<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="vue路由"><meta name="keywords" content="vue less route"><meta name="author" content="晟松"><meta name="copyright" content="晟松"><title>vue路由 | 晟松</title><link rel="shortcut icon" href="/logo.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c34d81d53341febe06a155941e2df16d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#router路由"><span class="toc-number">1.</span> <span class="toc-text">router路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#动态路由"><span class="toc-number">1.1.</span> <span class="toc-text">动态路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#嵌套路由"><span class="toc-number">1.2.</span> <span class="toc-text">嵌套路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编程式导航"><span class="toc-number">1.3.</span> <span class="toc-text">编程式导航</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命名路由"><span class="toc-number">1.4.</span> <span class="toc-text">命名路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重定向和别名"><span class="toc-number">1.5.</span> <span class="toc-text">重定向和别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#路由组件传参"><span class="toc-number">1.6.</span> <span class="toc-text">路由组件传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#路由守卫"><span class="toc-number">1.7.</span> <span class="toc-text">路由守卫</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#完整的导航解析流程"><span class="toc-number">1.8.</span> <span class="toc-text">完整的导航解析流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他"><span class="toc-number">1.9.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#路由元信息"><span class="toc-number">1.9.1.</span> <span class="toc-text">路由元信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#过渡动效"><span class="toc-number">1.9.2.</span> <span class="toc-text">过渡动效</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数据获取"><span class="toc-number">1.9.3.</span> <span class="toc-text">数据获取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#滚动行为"><span class="toc-number">1.9.4.</span> <span class="toc-text">滚动行为</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#路由懒加载"><span class="toc-number">1.9.5.</span> <span class="toc-text">路由懒加载</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">晟松</div><div class="author-info__description text-center">晟松的博客</div><div class="follow-button"><a href="https://gitee.com/cheng_song" target="_blank" rel="noopener">gitee</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">34</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">32</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">晟松</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">vue路由</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-15</time><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2.7k</span><span class="post-meta__separator">|</span><span>Reading time: 9 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><strong>B站老陈</strong></p>
<p>前面都没啥用，router路由才是核心</p>
<h3 id="router路由"><a href="#router路由" class="headerlink" title="router路由"></a>router路由</h3><p>根据不同的路径显示不同的页面。在router里面的index.js里面配置不同的路径显示的不同的组件或者页面。</p>
<p>根据选择的<router-link to ='/foo'>替换<router-view>标签来显示内容。在本质上还是一个页面。</p>
<p>所有的核心配置都在index.js里面</p>
<pre class=" language-js"><code class="language-js">
<span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    path<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>
    name<span class="token punctuation">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">//component: Home</span>
    components<span class="token punctuation">:</span><span class="token punctuation">{</span>
      nav<span class="token punctuation">:</span>navView<span class="token punctuation">,</span>
      aside<span class="token punctuation">:</span>asideView<span class="token punctuation">,</span>
      <span class="token keyword">default</span><span class="token punctuation">:</span>Home
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    path<span class="token punctuation">:</span><span class="token string">"/a"</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">//redirect:"/about"</span>
    redirect<span class="token punctuation">:</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>query<span class="token punctuation">.</span>go<span class="token operator">==</span><span class="token string">'about'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">"about"</span><span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">"news"</span><span class="token punctuation">,</span>params<span class="token punctuation">:</span><span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token number">456789</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span></code></pre>
<p>通过path，name，component设置。</p>
<p>我们可以在任何组件内通过 <code>this.$router</code> 访问路由器，也可以通过 <code>this.$route</code> 访问当前路由</p>
<h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a><strong>动态路由</strong></h4><p>把某种模式匹配到的所有路由，全都映射到同个组件。在path里面可使用通配符 <code>*</code>进行匹配任意路径，一般用于404页面。当使用一个通配符时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数，它包含了 URL 通过通配符被匹配的部分。当使用<em>通配符</em>路由时，请确保路由的顺序是正确的，也就是说含有<em>通配符</em>的路由应该放在最后。</p>
<p>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p>
<pre class=" language-js"><code class="language-js">routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>
<span class="token comment" spellcheck="true">// 动态路径参数 以冒号开头</span>
<span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true">//通过$route.params.id可获得路径后的id参数值</span>
<span class="token keyword">const</span> User <span class="token operator">=</span> <span class="token punctuation">{</span>
template<span class="token punctuation">:</span> <span class="token string">'&lt;div>User {{ $route.params.id }}&lt;/div>'</span>
<span class="token punctuation">}</span>
<span class="token punctuation">{</span>
<span class="token comment" spellcheck="true">// 会匹配以 `/user-` 开头的任意路径</span>
path<span class="token punctuation">:</span> <span class="token string">'/user-*'</span>
<span class="token punctuation">}</span>    </code></pre>
<p>可使用watch进行监听路由发生的变化</p>
<pre class=" language-js"><code class="language-js">watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">$route</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 对路由变化作出响应...</span>
    <span class="token punctuation">}</span></code></pre>
<h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a><strong>嵌套路由</strong></h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User<span class="token punctuation">,</span>
      children<span class="token punctuation">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">// 当 /user/:id/profile 匹配成功，</span>
          <span class="token comment" spellcheck="true">// UserProfile 会被渲染在 User 的 &lt;router-view> 中</span>
          path<span class="token punctuation">:</span> <span class="token string">'profile'</span><span class="token punctuation">,</span>
          component<span class="token punctuation">:</span> UserProfile
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">// 当 /user/:id/posts 匹配成功</span>
          <span class="token comment" spellcheck="true">// UserPosts 会被渲染在 User 的 &lt;router-view> 中</span>
          path<span class="token punctuation">:</span> <span class="token string">'posts'</span><span class="token punctuation">,</span>
          component<span class="token punctuation">:</span> UserPosts
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">//此时，基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由</span>
<span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> UserHome <span class="token punctuation">}</span></code></pre>
<p>使用children属性进行嵌套的配置。还可以继续进行嵌套。</p>
<p><strong>要注意，以 <code>/</code> 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径</strong></p>
<h4 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a><strong>编程式导航</strong></h4><p>(使用点击事件在js的mehtods里面使用)。除了使用 <code>&lt;router-link to=&quot;...&quot;&gt;</code>，<br>还可使用<code>router.push(location, onComplete?, onAbort?)</code>进行导航。</p>
<p>使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p>
<p>注意使用时的参数需要匹配：<strong>name params</strong>         <strong>path query</strong></p>
<p><strong>注意：在 Vue 实例内部，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code></strong></p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 字符串</span>
router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'home'</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 对象</span>
router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'home'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 命名路由</span>
router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span> params<span class="token punctuation">:</span> <span class="token punctuation">{</span> userId<span class="token punctuation">:</span> <span class="token string">'123'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 带查询参数，变成 /register?plan=private</span>
router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'register'</span><span class="token punctuation">,</span> query<span class="token punctuation">:</span> <span class="token punctuation">{</span> plan<span class="token punctuation">:</span> <span class="token string">'private'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> userId <span class="token operator">=</span> <span class="token string">'123'</span>
router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span> params<span class="token punctuation">:</span> <span class="token punctuation">{</span> userId <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -> /user/123</span>
router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`/user/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>userId<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -> /user/123</span>
<span class="token comment" spellcheck="true">// 这里的 params 不生效</span>
router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user'</span><span class="token punctuation">,</span> params<span class="token punctuation">:</span> <span class="token punctuation">{</span> userId <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -> /user</span></code></pre>
<p><strong>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，params将以path里面的为准</strong></p>
<p>router.replace()类似于push，只是替换掉history里面的当前记录</p>
<p>router.go(n)这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步</p>
<h4 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a><strong>命名路由</strong></h4><p>通过一个名称来标识一个路由</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      path<span class="token punctuation">:</span> <span class="token string">'/user/:userId'</span><span class="token punctuation">,</span>
      name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span>
      component<span class="token punctuation">:</span> User
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token punctuation">:</span>to<span class="token operator">=</span><span class="token string">"{ name: 'user', params: { userId: 123 }}"</span><span class="token operator">></span>User<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">></span>
<span class="token comment" spellcheck="true">//这跟代码调用 router.push() 是一回事：</span>
router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span> params<span class="token punctuation">:</span> <span class="token punctuation">{</span> userId<span class="token punctuation">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p><strong>命名视图</strong></p>
<p>同时 (同级) 展示多个视图，而不是嵌套展示，你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。之前router-link时，只有一个router-view进行替换，只会有一个视图，现在可通过命名视图将几个视图合在一个页面上。</p>
<p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。需要使用components进行配置，默认为default。也可配合嵌套路由，在childern里面使用命名视图。</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>router<span class="token operator">-</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"view one"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"view two"</span> name<span class="token operator">=</span><span class="token string">"a"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"view three"</span> name<span class="token operator">=</span><span class="token string">"b"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span>

<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      path<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>
      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token keyword">default</span><span class="token punctuation">:</span> Foo<span class="token punctuation">,</span>
        a<span class="token punctuation">:</span> Bar<span class="token punctuation">,</span>
        b<span class="token punctuation">:</span> Baz
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<h4 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a><strong>重定向和别名</strong></h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> redirect<span class="token punctuation">:</span> <span class="token string">'/b'</span> <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
重定向的目标也可以是一个命名的路由：
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> redirect<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'foo'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
甚至是一个方法，动态返回重定向目标：
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> redirect<span class="token punctuation">:</span> to <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 方法接收 目标路由 作为参数</span>
      <span class="token comment" spellcheck="true">// return 重定向的 字符串路径/路径对象</span>
    <span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>​    <code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> A<span class="token punctuation">,</span> alias<span class="token punctuation">:</span> <span class="token string">'/b'</span> <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p>
<h4 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a><strong>路由组件传参</strong></h4><p>在组件中使用 <code>$route</code> 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。使用 <code>props</code> 将组件和路由解耦：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> User <span class="token operator">=</span> <span class="token punctuation">{</span>
  template<span class="token punctuation">:</span> <span class="token string">'&lt;div>User {{ $route.params.id }}&lt;/div>'</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">//组件传参props</span>
<span class="token keyword">const</span> User <span class="token operator">=</span> <span class="token punctuation">{</span>
  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  template<span class="token punctuation">:</span> <span class="token string">'&lt;div>User {{ id }}&lt;/div>'</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User<span class="token punctuation">,</span> props<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>

    <span class="token comment" spellcheck="true">// 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span>
    <span class="token punctuation">{</span>
      path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span>
      components<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token punctuation">:</span> User<span class="token punctuation">,</span> sidebar<span class="token punctuation">:</span> Sidebar <span class="token punctuation">}</span><span class="token punctuation">,</span>
      props<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> sidebar<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p>在组件里也使用props将传入的数据拿到，进行数据显示。</p>
<h4 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a><strong>路由守卫</strong></h4><p>简单来说就是路由在跳转之前的验证，当满足条件时才会进行跳转。分为<code>全局守卫</code>，<code>路由守卫</code>和<code>组件守卫</code></p>
<p>1.注册全局守卫应该在路由模块暴露出去之前定义，所有的路由跳转都会被调用使用<code>router.beforeEach(function(to,from,next){})</code>来注册一个全局守卫。</p>
<p>参数：</p>
<ul>
<li><p>to：代表目标路径对象</p>
</li>
<li><p>from：来源路径对象</p>
</li>
<li><p>next：用于决定是否继续进行跳转。</p>
<p>当next()函数不传参数或者传入true的时候 则允许正常跳转；</p>
<p>当next()函数传入false时 会中断跳转(阻止跳转)；</p>
<p>当next()函数中<strong>传入路径</strong>时或者<strong>对象</strong>时(比如:{name:’xxx’})则会重定向到指定路径。</p>
</li>
</ul>
<p>2.路由守卫就是针对单个路由对象配置的守卫。<strong>beforeEnter</strong></p>
<p>假如我在users组件配置路由守卫，那么只有跳转到users路由时才会触发该守卫，跳转到其他路由时不会触发该守卫。</p>
<p>路由守卫的注册写在路由匹配规则数组里面：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    
    routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token comment" spellcheck="true">//...        </span>
    <span class="token punctuation">{</span>path<span class="token punctuation">:</span> <span class="token string">'/users'</span><span class="token punctuation">,</span>            
     component<span class="token punctuation">:</span> Users<span class="token punctuation">,</span>            
     name<span class="token punctuation">:</span> <span class="token string">'u'</span><span class="token punctuation">,</span>            
     beforeEnter<span class="token punctuation">:</span> <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                                    
         <span class="token function">next</span><span class="token punctuation">(</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">'Entey Users?'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           
<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>3.组件守卫是针对单个组件进行监听，在访问到该组件时才会触发。</p>
<p>写在组件里</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">let</span> Home <span class="token operator">=</span> <span class="token punctuation">{</span>
    template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`
        &lt;div>
            &lt;h1>首页&lt;/h1>
            &lt;router-view>&lt;/router-view>
            &lt;router-view name="b">&lt;/router-view>
        &lt;/div>
    `</span></span><span class="token punctuation">,</span>
    beforeRouteEnter <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 在渲染该组件的对应路由被 confirm 前调用</span>
    <span class="token comment" spellcheck="true">// 不！能！获取组件实例 `this`</span>
    <span class="token comment" spellcheck="true">// 因为当守卫执行前，组件实例还没被创建</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   beforeRouteUpdate <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 在当前路由改变，但是该组件被复用时调用</span>
    <span class="token comment" spellcheck="true">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span>
    <span class="token comment" spellcheck="true">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span>
    <span class="token comment" spellcheck="true">// 可以访问组件实例 `this`</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   beforeRouteLeave <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 导航离开该组件的对应路由时调用</span>
    <span class="token comment" spellcheck="true">// 可以访问组件实例 `this`</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<h4 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h4><ol>
<li><p>导航被触发。</p>
</li>
<li><p>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</p>
</li>
<li><p>调用全局的 <code>beforeEach</code> 守卫。</p>
</li>
<li><p>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</p>
</li>
<li><p>在路由配置里调用 <code>beforeEnter</code>。</p>
</li>
<li><p>解析异步路由组件。</p>
</li>
<li><p>在被激活的组件里调用 <code>beforeRouteEnter</code>。</p>
</li>
<li><p>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</p>
</li>
<li><p>导航被确认。</p>
</li>
<li><p>调用全局的 <code>afterEach</code> 钩子。</p>
</li>
<li><p>触发 DOM 更新。</p>
</li>
<li><p>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</p>
<hr>
</li>
</ol>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a><strong>路由元信息</strong></h5><p>路由的特有属性，写在meta:{ }里面，为后面的组件提供一些特定信息进行逻辑判断。</p>
<p>一个路由匹配到的所有路由记录会暴露为 <code>$route</code> 对象 (还有在导航守卫中的路由对象) 的 <code>$route.matched</code> 数组。因此，我们需要遍历 <code>$route.matched</code> 来检查路由记录中的 <code>meta</code> 字段。</p>
<h5 id="过渡动效"><a href="#过渡动效" class="headerlink" title="过渡动效"></a><strong>过渡动效</strong></h5><p>用 <code>&lt;transition&gt;</code> 组件给它添加一些过渡效果</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>transition name<span class="token operator">=</span><span class="token string">"slide"</span> mode<span class="token operator">=</span><span class="token string">"out-in"</span> 
enter<span class="token operator">-</span>active<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"animated bounceInLeft"</span> 
leave<span class="token operator">-</span>active<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"animated bounceOutRight"</span><span class="token operator">></span>
      <span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive<span class="token operator">></span>
        <span class="token operator">&lt;</span>router<span class="token operator">-</span>view<span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">></span>

    <span class="token operator">&lt;</span><span class="token operator">/</span>transition<span class="token operator">></span></code></pre>
<h5 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a><strong>数据获取</strong></h5><p>我们可以通过两种方式来实现：</p>
<ul>
<li><strong>导航完成之后获取</strong>：先完成导航，然后在接下来的组件生命周期created钩子中获取数据。在数据获取期间显示“加载中”之类的指示。</li>
<li><strong>导航完成之前获取</strong>：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示。如果数据获取失败，同样有必要展示一些全局的错误提醒。</li>
</ul>
<p>从技术角度讲，两种方式都不错 —— 就看你想要的用户体验是哪种。</p>
<h5 id="滚动行为"><a href="#滚动行为" class="headerlink" title="滚动行为"></a><strong>滚动行为</strong></h5><p>使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 <code>vue-router</code> 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p>
<p>当创建一个 Router 实例，你可以提供一个 <code>scrollBehavior</code> 方法</p>
<pre class=" language-js"><code class="language-js">scrollBehavior <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> savedPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>savedPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> savedPosition
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h5 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a><strong>路由懒加载</strong></h5><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">晟松</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://chengsong.info/2020/07/15/vue-router/">http://chengsong.info/2020/07/15/vue-router/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vue-less-route/">vue less route</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/07/19/vue-vuex/"><i class="fa fa-chevron-left">  </i><span>vue-vuex</span></a></div><div class="next-post pull-right"><a href="/2020/07/13/vue%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0/"><span>vue进一步学习</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://blog-1251750343.cos.ap-beijing.myqcloud.com/blog/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2021 By 晟松</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="icp"><a><span>湘ICP备2020021729号</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>