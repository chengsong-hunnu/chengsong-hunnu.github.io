<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue高级知识</title>
      <link href="/2020/07/15/vue%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/07/15/vue%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h5 id="B站老陈"><a href="#B站老陈" class="headerlink" title="B站老陈"></a>B站老陈</h5><p>1.socket.io(套接字),用于浏览器和服务器进行实时，双向，基于事件(异步)的通信。</p><p>socket. emit(‘名’,’数据’),发送客户端数据。socket.on(‘名’,function(data){})监听客户端或服务器发送的内容</p><p>服务器与客户端之间的连接以一个唯一的id进行标识，当一个新的用户浏览器进行与服务器的连接时，需要进行广播(sockets.emit())，将此连接的id广播给其他客户端，方便进行数据交流,使用socket.to(目标id).emit(‘名’,{数据})</p><p>命名空间，用以区分。通过socket.join和leave可以加入和离开房间</p><p>2.vue实现原理</p><p>首先vue可以当做一个构造函数，传入一个参数为对象。</p><p>3.less。css扩展语言，预处理器。让其可重复使用，但浏览器不支持，需要编译转化为css。使用</p><pre><code>lessc 源文件.less 目标文件.css</code></pre><p>将less文件编译成css文件。</p><p>使用@变量名 = xxx,定义全局可使用的变量。可混合带参数使用，直接在一个class里面引入另一个class名，即可将样式复制过来，参数也可在样式里面当一个变量。参数需要@符号声明。参数可以使用一个默认值，当没有参数传入时，就使用默认值。@_匹配模式，相当于匹配一些class，再加上一些样式。还可对变量进行计算可进行样式直接嵌套(不建议使用嵌套)</p><p>可使用@argument将所有的默认变量传入。</p><pre><code>.border_arg(@width: 1.75rem, @color: #e6e6e6, @style: solid) {    border: @arguments}</code></pre><p>在vue里面使用less：</p><p>需要在sytle标签里面设置lang属性为less。lang=”less”。</p><p>4.router路由</p><p>根据不同的路径显示不同的页面。在router里面的index.js里面配置不同的路径显示的不同的组件或者页面。根据选择的<router-link>替换<router-view/>来显示内容。在本质上还是一个页面。</p><p>所有的核心配置都在index.js里面</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token punctuation">{</span>    path<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>    name<span class="token punctuation">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//component: Home</span>    components<span class="token punctuation">:</span><span class="token punctuation">{</span>      nav<span class="token punctuation">:</span>navView<span class="token punctuation">,</span>      aside<span class="token punctuation">:</span>asideView<span class="token punctuation">,</span>      <span class="token keyword">default</span><span class="token punctuation">:</span>Home    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    path<span class="token punctuation">:</span><span class="token string">"/a"</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//redirect:"/about"</span>    redirect<span class="token punctuation">:</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>query<span class="token punctuation">.</span>go<span class="token operator">==</span><span class="token string">'about'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">"about"</span><span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">"news"</span><span class="token punctuation">,</span>params<span class="token punctuation">:</span><span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token number">456789</span><span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span></code></pre><p>通过path，name，component设置。</p><p>我们可以在任何组件内通过 <code>this.$router</code> 访问路由器，也可以通过 <code>this.$route</code> 访问当前路由</p><p><strong>动态路由</strong>，把某种模式匹配到的所有路由，全都映射到同个组件。在path里面可使用通配符 <code>*</code>进行匹配任意路径，一般用于404页面。当使用一个通配符时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 URL 通过通配符被匹配的部分</p><pre class=" language-js"><code class="language-js"> routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token comment" spellcheck="true">// 动态路径参数 以冒号开头</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User <span class="token punctuation">}</span>  <span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">//通过$route.params.id可获得路径后的id参数值</span>  <span class="token keyword">const</span> User <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;div>User {{ $route.params.id }}&lt;/div>'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 会匹配以 `/user-` 开头的任意路径</span>  path<span class="token punctuation">:</span> <span class="token string">'/user-*'</span>  <span class="token punctuation">}</span>    </code></pre><p>可使用watch进行监听路由发生的变化</p><pre class=" language-js"><code class="language-js">watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">$route</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 对路由变化作出响应...</span>    <span class="token punctuation">}</span></code></pre><p><strong>嵌套路由</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User<span class="token punctuation">,</span>      children<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 当 /user/:id/profile 匹配成功，</span>          <span class="token comment" spellcheck="true">// UserProfile 会被渲染在 User 的 &lt;router-view> 中</span>          path<span class="token punctuation">:</span> <span class="token string">'profile'</span><span class="token punctuation">,</span>          component<span class="token punctuation">:</span> UserProfile        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 当 /user/:id/posts 匹配成功</span>          <span class="token comment" spellcheck="true">// UserPosts 会被渲染在 User 的 &lt;router-view> 中</span>          path<span class="token punctuation">:</span> <span class="token string">'posts'</span><span class="token punctuation">,</span>          component<span class="token punctuation">:</span> UserPosts        <span class="token punctuation">}</span>      <span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>使用children属性进行嵌套的配置。还可以继续进行嵌套。</p><p><strong>编程式导航</strong>，除了使用 <code>&lt;router-link&gt;</code>，还可使用</p><p><code>router.push(location, onComplete?, onAbort?)</code>进行导航。使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 字符串</span>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'home'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 对象</span>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'home'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 命名的路由</span>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span> params<span class="token punctuation">:</span> <span class="token punctuation">{</span> userId<span class="token punctuation">:</span> <span class="token string">'123'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 带查询参数，变成 /register?plan=private</span>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'register'</span><span class="token punctuation">,</span> query<span class="token punctuation">:</span> <span class="token punctuation">{</span> plan<span class="token punctuation">:</span> <span class="token string">'private'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><strong>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，params将以path里面的为准</strong></p><p>router.go(n)这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步</p><p><strong>命名路由</strong></p><p>通过一个名称来标识一个路由</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/user/:userId'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> User    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token punctuation">:</span>to<span class="token operator">=</span><span class="token string">"{ name: 'user', params: { userId: 123 }}"</span><span class="token operator">></span>User<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">></span><span class="token comment" spellcheck="true">//这跟代码调用 router.push() 是一回事：</span>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span> params<span class="token punctuation">:</span> <span class="token punctuation">{</span> userId<span class="token punctuation">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><strong>命名视图</strong></p><p>同时 (同级) 展示多个视图，而不是嵌套展示，你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。之前router-link时，只有一个router-view进行替换，只会有一个视图，现在可通过命名视图将几个视图何在一个页面上。</p><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。需要使用components进行配置，默认为default。也可配合嵌套路由，在childern里面使用命名视图。</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>router<span class="token operator">-</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"view one"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span><span class="token operator">&lt;</span>router<span class="token operator">-</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"view two"</span> name<span class="token operator">=</span><span class="token string">"a"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span><span class="token operator">&lt;</span>router<span class="token operator">-</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"view three"</span> name<span class="token operator">=</span><span class="token string">"b"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token keyword">default</span><span class="token punctuation">:</span> Foo<span class="token punctuation">,</span>        a<span class="token punctuation">:</span> Bar<span class="token punctuation">,</span>        b<span class="token punctuation">:</span> Baz      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><strong>重定向和别名</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> redirect<span class="token punctuation">:</span> <span class="token string">'/b'</span> <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>重定向的目标也可以是一个命名的路由：<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> redirect<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'foo'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>甚至是一个方法，动态返回重定向目标：<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> redirect<span class="token punctuation">:</span> to <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 方法接收 目标路由 作为参数</span>      <span class="token comment" spellcheck="true">// return 重定向的 字符串路径/路径对象</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>​    <code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> A<span class="token punctuation">,</span> alias<span class="token punctuation">:</span> <span class="token string">'/b'</span> <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p><p><strong>路由组件传参</strong></p><p>在组件中使用 <code>$route</code> 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。使用 <code>props</code> 将组件和路由解耦：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> User <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;div>User {{ $route.params.id }}&lt;/div>'</span><span class="token punctuation">}</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//组件传参props</span><span class="token keyword">const</span> User <span class="token operator">=</span> <span class="token punctuation">{</span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;div>User {{ id }}&lt;/div>'</span><span class="token punctuation">}</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User<span class="token punctuation">,</span> props<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token punctuation">:</span> User<span class="token punctuation">,</span> sidebar<span class="token punctuation">:</span> Sidebar <span class="token punctuation">}</span><span class="token punctuation">,</span>      props<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> sidebar<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>在组件里也使用props将传入的数据拿到，进行数据显示。</p><p><strong>路由守卫</strong></p><p>简单来说就是路由在跳转之前的验证，当满足条件时才会进行跳转。分为<code>全局守卫</code>，<code>路由守卫</code>和<code>组件守卫</code></p><p>​    1.注册全局守卫应该在路由模块暴露出去之前定义，所有的路由跳转都会被调用使用<code>router.beforeEach(function(to,from,next){})</code>来注册一个全局守卫。</p><p>参数：</p><ul><li><p>to：代表目标路径对象</p></li><li><p>from：来源路径对象</p></li><li><p>next：用于决定是否继续进行跳转。</p><p>当next()函数不传参数或者传入true的时候 则允许正常跳转；</p><p>当next()函数传入false时 会中断跳转(阻止跳转)；</p><p>当next()函数中<strong>传入路径</strong>时或者<strong>对象</strong>时(比如:{name:’xxx’})则会重定向到指定路径。</p><p>2.路由守卫就是针对单个路由对象配置的守卫。</p></li></ul><p>假如我在users组件配置路由守卫，那么只有跳转到users路由时才会触发该守卫，跳转到其他路由时不会触发该守卫。</p><p>路由守卫的注册写在路由匹配规则数组里面：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token comment" spellcheck="true">//...        </span>        <span class="token punctuation">{</span>path<span class="token punctuation">:</span> <span class="token string">'/users'</span><span class="token punctuation">,</span>                     component<span class="token punctuation">:</span> Users<span class="token punctuation">,</span>                     name<span class="token punctuation">:</span> <span class="token string">'u'</span><span class="token punctuation">,</span>                     beforeEnter<span class="token punctuation">:</span> <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                                    <span class="token function">next</span><span class="token punctuation">(</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">'Entey Users?'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    3.组件守卫是针对单个组件进行监听，在访问到该组件时才会触发。</p><p>​    写在组件里</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">let</span> Home <span class="token operator">=</span> <span class="token punctuation">{</span>    template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`        &lt;div>            &lt;h1>首页&lt;/h1>            &lt;router-view>&lt;/router-view>            &lt;router-view name="b">&lt;/router-view>        &lt;/div>    `</span></span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 在路由跳转时,如果会访问到当前组件,则会触发该守卫</span>    <span class="token function">beforeRouteEnter</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">'Enter Home?'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 在路由跳转时,如果离开当前组件,则会触发该守卫</span>    beforeRouteLeave <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">'Leave Home?'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 在当前路径下,当路由的参数发生变化时，才会触发该路由守卫</span>    <span class="token function">beforeRouteUpdate</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>params<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>路由元信息</strong></p><p>路由的特有属性，写在meta:{ }里面，为后面的组件提供一些特定信息进行逻辑判断。</p><p><strong>过渡动效</strong></p><p>用 <code>&lt;transition&gt;</code> 组件给它添加一些过渡效果</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>transition name<span class="token operator">=</span><span class="token string">"slide"</span> mode<span class="token operator">=</span><span class="token string">"out-in"</span> enter<span class="token operator">-</span>active<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"animated bounceInLeft"</span> leave<span class="token operator">-</span>active<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"animated bounceOutRight"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive<span class="token operator">></span>        <span class="token operator">&lt;</span>router<span class="token operator">-</span>view<span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>transition<span class="token operator">></span></code></pre><p><strong>数据获取</strong></p><p><strong>滚动行为</strong></p><p>当创建一个 Router 实例，你可以提供一个 <code>scrollBehavior</code> 方法</p><pre class=" language-js"><code class="language-js">scrollBehavior <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> savedPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>savedPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> savedPosition  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>路由懒加载</strong></p><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue socket less route </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue学习-三</title>
      <link href="/2020/07/13/vue%E5%AD%A6%E4%B9%A0-%E4%B8%89/"/>
      <url>/2020/07/13/vue%E5%AD%A6%E4%B9%A0-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h5 id="单组件文件-vue"><a href="#单组件文件-vue" class="headerlink" title="单组件文件(.vue)"></a>单组件文件(.vue)</h5><p>1.解决了<strong>全局定义</strong> <strong>字符串模板</strong> <strong>不支持组件 CSS</strong>  <strong>没有构建步骤</strong>这些缺点，使关注点分离，模块化开发。</p><p>2.vue-cli    vue.js的<a href="https://cli.vuejs.org/zh/guide/prototyping.html" target="_blank" rel="noopener">标准开发工具</a></p><p>3.安装vue-cli按照官方文档的命令进行就可以了，不要其他的不加@符号的命令，在vscode终端里面目前是需要3版本以上。推荐使用git-bash进行npm下载或者cnpm下载。如果出现了什么命令没找到，注意添加安装路径到环境变量。如果安装好了，在bash里面vue –version没有问题，但在vscode终端里无法使用，将vscode设置成管理员打开。vue ui可以进行更简易化的创建配置操作。</p><p>4.在src目录里面开发，使用npm run serve看效果，npm run build打包到dist文件夹，可将dist文件夹部署到服务器，当做平常网站。注意绝对路径(/)，和相对路径(./)</p><p>5.将文件模块化，明确文件关系</p><p><strong>6.app.vue文件</strong>。核心文件，在template里面写html代码，script里面写js，style里面写css。注意全局使用驼峰命名，防止一些奇怪错误。</p><pre class=" language-vue"><code class="language-vue"><template>  <div id="app">    <chat-com></chat-com>    <userlist-com></userlist-com>  </div></template><script>import chatCom from './components/chatcom'import userlistCom from './components/userlistcom'export default {  name: 'App',  components: {    chatCom,    userlistCom  }}</script><style>#app {  font-family: Avenir, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;}</style></code></pre><p>使用import引入自定义组件，并在export default的component里面声明，里面的<strong>数据data是返回一个对象</strong>.</p><p>报错和解决方法：</p><p>1.Newline required at end of file but not found eol-last</p><p>在.vue文件的最后一行后面加一个空行，还只能加一个空行，多了不行</p><p>2.miss什么什么的，在miss的地方加空格。好吧，这是最考试创建的时候开启了eclint选项，是一个严格语法结构。不能使用tab，空格多了两个。</p><p>3.推荐使用vscode的格式化文档，再对照错误进行修改，字符串使用单引号。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue .vue 脚手架(vue-cli) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue学习(二)</title>
      <link href="/2020/07/13/vue%E5%AD%A6%E4%B9%A0-%E4%BA%8C/"/>
      <url>/2020/07/13/vue%E5%AD%A6%E4%B9%A0-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="vue的B站老陈学习"><a href="#vue的B站老陈学习" class="headerlink" title="vue的B站老陈学习"></a>vue的B站老陈学习</h4><p>那些基本的在前一篇大多都说了，这一篇记一些没说到的。</p><p>1.过渡动画，一般使用transition完成。例如</p><pre class=" language-html"><code class="language-html">&lt;transition name = "nameoftransition">   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">></span></span></code></pre><p>需要指定这个动画的名字。</p><p><strong>重点是css里面的css类名和css动画效果</strong></p><p>一般是动画名(例如fade)再加一些特定标识，如</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.fade-enter-active</span>, <span class="token class">.fade-leave-active</span> </span><span class="token punctuation">{</span>    <span class="token property">transition</span><span class="token punctuation">:</span> opacity <span class="token number">2</span>s<span class="token punctuation">}</span><span class="token selector"><span class="token class">.fade-enter</span>, <span class="token class">.fade-leave-to</span>  </span><span class="token punctuation">{</span>    <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token comment" spellcheck="true">/*opacity表示透明效果*/</span><span class="token punctuation">}</span></code></pre><p>active表示动画的进行时间，enter和leave-to表示刚进入的效果和最终离开时的效果。还有enter-to和leave这两个表示动画最后的效果和离开开始的过渡状态。</p><img src="https://www.runoob.com/wp-content/uploads/2018/06/transition.png" alt="img" style="zoom:50%;" /><p>还可以使用自定义的类名，可以和第三方css类插件库(如:animate.css)进行配合。</p><p>如：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span>    <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>custom-classes-transition<span class="token punctuation">"</span></span>    <span class="token attr-name">enter-active-class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>animated tada<span class="token punctuation">"</span></span>    <span class="token attr-name">leave-active-class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>animated bounceOutRight<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">></span></span></code></pre><p>此外还有enter-class,leave-class,enter-to-class,leave-to-class.与上面相对应。</p><p>过渡时间你也可以在transition里面是绑定duration进行设置。如：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span> <span class="token attr-name">:duration</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span> <span class="token attr-name">:duration</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{ enter: 500, leave: 800 }<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">></span></span></code></pre><p>2.生命周期</p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue å®ä¾çå½å¨æ" style="zoom:33%;" /><p>我们能拿到的只有红色框里面的东西，中间的都是vue自动完成，我们无法控制。一般直接在vue实例里面添加这些东西进行控制。如：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//进行控制.</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a is: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>在beforeCreate里面输出this和vue里面的data会有不同，this表示vue实例刚创建，但data里面的数据还没有绑定，会输出undefined，同时methods这些也没有绑定</p><p>在beforeCreate和created这中间就是绑定data和methods这些。</p><p>created之后就是渲染页面，在渲染之前绑定的一些数据在vue实例里面不会拿到，虽然在浏览器html里面有了。在渲染之后(mounted)就可以拿到这些dom对象。</p><p>当数据被修改，也会有两个阶段，在before阶段，虽然数据修改了，但内容还没渲染修改，在updated后，就会重新渲染，内容也改变了。</p><p>销毁一般很少调用。</p><p>3.组件感觉还有一些东西要写。</p><p>prop传递数据（子组件用来接受父组件传递过来的数据的一个自定义属性）：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">message</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hello!<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parentMsg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>//动态prop传递数据      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>message1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parentMsg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token comment" spellcheck="true">// 注册</span>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'child'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 声明 props</span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'message'</span><span class="token punctuation">,</span><span class="token string">'message1'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 同样也可以在 vm 实例中像 "this.message" 这样使用</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;span>{{ message }}+{{message1}}&lt;/span>'</span><span class="token punctuation">}</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>自定义事件（子组件要把数据传递回去，就需要使用自定义事件）</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>counter-event-example<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>{{ total }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button-counter</span> <span class="token attr-name"><span class="token namespace">v-on:</span>increment</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>incrementTotal<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button-counter</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button-counter</span> <span class="token attr-name"><span class="token namespace">v-on:</span>increment</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>incrementTotal<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button-counter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'button-counter'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;button v-on:click="incrementHandler">{{ counter }}&lt;/button>'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      counter<span class="token punctuation">:</span> <span class="token number">0</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    incrementHandler<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>counter <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//触发increment事件,在v-on监听里面触发，调用vue实例里面的函数</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">'#counter-event-example'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    total<span class="token punctuation">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    incrementTotal<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>total <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>component里面的data必须是一个函数，为了保证每个组件的数据不共用。注意驼峰命名法在html里面需要转换成横线格式。</p><p>同时有$parent,$children,$root属性，可以在组件中找到父元素的vue对象，子元素的，根(最外层对象)的这些，之后就可以当做vue对象进行调用方法之类的。</p><p>v-model也可以绑定到组件上，默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，需要在组件的template里面添加相应监听和$emit()调用。</p><p><strong>一般使用.vue分开使用组件的话</strong></p><p><strong>父组件给子组件传递数据：在父组件的子组件标签里面通过v-bind绑定一个<u>特定名</u>和数据。在子组件里使用props声明这个<u>特定名</u>，然后就可以使用这个特定名进行数据使用。</strong></p><p><strong>子组件给父组件传递数据和使用父组件的方法：</strong></p><p>​    <strong>1.在父组件的子组件标签里面通过v-on监听一个<u>特定名</u>和一个在父组件里面的methods的方法名，在子组件里面自定义一个点击事件之类的，触发在子组件里面自定义的方法，在这个方法里面通过this.$emit(‘<u>特定名</u>‘,’数据’)，就会通过这个特定名调用父组件里面的方法，数据也作为参数传递了过去。</strong></p><p>​    <strong>2.在父组件里通过v-bind绑定一个<u>特定名</u>和<u>父组件方法</u>，在子组件里通过props声明这个特定名，然后就可以把这个<u>特定名</u>当做一个方法进行使用</strong></p><p>4.插槽。整体结构不变，但要插入一些内容。<slot></slot>,新版本(2.6.0)可使用v-slot。一般来说，在自定义组件的标签里面添加内容，是不会被渲染到页面上去的，但slot解决了这个问题。<slot>在组件的template里面添加使用，添加之后，当在组件标签里面添加内容时，slot将会被替换掉，内容可被渲染到页面上。一个组件的template最外层只会有一个标签，一般可使用一个div将所有元素进行包裹。</p><p><strong>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</strong></p><p>5.动态组件。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>is</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>currentTabComponent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">></span></span></code></pre><p>可使用is属性切换不同的组件。</p><p>is用法。其中currentTabComponent是在vue实例里面进行数据定义，然后在局部定义组件和方法进行切换currentTabComponent，在this.$options.components[id]，this表示vue实例，获取到组件实例，之后将component标签替换成这个组件。</p><p>一般切换的时候，都会重新渲染组件。当我们不想让其重新渲染的时候，就可以使用<keep-alive>标签。如</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>is</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>currentTabComponent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">></span></span></code></pre><p> keep-alive要求被切换到的组件都有自己的名字，不论是通过组件的 <code>name</code>选项还是局部/全局注册。</p><p>因为一些标签 有一些限制出现的地方，如<li>，为了避免这些情况，在组件中的template使用<strong>单文件组件(.vue文件)</strong>就不会存在这些限制，这也是重点。</p><p>6.<strong>单文件组件(.vue文件)</strong></p><p>脚手架。.vue文件解决了<strong>全局定义</strong> <strong>字符串模板</strong> <strong>不支持组件 CSS</strong>  <strong>没有构建步骤</strong>这些缺点</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue 老陈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue学习(一)</title>
      <link href="/2020/07/11/vue%E5%AD%A6%E4%B9%A0-%E4%B8%80/"/>
      <url>/2020/07/11/vue%E5%AD%A6%E4%B9%A0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h5 id="vue的黑马学习"><a href="#vue的黑马学习" class="headerlink" title="vue的黑马学习"></a>vue的黑马学习</h5><p>1.vue作用范围，只有在vue实例的el挂载点里面及其后代元素才会进行这个vue实例的操作。不仅可以使用id选择器，class选择器也行，使用.class进行el挂载。其他的选择器也都能行。可以使用其他的双标签，但不能是body和html标签。</p><p>2.Vue中用到的数据定义在data中，data中可以写复杂类型的数据，渲染复杂类型数据时,遵守js的语法即可</p><p>3.dom操作是获取元素，操作它们。vue使用指令操作</p><p>4.v-text指令。直接替换标签里面的所有文字和数据。跟两个大括号没什么差别。</p><p>5.v-html，设置标签的innerHTML，就是将纯html文本解析成html效果。</p><p>6.v-on，为元素绑定事件，类似onclick等。v-on:click=”函数名”,函数在vue实例的methods里面定义，methods:{click:function(){ }, other:{ } }。同时，在函数名后面可以传递参数，相应在定义函数时也要添加这个参数。还可以使用(.)表示的指令后缀调用修饰符。如@click.once=””,只会调用一次，@keyup.enter=””这些。</p><p>7.v-show,根据表达值的真假，切换元素的显示和隐藏。本质就是切换display属性。</p><p>8.v-if,v-if=”值”,根据值的真假，判断是否显示，但不是操纵display，而是直接操纵dom元素。</p><p>9.v-bind,设置元素的属性。v-bind:属性名=”属性值”，一般属性值在data里面进行定义。</p><p>10.v-for,生成列表。格式v-for=”item in items”，在data里面对items进行数据设置，一般是数组或者对象或者对象数组。使用对象时，可使用(value,key,index) in object 对对象进行数据访问。</p><p>11.v-model，获取和设置表单元素的值(进行双向数据绑定)。就是表单中的数据发生改变时，另一个绑定的数据元素也会发生改变。一般用来获取输入文本框中的输入数据.</p><p>12.网络请求(axios).一般使用get和post</p><p>例如：</p><pre class=" language-js"><code class="language-js">axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"https://autumnfish.cn/api/joke/list?num=1"</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">{</span>                        that<span class="token punctuation">.</span>joke<span class="token operator">=</span>response<span class="token punctuation">.</span>data<span class="token punctuation">.</span>jokes<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里不能通过this访问joke，this的范围已经发生了变化</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>data<span class="token punctuation">.</span>jokes<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue学习</title>
      <link href="/2020/07/08/vue%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/08/vue%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="关于自己对Vue学习的一些重点和理解"><a href="#关于自己对Vue学习的一些重点和理解" class="headerlink" title="关于自己对Vue学习的一些重点和理解"></a>关于自己对Vue学习的一些重点和理解</h4><p>学习的地方包括Vue自己的网站，菜鸟教程，B站等</p><h5 id="1-vue对象中会有两个重要的属性，el和data，表示绑定的属性和数据。"><a href="#1-vue对象中会有两个重要的属性，el和data，表示绑定的属性和数据。" class="headerlink" title="1.vue对象中会有两个重要的属性，el和data，表示绑定的属性和数据。"></a>1.vue对象中会有两个重要的属性，el和data，表示绑定的属性和数据。</h5><h5 id="2-模板语法"><a href="#2-模板语法" class="headerlink" title="2.模板语法"></a>2.模板语法</h5><p>插值：数据绑定：文本：, v-once；原始html：v-html，将html文本转换为html样式；作用于html 的attribute：v-bind,</p><p>指令：指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute,一些指令可以带参数。</p><p>动态参数：可以用方括号括起来的 JavaScript 表达式作为一个指令的参数。可以使用null字符串显式的移除此属性。</p><p><strong><code>v-bind</code> 指令可以用于响应式地更新 HTML attribute，</strong></p><p><strong><code>v-on</code> 指令，它用于监听 DOM 事件,</strong>进行事件处理</p><h5 id="3-计算属性和侦听器"><a href="#3-计算属性和侦听器" class="headerlink" title="3.计算属性和侦听器"></a>3.计算属性和侦听器</h5><p>​    1.对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>computed。</p><p>​    2.我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。只要值没有发生变化，就不会再次计算属性，直接返回上一次的计算结果。而方法会每一次重新渲染时都重新计算。</p><p>​    3.Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：<strong>侦听属性</strong> </p><h5 id="4-class和style绑定"><a href="#4-class和style绑定" class="headerlink" title="4.class和style绑定"></a>4.class和style绑定</h5><p>​    1.对象语法，使用v-bind:class指令。</p><p>​    2.绑定内联样式，v-bind:style指令。是一个js对象</p><h5 id="5-条件渲染"><a href="#5-条件渲染" class="headerlink" title="5.条件渲染"></a>5.条件渲染</h5><p>​    1.v-if条件性的渲染一部分内容，使用<template>进行包裹，再使用v-if可以渲染多个内容。还有配套的 v-else,还有v-else-if进行连续使用。</p><p>​    2.v-show的使用与v-if差不多，但没有v-else这些。同时因为各自特性，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p><h5 id="6-列表渲染"><a href="#6-列表渲染" class="headerlink" title="6.列表渲染"></a>6.列表渲染</h5><p>​    1.v-for，使用item in items的格式执行。其中items需要在vue里面的data里指定数据。也可使用value in object进行对象循环，也可使用(value, name, index)进行对象里面的数据，键名，索引访问。也可以使用n in 10进行循环。类似于 <code>v-if</code>，你也可以利用带有 <code>v-for</code> 的 <code>&lt;template&gt;</code> 来循环渲染一段包含多个元素的内容。</p><h5 id="7-事件处理"><a href="#7-事件处理" class="headerlink" title="7.事件处理"></a>7.事件处理</h5><p>​    1.v-on监听dom事件，并执行一些js代码。还可以接收一个需要调用的方法名称。在vue的methods里面添加方法。</p><p>​    Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><pre><code>&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</code></pre><p>​    使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p><p>​    2.监听按键事件时，可以使用按键修饰符，如：v-on:keyup.enter，只有enter键可以触发事件。</p><h5 id="8-表单输入绑定"><a href="#8-表单输入绑定" class="headerlink" title="8.表单输入绑定"></a>8.表单输入绑定</h5><p>​    1.v-model，创建双向数据绑定，一处数据发生变化，另一处也会发生变化。</p><p>​    <code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li><li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</li><li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li></ul><p>​    2.文本，多行文本，复选框，单选按钮，选择框。</p><p>​    3.值绑定</p><p>​    4.修饰符，.lazy;.number;.trim</p><h5 id="9-组件"><a href="#9-组件" class="headerlink" title="9.组件"></a>9.组件</h5><p>​    1.组件可以扩展 HTML 元素，封装可重用的代码，是可复用的vue实例。组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树。<strong>每个组件都只有一个根元素</strong></p><p>​    2.Vue.component创建组件，第一个参数是组件名称，第二个参数是以对象的实例描述一个组件。通过将组件名作为标签进行调用。<strong>一个组件的 <code>data</code> 选项必须是一个函数</strong>，多个组件的使用，其数据都是分开的，不会互相影响。</p><p>​    3.组件需要注册，Vue.component全局注册，先在js里定义组件，再在vue实例中通过component定义想使用的组件局部注册。</p><p>​    4.组件里使用prop向子组件传递数据，当做自定义的attribute传递数据。也可使用v-bind动态传递prop，且是单向的。</p><p>​    5.监听子组件事件，父级组件可以像处理 native DOM 事件一样通过 <code>v-on</code> 监听子组件实例的任意事件：</p><pre><code>&lt;blog-post  ...  v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&gt;&lt;/blog-post&gt;</code></pre><p>同时子组件可以通过调用内建的 <a href="https://cn.vuejs.org/v2/api/#vm-emit" target="_blank" rel="noopener"><strong><code>$emit</code></strong> 方法</a>并传入事件名称来触发一个事件：</p><pre><code>&lt;button v-on:click=&quot;$emit(&#39;enlarge-text&#39;)&quot;&gt;  Enlarge text&lt;/button&gt;</code></pre><p>​    6.<slot>内容</slot>，在组件里面通过vue自定义的slot可以实现插槽效果。</p><p>​    7.动态组件，通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 <code>is</code> attribute 来实现。</p><h5 id="10-自定义事件"><a href="#10-自定义事件" class="headerlink" title="10.自定义事件"></a>10.自定义事件</h5><p>​    1.Vue.directive自定义指令，第一个参数是名字，或在vue实例中通过directives局部注册。会有几个钩子函数bind,inserted,update,componentUpdated,unbind.</p><p>差不多这篇文章就不想写了，看其他的吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猎奇作品(以后有时间会更新)</title>
      <link href="/2020/07/08/%E7%8C%8E%E5%A5%87%E4%BD%9C%E5%93%81/"/>
      <url>/2020/07/08/%E7%8C%8E%E5%A5%87%E4%BD%9C%E5%93%81/</url>
      
        <content type="html"><![CDATA[<h4 id="就是记录一下一些看过的猎奇作品"><a href="#就是记录一下一些看过的猎奇作品" class="headerlink" title="就是记录一下一些看过的猎奇作品"></a>就是记录一下一些看过的猎奇作品</h4><p>1.鱼毛骨悚然的蠕动</p><p>​        动漫观感一般，后遗感2小时以内，留的坑有些多，不讨论其内涵，就画面来说对于猎奇这点还是有一些诠释，就是有些地方密恐慎入。</p><p>2.芽衣恶虐，恶梦轮回</p><p>​        这两部作品着实有些血腥，生理性有些不适。都是漫画，大概50页左右，后遗感1小时左右吧，血腥，色情，生理性不适，<strong>慎看</strong> 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 猎奇,记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android room简单学习</title>
      <link href="/2020/07/07/android-room%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/07/android-room%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="room"><a href="#room" class="headerlink" title="room"></a>room</h3><p>1.要使用room需要先声明依赖，<a href="https://developer.android.google.cn/jetpack/androidx/releases/room#declaring_dependencies" target="_blank" rel="noopener">声明方法</a><br><strong>注意要在app模式下的build.gradle(module:app)里面添加依赖，不要在project里面的gradle里面添加。</strong></p><p>2.room由3个主要的组件，分别为<br>Database：数据库，<br>Entity：数据库中的表，<br>DAO：访问数据库的方法。</p><p>3.room可以使用一个Java类文件当做数据库的表，只需使用@Entity注解。<br>里面有几个主要的注解使用<br><strong>也可以在@Entity注解后面使用tablename声明表的名称</strong><br> <strong>@PrimaryKey(autoGenerate = true) // 设置主键，并且自动生长</strong><br> <strong>@ColumnInfo(name = “true_name”) // 设置别名，如果不设置就默认为变量名</strong><br> 在其中可以定义需要的变量且对其中每一个变量都需要写出其set方法和get方法。</p><p> 4.之后我们使用DAO来对数据库进行访问<br> 同样我们需要使用一个Java接口类文件，同时使用@DAO 注解<br> 其中里面有4个主要的注解进行使用<br> <strong>@Insert 表示插入记录。<br>@Update 表示修改数据库中的记录。<br>@Delete 表示删除数据库中记录。<br>@Query(“ “) 中可以写入SQL语句，来执行操作。</strong></p><p>5.创建一个Database，同样要使用@Database注解，且在其中需要指明entities和version<br><strong>Database 文件必须要继承 **androidx.room.RoomDatabase</strong>，并且得是抽象类。**</p><p>之后就是建立一个布局，将数据库里面的数据显示出来，并与DAO的几个操作通过点击进行交互。</p><p><a href="https://github.com/chengsong-hunnu/local-github/tree/master/room" target="_blank" rel="noopener">主要代码在这里</a></p><p>主要借鉴了<a href="https://blog.csdn.net/weixin_43734095/article/details/100182369?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">萌宅鹿</a>和<a href="https://developer.android.google.cn/training/data-storage/room" target="_blank" rel="noopener">android studio官方</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> csdn room </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp fork的一些代码运行和理解</title>
      <link href="/2020/07/07/csapp-fork%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%92%8C%E7%90%86%E8%A7%A3/"/>
      <url>/2020/07/07/csapp-fork%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%92%8C%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p><strong>1.</strong> 先说一点简单的fork定义<br>1.创建一个新进程，新进程被称为子进程。两者最大的区别在于pid不同，一般通过返回值分辨是哪个进程。<br>2.fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。<br>3.子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。各自都有自己的独立地址。<br>4.两者的执行顺序是随机并发执行的，也就是不能判断执行顺序。</p><p><strong>2</strong> 为什么fork会返回两次？<br>由于在复制时复制了父进程的堆栈段，所以两个进程都停留在fork函数中，等待返回。因此fork函数会返回两次，一次是在父进程中返回，另一次是在子进程中返回，这两次的返回值是不一样的，<strong>父进程返回子进程的pid，子进程返回0</strong><br><strong>3</strong>现在来看下一些代码吧：<br>1.</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fork1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child has x = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">++</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Parent has x = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">--</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Bye from process %d with x = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>结果：<img src="https://img-blog.csdnimg.cn/2019110910200816.png" alt="在这里插入图片描述"><br>先fork一个子进程，这次子进程先执行，之后再试父进程，最后得到这个结果。</p><p>下面有一些关键字，<a href="https://blog.csdn.net/GEAUSE/article/details/102933742" target="_blank" rel="noopener">waitpid等</a>，可以去看一下。</p><p>2.下一个是关于僵尸进程的问题</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">fork7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Child */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Terminating Child, PID = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Running Parent, PID = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Infinite loop */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：<img src="https://img-blog.csdnimg.cn/20191109103227316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>僵死进程</strong>：是指子进程退出时，父进程并未对其发出的SIGCHLD信号进行适当处理，导致子进程停留在僵死状态等待其父进程为其回收，这个状态下的子进程就是僵死进程。</p><p>主进程运行然后fork一个子进程，父进程因为while（1），一直在后台运行，但是子进程正常执行完程序。最后在后台卡住，使用Ctrl+z挂起这个程序，之后ps命令去看可看见这个程序的父进程（pid=4300）还是在后台挂起，只能用kill命令强制结束。</p><p><strong>3.</strong> 这个是关于孤儿进程</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">fork8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Child */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Running Child, PID = %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Infinite loop */</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Terminating Parent, PID = %d\n"</span><span class="token punctuation">,</span>                   <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：<br><img src="https://img-blog.csdnimg.cn/20191109104910232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>孤儿进程</strong>：父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(pid=1)所收养，并由init进程对它们完成状态收集工作。</p><p>由ps命令可看见子进程（pid=4304）还在后台运行，这就是一个孤儿进程。</p><p><strong>4.</strong>关于wait</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> N 5</span><span class="token keyword">void</span> <span class="token function">fork10</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> child_status<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Child */</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Parent */</span>        pid_t wpid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>child_status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated with exit status %d\n"</span><span class="token punctuation">,</span>                   wpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">else</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminate abnormally\n"</span><span class="token punctuation">,</span> wpid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fork11</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> child_status<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Child */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> N<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pid_t wpid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>child_status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated with exit status %d\n"</span><span class="token punctuation">,</span>                   wpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">else</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminate abnormally\n"</span><span class="token punctuation">,</span> wpid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：<img src="https://img-blog.csdnimg.cn/20191109113504188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于<strong>fork10</strong>，通过for循环先fork一个子进程，父进程进行到wait暂停，之后子进程运行exit正常退出，给出一个信号给父进程，然后根据wait的特点，父进程继续执行输出语句。</p><p>对于<strong>fork11</strong>，通过for循环先fork一个子进程，父进程进行到waitpid(pid[i],&amp;child_status, 0)暂停，之后waitpid等待着pid[i]的子进程结束，之后for（0-4）正常结束子进程，for（4-0）waitpid返回子进程结束值，之后执行输出语句。</p><p><strong>5</strong>关于信号</p><pre class=" language-c"><code class="language-c"> <span class="token operator">*</span><span class="token operator">/</span><span class="token keyword">void</span> <span class="token function">fork12</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> child_status<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Child: Infinite Loop */</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Killing process %d\n"</span><span class="token punctuation">,</span> pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">kill</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> SIGINT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//杀死此进程</span>        <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pid_t wpid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>child_status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated with exit status %d\n"</span><span class="token punctuation">,</span>wpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">else</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated abnormally\n"</span><span class="token punctuation">,</span> wpid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">*</span> fork12 <span class="token operator">-</span> Sending signals with the <span class="token function">kill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> function<span class="token punctuation">,</span>发送信号给前一个参数的进程 cheng@晟松<span class="token punctuation">:</span><span class="token operator">/</span>mnt<span class="token operator">/</span>d<span class="token operator">/</span>计算机基础代码测试<span class="token operator">/</span>chap8_code$ <span class="token punctuation">.</span><span class="token operator">/</span>forks <span class="token number">12</span>Killing process <span class="token number">34</span>Killing process <span class="token number">35</span>Killing process <span class="token number">36</span>Killing process <span class="token number">37</span>Killing process <span class="token number">38</span>Child <span class="token number">34</span> terminated abnormallyChild <span class="token number">35</span> terminated abnormallyChild <span class="token number">36</span> terminated abnormallyChild <span class="token number">37</span> terminated abnormallyChild <span class="token number">38</span> terminated abnormally <span class="token operator">*</span><span class="token operator">/</span></code></pre><p>kill（）函数就是给一个信号给进程。<a href="https://blog.csdn.net/qq_42152681/article/details/90261295" target="_blank" rel="noopener">参考kill()函数</a><br>此函数里面父进程被强制结束，子进程一直循环，结果子进程被系统自动回收，WIFEXITED()不能得到信号，最后显示出子进程被异常终止。</p>]]></content>
      
      
      
        <tags>
            
            <tag> csdn fork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统基础二</title>
      <link href="/2020/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
      <url>/2020/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机系统基础（二）"><a href="#计算机系统基础（二）" class="headerlink" title="计算机系统基础（二）"></a>计算机系统基础（二）</h2><h4 id="5-优化程序性能"><a href="#5-优化程序性能" class="headerlink" title="5    优化程序性能"></a>5    优化程序性能</h4><p>1.用度量标准（CPE）<strong>每元素的周期数</strong><br>2.一般优化方面为：消除循环的低效率（尽量顺序循环），减少过程调用，消除不必要的内存引用。</p><h4 id="6-存储器层次结构"><a href="#6-存储器层次结构" class="headerlink" title="6 存储器层次结构"></a>6 存储器层次结构</h4><p>1.随机访问存储器（RAM）:静态（SRAM）不需要刷新，稳定，一般用于高速缓存；动态（DRAM）不稳定，一般用于主存。都是易失的（断电就没了）<br>2.非易失性存储器（ROM），整体上都被称为只读存储器。一般用于外存<br>3.磁盘：由盘片组成，一般有多张盘片，磁道，扇区。</p><p>容量一般由记录密度，磁道密度，面密度决定。<br>容量 = 每个扇区的字节数 x 磁道上的平均扇区数 x 磁盘一面的磁道数 x 磁盘的面数 x 硬盘包含的磁盘数<br>访问时间一般由寻道时间，旋转时间，传送时间决定。<br>总的访问时间 = 寻址时间 + 旋转时间 + 传输时间 </p><p>寻址时间 因为物理规律的限制，一般是 3-9 ms<br>旋转延迟 取决于硬盘具体的转速，一般来说是 7200 RPM<br>传输时间 就是需要读取的扇区数目<br><img src="https://img-blog.csdnimg.cn/20191116121449266.png" alt="在这里插入图片描述"><br>4.固态硬盘<br>固态硬盘中分成很多的块，每个块又有很多页，大约 32-128 个，每个页可以存放一定数据，页是进行数据读写的最小单位。但是有一点需要注意，对一个页进行写入操作的时候，需要先把整个块清空（设计限制），而一个块大概在 100,000 次写入之后就会报废。<br>5.局部性<br>时间局部性： 如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。程序循环、堆栈等是产生时间局部性的原因。<br>空间局部性: 在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的<br>顺序局部性: 在典型程序中，除转移类指令外，大部分指令是顺序进行的。顺序执行和非顺序执行的比例大致是5:1。此外，对大型<strong>数组</strong>访问也是顺序的。指令的顺序执行、数组的连续存放等是产生顺序局部性的原因。<br>6.高速缓存<br><img src="https://img-blog.csdnimg.cn/20191116124629347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>每一层都可以看作是下一层的缓存，主存中的信息按“块” 送到Cache中。<br>缓存命中：在对应的层中找到需要的数据<br><strong>缓存不命中</strong>：对应的层没有找到数据，需要从下一层中取出需要的数据，有时候会需要覆盖。<br>强制性失效: CPU 第一次访问相应缓存块，缓存中肯定没有对应数据，这是不可避免的。<br>冲突失效：在直接相联或组相联的缓存中，不同的缓存块由于索引相同相互替换，引起的失效叫做冲突失效。<br>容量失效: 有限的缓存容量导致缓存放不下而被替换，被替换出去的缓存块再被访问，引起的失效叫做容量失效。<br>7.高速缓冲存储器<br> 高速缓冲存储器的三个关键组成部分（注意区分大小写）：</p><p>S 表示集合(set)数量<br>E 表示数据行(line)的数量<br>B 表示每个缓存块(block)保存的字节数目<br><img src="https://img-blog.csdnimg.cn/20191116132546630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">地址宽度m=s+t+b<br><img src="https://img-blog.csdnimg.cn/20191116135814907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先确定组索引对应的组，再看有效为是否为1，再去比对标记位，最后看块偏移，得到数据。<br>标记位和索引位连起来唯一的标识内存中的每个块。</p><h4 id="7-链接"><a href="#7-链接" class="headerlink" title="7.链接"></a>7.链接</h4><p><a href="https://blog.csdn.net/qq_43977818/article/details/102230859#" target="_blank" rel="noopener">之前的一些记录</a></p><h4 id="8-异常控制流"><a href="#8-异常控制流" class="headerlink" title="8.异常控制流"></a>8.异常控制流</h4><p><a href="https://blog.csdn.net/qq_43977818/article/details/102983925#" target="_blank" rel="noopener">fork的一些记录</a></p><h4 id="9-虚拟内存"><a href="#9-虚拟内存" class="headerlink" title="9.虚拟内存"></a>9.虚拟内存</h4><p>1.分页，通过页表实现逻辑地址向物理地址的转换。<br>2.每个虚拟页都可以被映射到任何的物理页上。</p><h5 id="3-地址翻译："><a href="#3-地址翻译：" class="headerlink" title="3.地址翻译："></a><strong>3.地址翻译：</strong></h5><p><strong>从虚拟地址找到物理地址，再物理地址在缓存中找到数据<br>vpn在TLB中找到PPN，物理地址中的CI在缓存中找到对应的组，在CT标记位对应，最后CO 块偏移找到相应字节</strong><br>先来了解<strong>以下参数</strong>：</p><p>N=2^n^,M=2^m^,P=2^p^<br>其中 N 表示虚拟地址空间中的地址数量，M 表示物理地址空间中的地址数量，P 是每一页包含的字节数(page size)。</p><p>虚拟地址(VA, Virtual Address)中的元素：</p><p>TLBI: TLB 的索引值<br>TLBT: TLB 的标签(tag)<br>VPO: 虚拟页偏移量<br>VPN: 虚拟页编号<br>物理地址(PA, physical address)中的元素：</p><p>PPO: 物理页偏移量（与 VPO 的值相同）<br>PPN: 物理页编号<br><img src="https://img-blog.csdnimg.cn/20191116232117177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>具体的访问过程为</strong>：</p><p>通过虚拟地址找到页表(page table)中对应的条目<br>检查有效位(valid bit)，是否需要触发页错误(page fault)<br>然后根据页表中的物理页编号(physical page number)找到内存中的对应地址<br>最后把虚拟页偏移(virtual page offset)和前面的实际地址拼起来，就是最终的物理地址了<br>这里又分两种情况：Page Hit 和 Page Fault。<br><img src="https://img-blog.csdnimg.cn/20191123110317476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20191123110746831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.C程序中的内存错误（P609）</p>]]></content>
      
      
      
        <tags>
            
            <tag> csdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的建立</title>
      <link href="/2020/07/07/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
      <url>/2020/07/07/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
      
        <content type="html"><![CDATA[<p>对这个博客，确实有很多的问题，自己都删了好几次文件，从新来搞，才搞成这样，可能还有一些的问题在里面，等后面发现了，就继续改进。现在就有一些问题就很烦，就是github.io过一段时间就不能进行访问了，相当于这个网页就没了，就是这个问题搞了好久，最后只能重新重头开始再搞一次。在网上也没找到什么解决办法，看后面怎么搞。下一个就是关于这个github和自己的域名的链接，上次一搞就崩了，希望这次不崩。</p><h4 id="首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。"><a href="#首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。" class="headerlink" title="首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。"></a>首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。</h4><p>1.<a href="https://yafine-blog.cn/posts/4ab2.html#1-%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B8%83%E5%88%B0Github-Pages" target="_blank" rel="noopener">过客～励む</a></p><p>2.<a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">遇见西门</a></p><p>3.<a href="https://space.bilibili.com/384068749/" target="_blank" rel="noopener">B站codesheep</a></p><h5 id="后面再说一下一些我碰见的问题和解决方法。"><a href="#后面再说一下一些我碰见的问题和解决方法。" class="headerlink" title="后面再说一下一些我碰见的问题和解决方法。"></a>后面再说一下一些我碰见的问题和解决方法。</h5><p>首先是域名的问题，这里参考遇见西门的博客的域名方法就行，记住不要直接在github建立CNAME文件，需要在本地建立CNAME文件，再上传，之后在github链接域名。</p><p>后面的一个问题是新建博客，使用的命令是<strong>hexo n “新建的博客名”</strong>,因为是md文件，所以需要你自己下一个md文件格式的编辑器，例如typora等，最后，你的文件写的时候，一般会添加tag，一定要tag:后面加一个空格，再加你的tag，不然会出现错误。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客建立 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csdn上的一些以前写的东西</title>
      <link href="/2020/07/07/csdn%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A5%E5%89%8D%E5%86%99%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
      <url>/2020/07/07/csdn%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A5%E5%89%8D%E5%86%99%E7%9A%84%E4%B8%9C%E8%A5%BF/</url>
      
        <content type="html"><![CDATA[<p>csdn以前的一些东西</p><h2 id="计算机系统基础（一）"><a href="#计算机系统基础（一）" class="headerlink" title="计算机系统基础（一）"></a>计算机系统基础（一）</h2><p>1.关于计算机基础方面的一些理解</p><pre><code>对于这门课，我在刚接触的时候，跟我刚接触C语言一样，这到底讲的是个什么啊。但是经过这半个学期的学习，我其实还是懂了一些了，这门课其实是为了写出更加优美的代码，其实也就是去理解计算机的底层到底是怎样去运行的。这些底层的东西，对于我们来说其实是一个通往一个更高的水平的路，我们需要的就是去理解，去学习。</code></pre><p>好，现在从第一章开始。</p><p><strong>第一章 计算机系统漫游</strong></p><pre><code>    这一部分其实我还真的不理解，这一部分要求我们学习更多的知识才能理解，但我自己对这一部分的理解也就是一个总览，看看就好，不必深究。</code></pre><p><strong>第二章 信息的表示和处理</strong><br><strong>2.1    信息存储</strong><br>            一个字节由8位组成        十六进制由0x开头，由0-F十六个字符表示，可大小写混合。<br>        <strong>进制转换：</strong><br>        十六进制转换为二进制，直接把相应的字符转换为对应的4位二进制就行。<br>        十进制转换为十六进制，直接十进制数除以16，取其剩下的余数，再用那个16的倍数再次除以16继续取其余数，再反向排序余数<br>        十进制转换为二进制与上面也差不多，只是除数变为2。<br>        <strong>字数据大小</strong><br>        <img src="https://img-blog.csdnimg.cn/20190501200525609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">对于一个w位的机器，程序最多访问2^w个字节。也就是0 - 2^w<br>        64位机器可以运行32位的程序，这是一种向后兼容。<br>        我们将程序成为32位 64位 只是区别于程序是如何编译的，而不是其运行的机器类型。<br>        ps：所有的指针类型都是8个字节。<br>小端模式：低位数据放在低地址中。如0x01234567         67就是低位数据放在低地址中。大端模式与其相反。<br>        <strong>布尔代数：</strong>~        &amp;        |        ^四种运算。运算时按位相运算就是了。<br>        要保持原数不变，就是与1相与，十六进制的布尔运算先转换为二进制在按位相运算。<br>        <strong>移位运算</strong>：左移直接移就是了，右移有算术和逻辑两种，算数补符号位，逻辑补0。用’&lt;&lt;’表示左移<br>                                    ‘&gt;&gt;’表示右移。</p><p><strong>2.2 整数表示</strong><br>        整数有有符号和无符号两种，有符号数的最大值要比最小值的绝对值小1。|Tmin| = |Tmax|+1.<br>        有符号数的第一位用来表示正负，用来计算十进制数时，第一位用负数参与计算，之后的数以正数加至第一个负数，最后得到其值。<br>        有符号数和无符号数一起参与运算时的时候，要将有符号数转化为无符号数。<br>        无符号数和补码的转换就是一个大小的适配。也就是加或减2^w。<br>        <strong>扩展</strong>：无符号数添0，有符号数添符号位。<br>        <strong>截断</strong>：将一个w位的数字截断为k位，就是丢弃高w-k位。<br>        <strong>整数运算</strong>：<br>        无符号数加法：当两个数相加之后的结果没有超过相对应的范围时，就不去管；如果超过了，就减去最大范围，剩下的就是最后的结果。<br>        补码加法：有正溢出和负溢出两种，也是相应的对2^w相对应运算。<br>当要求一个负数表示的二进制代码时，可以先将它的绝对值用二进制表示出来，之后再将其取补就是了。<br>        <strong>取补</strong>：二进制数从后向前数的第一个1之前的数全部取反就是取补。ps：补码的非也就是取补。<br>        ps：一般两数相加超过最大的表示范围时，就直接截断超过的那些位，留下该表示的位数。<br>        <strong>无符号和有符号数的乘法</strong>：<br>        <img src="https://img-blog.csdnimg.cn/20190501213026781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        <strong>2.4   浮点数</strong><br>        符号数的小数点左移相当于除法，小数点右移相当于乘法<br>对于数来说，左移相当于乘法，右移相当于除法<img src="https://img-blog.csdnimg.cn/20190501213145130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        对于规格数，需要的是M=1+frac；E=Exp−Bias<br>而非规格数，就只是M=frac；而且E=1-bias。<img src="https://img-blog.csdnimg.cn/20190501213200636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        <img src="https://img-blog.csdnimg.cn/20190501213209871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        当阶码全为1，小数域全为0时，表示无穷     称为‘NaN’。<br>        <strong>舍入</strong>：<br>        舍去：多余位小于最低位的一半<br>        +一半：多余位大于最低位的一半<br>        当多余位和最低位的一半时：<br>        舍：最低位为0<br> +一半：最低位不为0</p><p>浮点数的细节舍入和溢出问题：<br>从int变为float，数字不会溢出，但可能被舍入<br>从int或float变为double，因为double有更大的范围，所以能精确保留数值<br>从double变为float，因为float的范围小，可能会溢出为无穷，也可能舍入<br>从float或double变为int，值会向0舍入</p><p><strong>第三章：程序的机器级表示</strong></p><p>程序计数器（也称pc）：给出将要执行的下一条指令在内存中的地址。<br>寄存器：有的寄存器用来保存某些重要的程序状态，而其他的用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。</p><p>gcc -s test.c        产生汇编代码<br>gcc -c test.c         产生目标代码文件test.o（二进制）<br>objdump -d test.o 反汇编二进制文件成汇编代码<br>所有‘.’开头的行都是伪指令，直接无视就是了。</p><p>char     1字节         汇编后缀         b<br>short     2字节          后缀        w<br>int         4字节          后缀        l<br>long   char*        8字节        后缀      q<br>ps;指针都是8字节</p><p><img src="https://img-blog.csdnimg.cn/20190502084629606.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于 movq 指令来说，需要源操作数和目标操作数，源操作数可以是立即数、寄存器值或内存值的任意一种，但目标操作数只能是寄存器值或内存值。指令的具体格式可以这样写 movq [Imm|Reg|Mem], [Reg|Mem]，第一个是源操作数，第二个是目标操作数。<br>但我们没有办法用一条指令完成内存间的数据交换。</p><p>而mov指令的后缀与目的操作数有关<br>ps：当目的操作数为内存引用时，就要看源操作数。<br>有时还会进行扩展，movz表示0扩展    movs表示符号扩展</p><p>在汇编代码中用小括号表示取地址<br>前六个寄存器(%rax, %rbx, %rcx, %rdx, %rsi, %rdi)称为通用寄存器，有其『特定』的用途：<br>o        %rax(%eax) 用于做累加           %rax 也用于函数的返回<br>o        %rcx(%ecx) 用于计数<br>o        %rdx(%edx) 用于保存数据<br>o        %rbx(%ebx) 用于做内存查找的基础地址<br>o        %rsi(%esi) 用于保存源索引值<br>o        %rdi(%edi) 用于保存目标索引值<br>而 %rsp(%esp) 和 %rbp(%ebp) 则是作为栈指针和基指针来使用的。</p><p>首先要理解的是，寄存器中存储着当前正在执行的程序的相关信息：<br>o临时数据存放在 (%rax, …)<br>o运行时栈的地址存储在 (%rsp) 中<br>o目前的代码控制点存储在 (%rip, …) 中<br>o目前测试的状态放在 CF, ZF, SF, OF 中</p><p>CF 进位标志    ZF 零标志    SF 符号标志    OF 溢出标志<br>其实这四个条件代码，是用来标记上一条命令的结果的各种可能的，是自动会进行设置的。<br>注意，使用 leaq 指令的话不会进行设置。</p><p>。对于寻址来说，比较通用的格式是 D(Rb, Ri, S) -&gt; Mem[Reg[Rb]+S<em>Reg[Ri]+D]，其中：<br>oD - 常数偏移量<br>oRb - 基寄存器<br>oRi - 索引寄存器，不能是 %rsp<br>oS - 系数<br>除此之外，还有如下三种特殊情况<br>o(Rb, Ri) -&gt; Mem[Reg[Rb]+Reg[Ri]]<br>oD(Rb, Ri) -&gt; Mem[Reg[Rb]+Reg[Ri]+D]<br>o(Rb, Ri, S) -&gt; Mem[Reg[Rb]+S</em>Reg[Ri]]<br>运算指令：这里以 leaq 指令为例子。具体格式为 leaq Src, Dst，其中 Src 是地址的表达式，然后把计算的值存入 Dst 指定的寄存器，也就是说，无须内存引用就可以计算，类似于 p = &amp;x[i]</p><p><img src="https://img-blog.csdnimg.cn/2019050208501234.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>移位操作：左移为乘法，右移为除法。都为2的倍数</p><p><img src="https://img-blog.csdnimg.cn/20190502085651931.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>注意：cmp s1 s2；实际是用s2-s1来比较的。<br>           test %rax %rax 用来检测%rax为正或负或零。<br>           <img src="https://img-blog.csdnimg.cn/20190502090927154.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>           跳转指令：<br><img src="https://img-blog.csdnimg.cn/20190502090945278.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>jmp 直接跳转；<br>还有一个间接跳转 加上*</p><p><img src="https://img-blog.csdnimg.cn/20190502091604548.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>do while         /while         /    for 三个循环都是用条件判断和跳转指令在汇编层面实现。<br>switch是编写一个跳转表来实现。适用于条件过多，且范围跨度较小时使用。</p><p><strong>过程调用：</strong><br>1.传递控制：包括如何开始执行过程代码，以及如何返回到开始的地方<br>2.传递数据：包括过程需要的参数以及过程的返回值<br>3.内存管理：如何在过程执行的时候分配内存，以及在返回之后释放内存<br><img src="https://img-blog.csdnimg.cn/20190502091710547.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>新入栈的数据放在低地址</p><p>调用新的函数时，总是push指令保存栈，然后mov指令<br>函数调用中会利用 %rax 来保存过程调用的返回值，以便程序继续运行的。<br>如果参数没有超过六个，那么会放在：%rdi, %rsi, %rdx, %rcx, %r8, %r9 中<br>且函数内的参数后面的先入栈，前面的后入栈</p><p>递归调用的所需空间和时间都很大，增加很多额外的东西，一般避免使用递归</p>]]></content>
      
      
      
        <tags>
            
            <tag> csdn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
