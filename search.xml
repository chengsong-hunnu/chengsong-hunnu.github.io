<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络基础</title>
      <link href="/2020/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>机械工业出版社的大黑书(计算机网络-自顶向下方法)和课程，慕课的一个的总结，主要根据tcp/ip的五层体系结构。介绍一些大概</p><p>下面放一些他人的总结，当做补充资料或者细节</p><p><a href="https://www.cnblogs.com/zyx110/p/11891335.html" target="_blank" rel="noopener">五层结构简解</a></p><p><a href="https://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">tcp协议详解</a></p><p><a href="https://blog.csdn.net/baidu_37964071/article/details/80467838?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160005926919725247451603%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160005926919725247451603&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v3~pc_rank_v4-1-80467838.first_rank_ecpm_v3_pc_rank_v4&utm_term=ip%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3&spm=1018.2118.3001.4187" target="_blank" rel="noopener">IP协议简解</a></p><p><a href="https://www.jianshu.com/p/80e25cb1d81a" target="_blank" rel="noopener">HTTP协议详解</a></p><p><a href="https://blog.csdn.net/qq_34468186/article/details/82146754" target="_blank" rel="noopener">get/post详解</a></p><p><a href="https://www.baidu.com/link?url=_CAyhOKA2GP12gcdHKpTsYZ0QSNlkvFnT2rzkwnXdFft46kVuu2ucoM5SBW4pce9izTuTi52PUYKbcnG7xrzKnQc3a3QVTyo5_lByRJHT7S&wd=&eqid=d758fef000045fe8000000055f5e03e2" target="_blank" rel="noopener">本书前六章简解</a></p><p><a href="https://blog.csdn.net/qq_40323844/article/details/94488975?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">本书大致结构梳理</a></p><h4 id="1-总览"><a href="#1-总览" class="headerlink" title="1.总览"></a>1.总览</h4><h5 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h5><p>互联网组成：边缘部分+核心部分。</p><p>边缘部分就是各种主机，端系统，用户直接使用。<strong>每个端系统都具有一个唯一的IP地址</strong>，通过ISP与网络相连。</p><p>核心部分就是网络，交换机，<strong>路由器</strong>这些，为边缘部分提供服务(连通性和交换)。每台路由器都有一个转发表，用于将目的地址映射为输出链路。</p><p>端系统的常见通信方式是<strong>客户服务器方式</strong>，客户和服务器都是指通信中涉及到的两个应用进程。客户和服务器都要使用网络核心部分提供的服务。另一种是<strong>对等方式</strong>，本质上看还是客户服务器方式，只不过通信双方都是客户和服务器。</p><p>客户和服务器建立连接之后，通信是双向的，两者都可以接收/发送信息</p><p><strong>协议：定义了两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送，接收采取的一系列动作。</strong></p><hr><p>主机是为用户<strong>进行信息处理</strong>的，并向网络发送分组，或者从网络接收分组。</p><p>路由器是实现<strong>分组交换</strong>(packet switching)的关键构件，其任务是对分组进行<strong>存储转发</strong>，最后把分组交付目的主机，这是网络核心部分最重要的功能。</p><p><strong>分组交换</strong>：是以分组为单位进行传输和交换的，它是一种存储-转发交换方式。简单地说，就是一个数据报文太长了，超过了传输限制，需要将其分割分组，为每一个分组添加<strong>首部</strong>(包含地址等信息)，进行传输，最后在目的地接收后取出首部，进行拼接得到完整数据。但是有可能<strong>丢包</strong>，因为存储的队列满了，一般通过重发解决。<br><strong>存储转发</strong>：路由器收到一个分组，先暂时存储下来，再<strong>检查其首部，查找转发表</strong>，按照首部中的目的地址，找到合适的接口转发出去。</p><img src="/images/loading.gif" data-original="https://gitee.com/cheng_song/picgo-img/raw/master/img/image-20200913161533494.png" alt="image-20200913161438568" style="zoom:50%;" /><h5 id="1-2-性能指标"><a href="#1-2-性能指标" class="headerlink" title="1.2 性能指标"></a>1.2 性能指标</h5><p>1.速率：数据的传送速率，单位bit/s等</p><p>2.带宽：单位时间内，某信道能通过的“最高数据率”，单位bit/s</p><p>3.吞吐量：单位时间内，通过某个网络的数据量</p><p>4.<strong>时延</strong>：数据(一个报文或分组)从网络(或链路)的一端到另一端传送所需的时间。通常有</p><p>发送时延/传输时延：从发送数据帧的第一个比特到最后一个比特发送完成所需的时间</p><p>传播时延：电磁波在信道中需要一定的时间进行传播</p><p>处理时延：主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。</p><p>排队时延：分组在路由器输入输出队列中排队等待处理所经历的时间。</p><p>总时延为上面相加</p><img src="/images/loading.gif" data-original="https://gitee.com/cheng_song/picgo-img/raw/master/img/image-20200913161503961.png" alt="image-20200913161347953" style="zoom:50%;" /><p>一个小点：宽带线路和窄带线路上比特的传播速率是一样的。宽带线路:每秒有更多比特从计算机注入到线路。而且宽带不等于并行传输。</p><p>5.时延带宽积</p><p>6.往返时间RTT</p><p>7.利用率：信道利用率和网络利用率</p><h5 id="1-3-体系结构"><a href="#1-3-体系结构" class="headerlink" title="1.3 体系结构"></a>1.3 体系结构</h5><img src="/images/loading.gif" data-original="https://gitee.com/cheng_song/picgo-img/raw/master/img/image-20200913161438568.png" alt="" style="zoom:50%;" /><p>消息自上向下<strong>逐层</strong>封装，目标系统自下向上逐层拆封，由最高层将消息提供给目标进程。</p><p><strong>协议数据单元</strong>(PDU):协议控制信息(称为协议头/首部)+数据。协议头包含地址，序号，长度，分段标志等控制信息</p><p><strong>封装</strong>：<img src="/images/loading.gif" data-original="https://gitee.com/cheng_song/picgo-img/raw/master/img/image-20200913161414234.png" alt="image-20200913161503961" style="zoom:50%;" /></p><p>在计算机网络中数据交换必须准守事先约定的协议。</p><img src="/images/loading.gif" data-original="https://gitee.com/cheng_song/picgo-img/raw/master/img/image-20200913161347953.png" alt="image-20200913161414234" style="zoom:43%;" /><p>应用层：网络应用程序及应用层协议存留的地方，包括HTTP.SMTP.FTP协议。分布在多个端系统上。</p><p>运输层：在应用程序端点之间传输应用层报文。有两种传输协议，<strong>TCP/UDP</strong>。TCP面向连接服务和可靠数据传输服务，UDP提供无连接服务。</p><p>网络层：负责将称为<strong>数据报</strong>的网络层分组从一台主机移到另一台主机，通过TCP/UDP得到报文段和目的地址。协议仅有一个为著名的<strong>IP</strong>协议。</p><p>链路层：为了将分组从一个节点(主机或路由器)移到另一个节点，网络层必须需要链路层提供服务。链路层分组称为帧。</p><p>物理层：链路层是将整个帧从一个网络元素移动到邻近的网络元素，物理层的任务是将帧中的一个个比特从一个节点移到下一个节点。与双绞铜线，同轴电缆，光纤相关。</p><img src="/images/loading.gif" data-original="https://gitee.com/cheng_song/picgo-img/raw/master/img/image-20200915205119264.png" alt="image-20200915205119264" style="zoom:57%;" /><hr><h4 id="2-应用层"><a href="#2-应用层" class="headerlink" title="2.应用层"></a>2.应用层</h4><p>规定应用进程在通信是遵守的协议，协议大多基于客户服务器方式。进程通过一个称为<strong>套接字软件接口</strong>向网络发送，接收报文。</p><p>可供应用程序使用的运输服务：1.可靠的数据传输  2.定时 3.吞吐量 4.安全</p><h5 id="2-1-HTTP"><a href="#2-1-HTTP" class="headerlink" title="2.1 HTTP"></a>2.1 HTTP</h5><p>定义了web客户向web服务器请求web页面的方式，以服务器向客户发送web页面的方式。使用TCP作为他的支撑运输协议。因为HTTP服务器不保存客户的任何信息，所以称HTTP协议是一个<strong>无状态协议</strong>，每一次请求都认为是一个全新的请求。默认是持续连接，也可改成非持续连接。</p><p><strong>HTTP报文格式</strong></p><p><strong>请求报文</strong>：第一行称为请求行，包含方法字段(get/post/put……)、URL字段、HTTP版本字段。后续的行称为首部行。</p><img src="/images/loading.gif" data-original="https://gitee.com/cheng_song/picgo-img/raw/master/img/image-20200913192706036.png" alt="image-20200913192706036" style="zoom:70%;" /><p>请求数据一般在post存在；get为空，参数直接在URL里存在。</p><pre><code>GET /books/?sex=man&amp;name=Professional HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive</code></pre><p><strong>响应报文</strong>：包括初始状态行(版本，状态码，短语)，6个首部行，一个实体体(数据)。结构与上面相似，只是第一行有变化。</p><pre><code>HTTP/1.1 200 OK  //初始状态行Date: Sat, 31 Dec 2005 23:59:59 GMTContent-Type: text/html;charset=ISO-8859-1Content-Length: 122name=Professional%20Ajax&amp;publisher=Wiley    //响应数据</code></pre><p>cookie：客户与服务器的交互，因为HTTP是无状态的，所以需要cookie进行保存会话，免得重新再来全部请求一遍。</p><p>web缓存：内容分发网络CDN，减少访问和数据传输的时间</p><h5 id="2-2-SMTP"><a href="#2-2-SMTP" class="headerlink" title="2.2 SMTP"></a>2.2 SMTP</h5><p>使用TCP可靠数据传输协议，是一个电子邮件传输协议。用户代理发送信息到用户的邮件服务器，此服务器发送邮件到接收方的邮件服务器，接收方的服务器将邮件放入接收方的邮箱中。</p><p>电子邮件组成：用户代理，邮件服务器，协议。</p><h5 id="2-3-SMTP与HTTP的对比"><a href="#2-3-SMTP与HTTP的对比" class="headerlink" title="2.3 SMTP与HTTP的对比"></a>2.3 SMTP与HTTP的对比</h5><ol><li>HTTP主要是一个<strong>拉协议</strong>，TCP连接由想要接收文件的机器发起。即在使用的时候，某些人在Web服务器上装载信息，用户使用HTTP从该服务器上拉取这些信息。</li><li>SMTP基本上是一个<strong>推协议</strong>，TCP连接由想要发送该文件的机器发起。即发送邮件服务器到接收邮件服务器</li><li>SMTP要求每个报文使用7比特ASCLL码形式。HTTP<strong>不受限制</strong></li><li>处理一个既包含文本又包含图形的文档，HTTP把<strong>每个对象</strong>封装到自己的<strong>HTTP响应报文</strong>中，SMTP则把所有的报文对象放在<strong>一个报文</strong>之中。</li></ol><p>邮件访问协议：取报文是一个拉操作，而SMTP为一个推协议，通过一个特殊的协议实现邮件服务器到用户代理。</p><ol><li>第三版的邮局协议：POP3 授权 (代理 &lt;–&gt;服务器) 并下载</li><li>因特网邮件访问协议：IMAP 更多特色 (更复杂) 操作存储在服务器上的报文</li></ol><h5 id="2-4-DNS域名系统"><a href="#2-4-DNS域名系统" class="headerlink" title="2.4 DNS域名系统"></a>2.4 DNS域名系统</h5><p>1.一个由分层的DNS服务器实现的分布式数据库。</p><p>2.一个使得主机能够查询分布式数据库的应用层协议。（DNS协议运行在UDP之上，使用53号端口）</p><p>DNS能够进行主机名(如localhost等)到IP地址(127.0.0.1)转换的目录服务。</p><img src="/images/loading.gif" data-original="https://gitee.com/cheng_song/picgo-img/raw/master/img/image-20200913200420786.png" alt="image-20200913200420786" style="zoom:60%;" /><p><strong>域名的解析过程</strong><br>主机向本地域名服务器的查询一般都是采用<strong>递归查询</strong>。<br>如果主机所询问的本地域名服务器不知道被查询域名的P地址，那么本地域名服务器就以DNS客户的身份，向其他<strong>根域名服务器</strong>继续发出查询请求报文。</p><p>本地域名服务器向根域名服务器的查询通常是采用<strong>迭代查询</strong>。<br>当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器:“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询，这就叫迭代。</p><p><strong>DNS缓存</strong>：存放最近使用过的主机名和ip的映射，再次访问的时候就直接进行域名解析得到ip地址，一般只会保存两天</p><hr><h4 id="3-运输层"><a href="#3-运输层" class="headerlink" title="3.运输层"></a>3.运输层</h4><p>为运行在不同主机上的应用程序之间提供了<strong>逻辑通信功能</strong>，ip协议提供了主机之间的逻辑通信功能。</p><p>将运输层分组称为<strong>报文段</strong>。<strong>数据交付和差错检查</strong>是两种最低程度的运输层服务，也是UDP仅能提供的两种服务。</p><p>多路复用，多路分解。通过<strong>源端口号字段和目的端口号字段</strong>在套接字中进行标识</p><h5 id="3-1-UDP服务"><a href="#3-1-UDP服务" class="headerlink" title="3.1 UDP服务"></a><strong>3.1 UDP服务</strong></h5><p>UDP（User Datagram Protocol 用户数据报协议）是<strong>不可靠，无连接</strong>的(发送数据前不需要建立连接)，尽最大可能交付，没有拥塞控制，<strong>面向报文</strong>（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部，一次发送一个报文），支持一对一、一对多、多对一和多对多的交互通信，首部开销小(只有8个字节)。适用于高实时性的场合，比如电话，音视频播放等。</p><h5 id="3-1-2-TCP服务"><a href="#3-1-2-TCP服务" class="headerlink" title="3.1-2 TCP服务"></a><strong>3.1-2 TCP服务</strong></h5><p>传输控制协议：可靠，面向连接的服务，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一），连接的端点叫<strong>套接字</strong></p><p><strong>套接字socket(IP地址：端口号)    TCP连接=(socket1，socket2)</strong></p><p>面向连接的服务：<strong>三次握手</strong>，建立一个TCP连接，是在两个进程的套接字之间建立。这条连接是<strong>全双工</strong>的，即双方都可进行报文收发。结束传输之后，必须<strong>四次挥手</strong>断开连接。</p><p>一个点是双方都有发送接收<strong>缓存</strong>，应用程序是从缓存中写入数据，读取数据</p><p><a href="https://blog.csdn.net/qq_43977818/article/details/108577151" target="_blank" rel="noopener">三次握手/四次挥手的简要解析</a></p><p>TCP本身没有提供加密服务，现在主要依靠<strong>安全套接字层(SSL)</strong>提供安全保证，在应用层上进行实现，是一种对TCP的加强。</p><hr><p><strong>可靠的数据传送服务</strong>：进程依靠TCP，无差错，按适当的顺序交付所有传输的数据。具有<strong>自动重传请求协议</strong>，需要差错检测，接收方反馈，重传三种功能处理比特差错的情况。还有<strong>超时重传(但这个时间的设置是一个问题)</strong>，检测冗余(因为过早超时，进行了数据重发，接收方产生了数据冗余)。</p><p>接收方一般有累计确认机制</p><img src="/images/loading.gif" data-original="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200915173418221.png" alt="image-20200915173418221" style="zoom:67%;" /><hr><h5 id="3-2-TCP首部格式"><a href="#3-2-TCP首部格式" class="headerlink" title="3.2 TCP首部格式"></a><strong>3.2 TCP首部格式</strong></h5><img src="/images/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" width="700" style="zoom:60%;" /><ul><li><strong>序号</strong>   ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。因为MSS的限制，TCP将数据报分成MSS大小的字节流。</li><li><strong>确认号</strong>   ：期望收到的下一个报文段的<strong>序号</strong>。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li><strong>数据偏移</strong>   ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>确认 ACK</strong>   ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li><strong>同步 SYN</strong>   ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li><strong>终止 FIN</strong>   ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li><strong>窗口</strong>   ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li><li><strong>选项</strong> ：规定了最大报文长度MSS，告诉对方TCP：“我的缓存所能接收的报文段的数据字段的最大长度是MSS个字节。”,与窗口用于流量控制</li></ul><hr><h5 id="3-3-TCP-的三次握手"><a href="#3-3-TCP-的三次握手" class="headerlink" title="3.3 TCP 的三次握手"></a>3.3 TCP 的三次握手</h5><img src="/images/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png" width="600" style="zoom:75%;" /><p>类比于：A:我要与你建立连接了，B:真的吗，A:是真的。</p><p>假设 A 为客户端，B 为服务器端。</p><ul><li><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p></li><li><p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p></li><li><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p></li><li><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p></li><li><p>B 收到 A 的确认后，连接建立。</p></li></ul><p><strong>三次握手的原因</strong>  </p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><hr><h5 id="3-4-TCP-的四次挥手"><a href="#3-4-TCP-的四次挥手" class="headerlink" title="3.4 TCP 的四次挥手"></a>3.4 TCP 的四次挥手</h5><img src="/images/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" width="600" style="zoom:75%;" /><p>类比于：A:我要与你断开连接了，B:好的，B:但我也要与你断开连接，A:好的</p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li><p>A 发送连接释放报文，FIN=1。</p></li><li><p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p></li><li><p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p></li><li><p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p></li><li><p>B 收到 A 的确认后释放连接。</p></li></ul><p><strong>四次挥手的原因</strong>  </p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong>  </p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><hr><h5 id="3-5-流量控制"><a href="#3-5-流量控制" class="headerlink" title="3.5 流量控制"></a>3.5 流量控制</h5><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。因为可能接收方的接收缓存因为应用程序读取数据过慢，导致接收缓存溢出</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。可靠传输中的滑动窗口进行流量控制。</p><hr><h5 id="3-6-拥塞控制"><a href="#3-6-拥塞控制" class="headerlink" title="3.6 拥塞控制"></a>3.6 拥塞控制</h5><p>如果网络出现拥塞，因为缓冲区溢出，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p><img src="/images/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg" width="500" style="zoom: 67%;" /><p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p><p>发送方需要维护一个叫做<strong>拥塞窗口</strong>（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><img src="/images/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/910f613f-514f-4534-87dd-9b4699d59d31.png" width="800" style="zoom: 67%;" /><h6 id="3-6-1-慢开始与拥塞避免"><a href="#3-6-1-慢开始与拥塞避免" class="headerlink" title="3.6.1  慢开始与拥塞避免"></a>3.6.1  慢开始与拥塞避免</h6><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当<strong>收到确认后</strong>，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，<strong>当 cwnd &gt;= ssthresh 时，进入拥塞避免</strong>，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 <strong>ssthresh = cwnd / 2</strong>，然后重新执行慢开始。</p><h6 id="3-6-2-快重传与快恢复"><a href="#3-6-2-快重传与快恢复" class="headerlink" title="3.6.2  快重传与快恢复"></a>3.6.2  快重传与快恢复</h6><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的<strong>有序</strong>报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p><strong>慢开始和快恢复的快慢指的是 cwnd 的设定值</strong>，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><hr><h4 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4.网络层"></a>4.网络层</h4><h5 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h5><p>网络层不保证数据报的交付，和按序交付，也不保证数据的完整性。IP协议提供了主机之间的逻辑通信功能。</p><p>数据平面：即是网络层中路由器的功能，决定到达网络层的<strong>数据报</strong>(网络层中的分组)如何转发到该路由器的输出链路之一，涉及<strong>IP转发和通用的转发</strong></p><p>控制平面：即网络范围的逻辑，控制数据报沿着源主机到目的主机的端到端的路径中路由器之间的路由方式，涉及<strong>路由选择算法，路由选择协议</strong></p><p>网络层的核心功能：<strong>转发</strong>（将分组从路由器的输入链路移到合适的输出链路的一个路由器本地动作，一般只有几纳秒，由硬件实现），<strong>路由选择</strong>（分组从发送方流向接收方，网络层必须决定这些分组所采取的路径或路由，称为路由选择算法，通常为几秒，由软件处理）</p><p>路由器有个关键元素<strong>转发表</strong>，通过在里面索引进行转发。由输入端口，交换结构，输出端口，路由选择处理器组成。</p><p>关于地址解析协议(ARP),将IP地址转换成MAC物理地址，我们放在链路层里面细讲。</p><h5 id="4-2-数据平面"><a href="#4-2-数据平面" class="headerlink" title="4.2 数据平面"></a>4.2 数据平面</h5><p><strong>IP转发</strong>：路由器的转发表结构</p><p><img src="/images/loading.gif" data-original="https://gitee.com/cheng_song/picgo-img/raw/master/img/image-20200915205940655.png" alt="image-20200915205940655" style="zoom:50%;" /><img src="/images/loading.gif" data-original="https://gitee.com/cheng_song/picgo-img/raw/master/img/image-20200915210414390.png" alt="image-20200915210414390" style="zoom:50%;" /></p><p>主机所在网络为目的地址的前缀，这么使用是为了简化转发表的大小。还有一些特定主机路由和默认路由(类似宿舍路由器)</p><p><strong>交换</strong>：经内存交换、经总线交换、经互联网络交换。</p><p><strong>排队</strong>：因为路由器的缓存有限，可能在输入端口和输出端口出现排队现象，当缓存满了之后，可能出现<strong>丢包</strong>，就是前面的分组丢失</p><p><strong>分组调度</strong>：确定次序，即排队的分组如何经链路传输的次序。先入先出、优先权排队、循环和加权公平排队。</p><hr><h5 id="4-2-2-IP协议"><a href="#4-2-2-IP协议" class="headerlink" title="4.2-2 IP协议"></a>4.2-2 IP协议</h5><p>数据报格式：</p><img src="/images/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" width="700" style="zoom: 67%;" /><ul><li><p><strong>版本</strong>   : 有 4（IPv4）和 6（IPv6）两个值；</p></li><li><p><strong>首部长度</strong>   : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p></li><li><p><strong>区分服务</strong>   : 用来获得更好的服务，一般情况下不使用。</p></li><li><p><strong>总长度</strong>   : 包括首部长度和数据部分长度。不超过65535字节，但一般不会超过1500字节，必须不超过最大传送单元<strong>MTU（一个链路层能承载的最大数据量）</strong>。</p></li><li><p><strong>生存时间</strong>   ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p></li><li><p><strong>协议</strong>  ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p></li><li><p><strong>首部检验和</strong>  ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量，用于帮助路由器检测收到的IP数据报中的比特错误。</p></li><li><p><strong>标识</strong>   : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p></li><li><p><strong>片偏移</strong>   : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p></li></ul><img src="/images/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23ba890e-e11c-45e2-a20c-64d217f83430.png" width="700" style="zoom:67%;" /><hr><h5 id="4-2-3-IP-地址编址方式"><a href="#4-2-3-IP-地址编址方式" class="headerlink" title="4.2-3 IP 地址编址方式"></a>4.2-3 IP 地址编址方式</h5><p>IP 地址的编址方式经历了三个历史阶段：前两个为其他书的补充知识，只需了解</p><ul><li>分类</li><li>子网划分</li><li>无分类（主流）</li></ul><p><code>1. 分类</code></p><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><img src="/images/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png" width="500" style="zoom:77%;" /><p> <code>2. 子网划分</code></p><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p><p><strong>子网定义</strong>：</p><p>1.无需通过路由器就能够物理上互相到达，在路由器同一侧（接入路由器同一接口），一般处于同一局域网</p><p>2.设备接口被配置的IP地址具有相同的网络地址（即共同的IP地址前缀）</p><p>3.IP地址 AND 子网掩码 = 网络地址</p><p>子网的表示方法：</p><p>1、子网掩码(使用子网划分)：用从最高位开始的连续1表示IP地址中的子网号部分，后面为0的标识子网内的主机号 255.255.255.0</p><p>2、前缀/长度(使用无分类的IP编址)：223.1.1.0/24，表示前24位为前缀部分</p><img src="/images/loading.gif" data-original="https://gitee.com/cheng_song/picgo-img/raw/master/img/image-20200916085108569.png" alt="image-20200916085108569" style="zoom:67%;" /><p><strong>3、无分类(目前主流)</strong></p><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，<strong>使用网络前缀和主机号来对 IP 地址进行编码(变为两级编址)</strong>，网络前缀的长度可以根据需要变化。</p><p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为<strong>掩码</strong>（不叫子网掩码），掩码的数字 1 的长度为网络前缀的长度，掩码全为 1。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为   <strong>构成超网</strong>  </p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><p>动态主机配置协议(<strong>DHCP</strong>)：组织被分配了一块地址后，主机可以自动获取一个IP地址，而且能通过配置，给一个主机临时分配一个IP地址。</p><p><strong>通用转发</strong>：IP转发是一个查找目的IP地址，发送到特定端口的 匹配+动作；通用转发在每台分组交换机里包含一张匹配加动作表，该表由远程控制器计算和分发，实现与基于目的地址的转发类似的功能，还能丢弃，复制一个分组或重写第2,3,4层的首部。</p><p><strong>网络地址转换 NAT</strong></p><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><img src="/images/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2719067e-b299-4639-9065-bed6729dbf0b.png" width=""/> <p><strong>IPv4与IPv6</strong></p><p>32比特的IP地址空间即将耗尽，应对大IP地址空间的要求，开发新的IP协议即IPv6</p><p>区别：</p><p>1.扩大地址容量 从32比特到128比特。</p><p>2.除单播和多播外加入任播地址。这种地址可以使数据报交付给一组主机中的任意一个</p><p>3.简单高效的40字节首部</p><p>4.留标签和优先级</p><p>5.IPV6不允许在中间路由器上进行分片组装，只能在源和目的地上进行</p><p>6.去除首部检验和</p><p>7.选项不再是标准IP首部一部分。</p><p>可通过建隧道的方式将IPV4迁移到IPV6</p><p><strong>地址解析协议 ARP</strong></p><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><img src="/images/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66192382-558b-4b05-a35d-ac4a2b1a9811.jpg" width="700" style="zoom:67%;" /><p>ARP 实现由 IP 地址得到 MAC 地址。</p><hr><h5 id="4-3-控制平面"><a href="#4-3-控制平面" class="headerlink" title="4.3 控制平面"></a>4.3 控制平面</h5><p><strong>构件控制平面的两大类方法</strong>：</p><p>传统的每路由器控制：每台路由器中运算算法，并且路由器中的路由选择组件与其他路由器的路由选择组件通信；</p><p>软件定义网络(SDN)控制：其中一个逻辑上集合的控制器计算，并向每台路由器分发转发表为他们所用</p><hr><p><strong>路由选择算法</strong>：为了得到一条有最低开销的路径，可基于<strong>图</strong>进行最短路径选择</p><p>链路状态算法(LS)：Djikstra算法，最差情况下复杂性为O(N^2)，使用全局信息的算法</p><p>距离向量算法(DV)：Bellman-Ford方程，属一种迭代，异步，分布式的算法。<strong>当遇到路由选择环路的时候可能会产生无穷计数的问题</strong>。</p><hr><p>互联网可以划分为许多较小的<strong>自治系统 AS</strong>，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><ul><li>自治系统内部的路由选择：RIP 和 OSPF</li><li>自治系统间的路由选择：BGP</li></ul><p><strong>1.内部网关协议 RIP</strong>（补充知识，）</p><p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p>距离向量算法：</p><ul><li>对地址为 X 的相邻路由器发来的 RIP 报文,先修改报文中的所有项目,把下一跳字段中的地址改为 X，并把所有的距离字段加 1</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<ul><li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li><li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li></ul></li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li></ul><p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p><p><strong>2.内部网关协议 OSPF</strong></p><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>且有安全，多条相同开销的路径，对单播和多播路由选择的综合支持，支持在单个AS中的层次结构的优点。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li>只有当链路状态发生变化时，路由器才会发送信息。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p><p><strong>3.外部网关协议 BGP</strong>（极为重要，可与IP协议一比）</p><p>BGP（Border Gateway Protocol，边界网关协议），ISP之间的路由选择</p><p>AS 之间的路由选择很困难，主要是由于：</p><ul><li>互联网规模很大；</li><li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li><li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li></ul><p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p><hr><p><strong>SDN控制平面</strong></p><p>具有4个特征：基于流的转发，数据平面和控制平面分离，网络控制功能：位于数据平面交换机外面，可编程的网络</p><p>ICMP（网际控制报文协议）：最典型的用途是差错报告，其体系结果位于IP之上，是承载在IP分组中的</p><img src="/images/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3124763-f75e-46c3-ba82-341e6c98d862.jpg" width="500"/><hr><h4 id="5-链路层"><a href="#5-链路层" class="headerlink" title="5.链路层"></a>5.链路层</h4><h5 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h5><p>沿着通信路径连接相邻节点的通信信道称为链路。有两种信道：广播信道(一对多 )、点对点通信链路</p><p><strong>数据链路层提供的服务：</strong></p><ul><li><p>成帧 （网络层数据报经链路传送前，链路层协议将其用链路层帧封装起来）<img src="/images/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/29a14735-e154-4f60-9a04-c9628e5d09f4.png" width="300"/></p></li><li><p>链路接入  （<strong>MAC</strong>协议规定了帧在链路传输的规则。链路的一段仅有一个发送方，另一端只有一个接收方的点对点链路）</p></li><li><p>可靠交付 （保证无差错地经链路层移动每个网络数据报）</p></li><li><p>差错检验和纠正  </p></li></ul><h5 id="5-2-差错检验与纠正"><a href="#5-2-差错检验与纠正" class="headerlink" title="5.2  差错检验与纠正"></a>5.2  差错检验与纠正</h5><p>奇偶校验：有单个奇偶校验位和二维奇偶校验（通过校验出错，比特值改变的行和列的索引，可以进行纠正）</p><p>检验和：将d比特数据看成k比特的整数的序列处理，将这k比特整数加起来当做校验和</p><p>循环冗余检测(CRC)编码(目前主流)：使用多项式算数进行操作</p><h5 id="5-3-多路访问协议"><a href="#5-3-多路访问协议" class="headerlink" title="5.3 多路访问协议"></a>5.3 多路访问协议</h5><p>主要是在广播链路中的多路访问问题的解决</p><p>划分为：信道划分协议，随机接入协议，轮流协议</p><p>理想的多路访问协议：<br>（1）当仅有一个节点发送数据时，该节点具有R bps的吞吐量；<br>（2）当有M个节点发送数据时，每个节点吞吐量为R/M bps；（每个节点在一定时间间隔内应有R/M的平均速率）<br>（3）协议是分散的；（不会因某个主节点故障而使整个系统崩溃）<br>（4）协议是简单的，实现不昂贵。</p><p>纯ALOHA（非时隙、高度分散）：<br>最大效率为 <strong>1/(2e)=0.185</strong>。</p><p>时隙ALOHA（高度分散的）：</p><ul><li>当只有一个节点时可以全速R连续传输；</li><li>一个给定节点传输的概率为p，节点成功传送的概率为 <strong>p(1-p)^(N-1)</strong>，N个节点任意一个发送成功的概率 <strong>Np(1-p)^(N-1)</strong>。（这个协议最大效率为 <strong>1/e=0.37</strong>，是纯ALOHA两倍）</li></ul><hr><h5 id="5-4-交换局域网"><a href="#5-4-交换局域网" class="headerlink" title="5.4 交换局域网"></a>5.4 交换局域网</h5><p>使用链路层地址而不是IP地址来转发链路层帧通过交换机</p><h5 id="5-4-2-链路层寻址和ARP"><a href="#5-4-2-链路层寻址和ARP" class="headerlink" title="5.4-2 链路层寻址和ARP"></a>5.4-2 链路层寻址和ARP</h5><p>1.链路层地址也称<strong>MAC</strong>地址</p><ul><li>不是主机或路由器具有链路层地址，而是它们的适配器（即网络接口）具有链路层地址。</li><li>MAC地址长度为6字节，共有2^48可能的MAC地址。</li><li>MAC地址通常被设计为永久。</li><li>MAC广播地址为 <strong>FF-FF-FF-FF-FF-FF</strong>。</li></ul><p>2.地址解析协议<strong>ARP</strong></p><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，<strong>IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</strong></p><p>因为ARP包含链路层和分组层的地址，可能最认为ARP是跨越链路层和网络层的协议</p><ul><li>作用：将一个IP地址解析为一个MAC地址。</li><li>工作方式：每台主机和路由器在其内存中具有一个ARP表，这张表包含IP地址到MAC地址的映射关系。</li><li>ARP分组有四个字段：源IP、MAC，目的IP、MAC。</li><li>查询ARP报文在广播帧中发送，而响应ARP报文在一个标准帧中发送。</li><li>ARP表是自动建立的，不需要管理员配置。</li></ul><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><img src="/images/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8006a450-6c2f-498c-a928-c927f758b1d0.png" width="700" style="zoom:50%;" /><p>3.以太网</p><p>以太网是一种星型拓扑结构局域网</p><p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p><p>以太网帧格式：最前面还有一个前同步码</p><ul><li><strong>类型</strong>  ：标记上层使用的协议；</li><li><strong>目的地址</strong>：目的适配器的MAC地址</li><li><strong>数据</strong>  ：承载IP数据报，长度在 46-1500 之间，如果太小则需要填充；</li><li><strong>FCS</strong>  ：帧检验序列，使用的是 CRC 检验方法；</li><li><strong>前同步码</strong>：8字节，前7个字节用来“唤醒”接收适配器，第8个字节是为了提醒有内容来了</li></ul><img src="/images/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/164944d3-bbd2-4bb2-924b-e62199c51b90.png" width="500"/><p>4.链路层交换机</p><p>交换机借助交换机表，实现过滤和转发。</p><p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p><p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p><p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p><img src="/images/loading.gif" data-original="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a4444545-0d68-4015-9a3d-19209dc436b3.png" width="800" style="zoom:67%;" /><p>5.虚拟局域网</p><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p><p>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</p><h4 id="5-1-回顾web页面请求的历程"><a href="#5-1-回顾web页面请求的历程" class="headerlink" title="5-1 回顾web页面请求的历程"></a>5-1 回顾web页面请求的历程</h4><p>1.准备：DHCP,UDP,IP和以太网</p><p>2.仍在准备：DNS和ARP</p><p>3.仍在准备：域内路由选择到DNS服务器</p><p>4.web客户-服务器交互：TCP,HTTP</p><hr><h4 id="6-其他"><a href="#6-其他" class="headerlink" title="6.其他"></a>6.其他</h4><p>其实这本书后面还有无线网络与移动网络、网络中的安全、多媒体网络三章，但应该不学了，前面还有一些特定协议的算法没有去搞清楚，后面看能不能补上去。</p><p>后面还有一个我比较感兴趣的一个点：TCP的连接安全    SSL。还要记录一下</p><h5 id="1-SSL（安全套接字层）"><a href="#1-SSL（安全套接字层）" class="headerlink" title="1.SSL（安全套接字层）"></a>1.SSL（安全套接字层）</h5><p>SSL通过机密性、数据完整性、服务器鉴别和客户鉴别来强化TCP</p><h5 id="宏观描述"><a href="#宏观描述" class="headerlink" title="宏观描述"></a>宏观描述</h5><p><strong>1.握手</strong>：使用了非对称加密和对称加密，就速度而言，对称加密解密的速度更快。</p><p>1.客户与服务器建立TCP连接</p><p>2.验证服务器是真实正确的服务器，服务器会发送一个被某CA公证过的公钥。</p><p>3.客户发送给服务器一个主密钥（使用服务器的公钥加密），客户和服务器使用该主密钥生成SSL会话所需的所有对称密钥</p><p><strong>2.密钥导出</strong>：双方使用不同的密钥，为了更安全</p><p>会根据前面的主密钥生成4个密钥，两个加密密钥用来解密数据，两个MAC密钥用来验证数据的完整性。</p><p><strong>3.数据传输</strong>：为了方便将MAC完整性检测传过去，<strong>其将数据分割成一个个记录</strong>，给每个记录附加一个MAC用于完整性检测，然后加密“记录+MAC”，进行传输</p><p><strong>4.SSL记录</strong>：</p><img src="/images/loading.gif" data-original="https://img-blog.csdn.net/20180523150500822?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXBmc2hfc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom: 67%;" /><p><strong>连接关闭</strong>：一个方法是直接TCP发送一个FIN报文进行关闭TCP连接而终止SSL会话，但有可能这个FIN是别人伪造，服务器接收数据不完整，所以ssl在类型字段中指出该记录手否用于终止SSL会话。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack简单使用</title>
      <link href="/2020/09/07/webpack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/09/07/webpack%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>就是在菜鸟的一个简单学习和使用，并没有深入</p><h5 id="1-首先进行一个webpack的安装"><a href="#1-首先进行一个webpack的安装" class="headerlink" title="1.首先进行一个webpack的安装"></a>1.首先进行一个webpack的安装</h5><pre class=" language-shell"><code class="language-shell">cnpm install webpack webpack-cli -g</code></pre><p>打包使用</p><pre class=" language-shell"><code class="language-shell">webpack filename -o targetname --mode=developmention/production  webpack ./src/index.js -o ./dist/bundle.js --mode=production //例</code></pre><p>开发环境里面会包含注释这些，会更详细。生产环境或对代码进行压缩，删除注释，代码混淆这些，大小也更小。</p><h5 id="2-webpack-config-js"><a href="#2-webpack-config-js" class="headerlink" title="2.webpack.config.js"></a>2.webpack.config.js</h5><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引入node的path</span><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过 npm 安装，生成一个html文件，包含bundle.js</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于访问内置插件</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token string">"./main.js"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//入口文件</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>        path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//输出路径，默认为dist文件夹</span>        filename<span class="token punctuation">:</span> <span class="token string">"bundle.js"</span> <span class="token comment" spellcheck="true">//输出文件名</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    mode<span class="token punctuation">:</span><span class="token string">'develpoment'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//模式</span>    <span class="token comment" spellcheck="true">//loader配置</span>    module<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//先进行文件匹配，在进行处理</span>        loaders<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span> test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>              use<span class="token punctuation">:</span><span class="token punctuation">[</span>                  <span class="token comment" spellcheck="true">//use的数组内容loader是从下到上，逆序执行</span>                  <span class="token string">"style-loader"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//将js的样式内容插入到style标签里面</span>                  <span class="token string">"css.loader"</span> <span class="token comment" spellcheck="true">//将css文件转换成js文件</span>              <span class="token punctuation">]</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//插件配置</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        template<span class="token punctuation">:</span> <span class="token string">'./src/index.html'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>    devServer<span class="token punctuation">:</span><span class="token punctuation">{</span>        contentBase<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__pathname<span class="token punctuation">,</span><span class="token string">"dist"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//目标路径</span>        compress<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//自动刷新</span>        port<span class="token punctuation">:</span><span class="token number">3000</span>  <span class="token comment" spellcheck="true">//端口号</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>之后直接在命令行使用</p><pre class=" language-shell"><code class="language-shell">webpack</code></pre><p>就可以进行打包</p><h5 id="3-loader"><a href="#3-loader" class="headerlink" title="3.loader"></a>3.loader</h5><p><em>loader</em> 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。</p><h5 id="4-plugins"><a href="#4-plugins" class="headerlink" title="4.plugins"></a>4.plugins</h5><p>使用一个插件，你只需要 <code>require()</code> 它，然后把它添加到 <code>plugins</code> 数组中.在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 <code>new</code> 操作符来创建它的一个实例</p><h5 id="5-热更新"><a href="#5-热更新" class="headerlink" title="5.热更新"></a>5.热更新</h5><p>可以在进行修改之后，马上看见webpack后的效果，不需要再进行webpack命令。使用devServe，需要安装依赖。</p><pre class=" language-js"><code class="language-js">cnpm install webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server <span class="token operator">-</span>gwebpack<span class="token operator">-</span>dev<span class="token operator">-</span>server <span class="token comment" spellcheck="true">//进行打开</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js复习</title>
      <link href="/2020/08/25/js%E5%A4%8D%E4%B9%A0/"/>
      <url>/2020/08/25/js%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p> 之前对js只是在菜鸟上面简单的看了一遍，并没有进行一个熟练地使用，后面发现需要补一些基础原理方面的，特在这里对前面的js进行一个复习</p><h5 id="1-js组成"><a href="#1-js组成" class="headerlink" title="1.js组成"></a>1.js组成</h5><blockquote><p><strong>js = ECMAScript + DOM + BOM + 高级</strong></p></blockquote><p><strong>ECMAScript</strong>（前身为欧洲计算机制造商协会）：JavaScript的语法规范</p><p><strong>DOM</strong>（Document Object Model 的文档对象模型简称）：JavaScript操作网页上元素的API</p><p><strong>BOM</strong>（Browser Object Model 的浏览器对象模型简称）：JavaScript操作浏览器部分功能的API</p><h5 id="2-记录一些常用的方法"><a href="#2-记录一些常用的方法" class="headerlink" title="2.记录一些常用的方法"></a>2.记录一些常用的方法</h5><p>字符串：</p><table><thead><tr><th>名</th><th></th></tr></thead><tbody><tr><td>trim()</td><td>去除字符串的左右空格，不包括在中间的空格</td></tr><tr><td>indexOf()</td><td>返回一个字符在字符串的位置</td></tr><tr><td>split()</td><td>把字符串分割成字符串数组</td></tr><tr><td>slice()</td><td>得到一个字符串的一部分</td></tr></tbody></table><p>json：</p><table><thead><tr><th>名</th><th></th></tr></thead><tbody><tr><td>JSON.parse(string name)</td><td>json<strong>字符串</strong>转成js对象  //json格式是一个字符串</td></tr><tr><td>JSON.stringify(json name)</td><td>js值(对象或数组)转成json字符串</td></tr></tbody></table><p>算了，用的时候还不如直接查参考手册</p><h5 id="3-js-promise"><a href="#3-js-promise" class="headerlink" title="3.js promise"></a>3.js promise</h5><p>之前一直听说promise，但不知道是何，现在才来进行一个理解。</p><p>promise是es6新增的一个类，专门为了简单化异步编程而进行。避免了层层的回调函数，将回调函数转换成一条执行链。</p><p>Promise 构造函数只有一个参数，是一个函数，这个函数在构造之后会直接被异步运行，所以我们称之为起始函数。起始函数包含两个参数 <strong>resolve 和 reject</strong>。resolve表示函数正常运行，reject表示出现错误时运行</p><p><strong>在初始化Promise实例对象的时候，Promise的状态为pending；在调用resolve回调函数的时候，Promise的状态为fullfilled，表示成功状态；在调用reject回调函数的时候，Promise的状态为rejected，表示失败状态；</strong></p><p>Promise 类有 .then() .catch() 和 .finally() 三个方法，这三个方法的参数都是一个函数，<strong>.then()</strong> 可以将参数中的函数添加到当前 Promise 的正常执行序列，.catch() 则是设定 Promise 的异常处理序列，.finally() 是在 Promise 执行的最后一定会执行的序列。 .then() 传入的函数会按顺序依次执行，有任何异常都会直接跳到 catch 序列。</p><p>如果 then 中返回的是一个 Promise 对象，那么<strong>下一个 then</strong> 将相当于对这个返回的 Promise 进行操作</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 执行异步操作</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 执行异步操作成功,此时修改promise的状态fullfilled</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"success!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 执行异步操作成功,此时修改promise的状态rejected</span>    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">"failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// promise的状态fullfilled的操作</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"成功"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// promise的状态rejected的操作</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"失败"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//111 222 成功 success</span></code></pre><p>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。<strong>resolve或reject总是在本轮事件循环的末尾执行</strong>，所以最后才打印success。当调用resolve()函数将promise状态改变成fullfilled时，后面的reject()就不会执行</p><hr><p><strong>重点异步函数</strong>：async 和 await。方便，简洁.但await 指令后必须跟着一个 Promise，异步函数会在这个 Promise 运行中暂停，直到其运行结束再继续运行。</p><p>例：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">"First"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">await</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">4000</span><span class="token punctuation">,</span> <span class="token string">"Second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">await</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token string">"Third"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="4-DOM文档对象模型"><a href="#4-DOM文档对象模型" class="headerlink" title="4.DOM文档对象模型"></a>4.DOM文档对象模型</h5><p>通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素。</p><p>改变 <strong>HTML</strong> 元素的属性，请使用这个语法：</p><p>document.getElementById(<em>id</em>).<em>attribute=新属性值</em></p><hr><p>改变 HTML 元素的<strong>样式</strong>，请使用这个语法：</p><p>document.getElementById(<em>id</em>).style.<em>property</em>=<em>新样式</em></p><hr><p>添加<strong>监听</strong>事件。addEventListener() 方法允许向同一个元素添加多个事件，且不会覆盖已存在的事件。不论是同一种类型，还是不同的类型</p><p><em>element</em>.addEventListener(<em>event, function, useCapture</em>);</p><p>第一个参数是事件的类型 (如 “click” 或 “mousedown”).</p><p>第二个参数是事件触发后调用的函数。</p><p>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。</p><hr><p><strong>冒泡，捕获</strong>定义了事件触发的顺序</p><p>在 <em>冒泡</em> 中，<strong>内部</strong>元素的事件会先被触发，然后再触发外部元素</p><p>在 <em>捕获</em> 中，<strong>外部</strong>元素的事件会先被触发，然后才会触发内部元素的事件</p><h5 id="5-BOM浏览器对象模型"><a href="#5-BOM浏览器对象模型" class="headerlink" title="5.BOM浏览器对象模型"></a>5.BOM浏览器对象模型</h5><p>所有 JavaScript 全局对象、函数以及变量均自动成为 <strong>window 对象</strong>的成员。</p><p>window的常用方法：</p><ul><li>window.innerHeight - 浏览器窗口的内部高度(包括滚动条)</li><li>window.innerWidth - 浏览器窗口的内部宽度(包括滚动条)</li><li>window.open() - 打开新窗口</li><li>window.close() - 关闭当前窗口</li><li>window.moveTo() - 移动当前窗口</li><li>window.resizeTo() - 调整当前窗口的尺寸</li></ul><hr><p>window.<strong>location</strong> 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。使用时可省略window。</p><ul><li>location.href 属性返回当前页面的 URL。// <a href="https://www.runoob.com/js/js-window-location.html" target="_blank" rel="noopener">https://www.runoob.com/js/js-window-location.html</a></li><li>location.pathname 属性返回 URL 的路径名。 // /js/js-window-location.html</li><li>location.assign() 方法加载新的文档，打开新的网页。// window.location.assign(“<a href="https://www.runoob.com&quot;" target="_blank" rel="noopener">https://www.runoob.com&quot;</a>)</li></ul><hr><ul><li>history.back() - 与在浏览器点击后退按钮相同</li><li>history.forward() - 与在浏览器中点击向前按钮相同</li></ul><hr><p><strong>计时事件</strong></p><ul><li>setInterval(fucntion,time) - 间隔指定的毫秒数<strong>不停地执行</strong>指定的代码。</li><li>setTimeout(function,time) - 在指定的毫秒数后执行指定代码。</li><li>clearInterval() 方法用于停止 setInterval() 方法执行的函数代码。</li><li>clearTimeout() 方法用于停止执行setTimeout()方法的函数代码。</li></ul><hr><p><strong>cookie</strong></p><p>Cookie 的作用就是用于解决 “如何记录客户端的用户信息”.当用户访问 web 页面时，他的名字可以记录在 cookie 中.下一次访问就可以通过cookie读取用户访问记录。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//创建 cookie 如下所示：</span>document<span class="token punctuation">.</span>cookie<span class="token operator">=</span><span class="token string">"username=John Doe"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//读取 cookie：</span><span class="token keyword">var</span> x <span class="token operator">=</span> document<span class="token punctuation">.</span>cookie<span class="token punctuation">;</span></code></pre><h5 id="6-this"><a href="#6-this" class="headerlink" title="6.this"></a>6.this</h5><p>根据函数的调用方式的不同，this会指向不同的对象：【重要】</p><ul><li>1.以函数的形式调用时，this永远都是window。比如<code>fun();</code>相当于<code>window.fun();</code></li><li>2.以方法的形式调用时，this是调用方法的那个对象</li><li>3.以构造函数的形式调用时，this是新创建的那个对象</li><li>4.使用call和apply调用时，this是指定的那个对象</li></ul><h5 id="7-原型对象-原型链"><a href="#7-原型对象-原型链" class="headerlink" title="7.原型对象(原型链)"></a>7.原型对象(原型链)</h5><p><a href="http://www.cpengx.cn/p/357.html" target="_blank" rel="noopener">具体细节查看</a></p><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><p>我们所创建的每一个函数，解析器都会向函数中添加一个属性 prototype。这个属性对应着一个对象，这个对象就是我们所谓的原型对象。每个原型都有一个 constructor 属性指向关联的构造函数 实例原型指向构造函数</p><p>当函数以<strong>构造函数</strong>的形式调用时，它所创建的实例对象中都会有一个隐含的属性，指向该构造函数的原型，我们可以通过<strong>proto</strong>来访问该属性</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 定义构造函数</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> per1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> per2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 打印结果：[object object]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>per1<span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//注意后面是构造函数的prototype，前面为实例的__proti__</span><span class="token comment" spellcheck="true">// 打印结果：true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person <span class="token operator">===</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p><code>实例.__proto__</code> 和 <code>构造函数.prototype</code>都指的是原型对象。</p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/1490251-e7476a8697e97aab.png?imageMogr2/auto-orient/strip|imageView2/2/w/567/format/webp" alt="图解" style="zoom:80%;" /><p>原型对象就相当于一个<strong>公共</strong>的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p><h6 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h6><p>原型对象也是对象，所以它也有原型，当我们使用或访问一个对象的属性或方法时：</p><ul><li>它会先在对象自身中寻找，如果有则直接使用；</li><li>如果没有则会去原型对象中寻找，如果找到则直接使用；</li><li>如果没有则去原型的原型中寻找，直到找到Object对象的原型。</li><li>Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回 null</li></ul><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/1490251-3089c135df71c956.png?imageMogr2/auto-orient/strip|imageView2/2/w/604/format/webp" alt="原型链" style="zoom:60%;" />]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则入门笔记</title>
      <link href="/2020/08/24/%E6%AD%A3%E5%88%99%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/24/%E6%AD%A3%E5%88%99%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>大概就是网上的30分钟入门正则表达的一个个人总结。<a href="https://www.runoob.com/w3cnote/regular-expression-30-minutes-tutorial.html" target="_blank" rel="noopener">链接</a></p><p>不过就只是进行一个简单的学习和简单实用。<a href="https://blog.csdn.net/ZYC88888/article/details/98479629" target="_blank" rel="noopener">一些方便常用的正则早有人进行了总结</a></p><h5 id="1-元字符"><a href="#1-元字符" class="headerlink" title="1.元字符"></a>1.元字符</h5><p>(\b)，代表单词的开头或者结尾，并不匹配任何字符，只表明是匹配这个位置。</p><p>(.)元字符，匹配除了换行符以外的任意字符。(*)同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定(*)前边的内容可以连续重复使用任意次(可以是0次)以使整个表达式得到匹配。因此，(.*)连在一起就意味着任意数量的不包含换行的字符。如果是(+),这表示至少匹配一次或更多次</p><table><thead><tr><th align="left">代码</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">.</td><td align="left">匹配除换行符以外的任意字符</td></tr><tr><td align="left">\w</td><td align="left">匹配字母或数字或下划线或汉字</td></tr><tr><td align="left">\s</td><td align="left">匹配任意的空白符</td></tr><tr><td align="left">\d</td><td align="left">匹配数字</td></tr><tr><td align="left">\b</td><td align="left">匹配单词的开始或结束</td></tr><tr><td align="left">^</td><td align="left">匹配字符串的开始</td></tr><tr><td align="left">$</td><td align="left">匹配字符串的结束</td></tr></tbody></table><h5 id="2-匹配重复"><a href="#2-匹配重复" class="headerlink" title="2.匹配重复"></a>2.匹配重复</h5><p>就是进行多少次重复的匹配。一般是为了减少正则表达式的长度。</p><table><thead><tr><th align="left">代码/语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">重复零次或更多次</td></tr><tr><td align="left">+</td><td align="left">重复一次或更多次</td></tr><tr><td align="left">?</td><td align="left">重复零次或一次</td></tr><tr><td align="left">{n}</td><td align="left">重复n次</td></tr><tr><td align="left">{n,}</td><td align="left">重复n次或更多次</td></tr><tr><td align="left">{n,m}</td><td align="left">重复n到m次</td></tr></tbody></table><p>例：^\w+匹配一行的第一个单词或整个字符串的第一个单词</p><h5 id="3-字符类"><a href="#3-字符类" class="headerlink" title="3.字符类"></a>3.字符类</h5><p>为了解决一些特定的字符没有专门的匹配元字符，使用<strong>[]</strong>方括号包含这些特殊字符就行。</p><p>例：[.?!]匹配标点符号(.或?或!)。[0-9]代表的含意与\d就是完全一致的</p><p>\(?0\d{2}[) -]?\d{8}  首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个(方括号中间有一个<strong>空格</strong>)，它出现1次或不出现(?)，最后是8个数字(\d{8})。匹配例如(010)88886666，或022-22334455，或02912345678。</p><h5 id="4-分枝条件"><a href="#4-分枝条件" class="headerlink" title="4.分枝条件"></a>4.分枝条件</h5><p><strong>|</strong>，就是当成多个匹配式进行匹配。</p><p>例：0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。但要注意顺序，从左往右进行匹配，当匹配成功之后，后面的就不会再进行匹配了，有时候会出现一些奇怪的问题</p><h5 id="5-分组"><a href="#5-分组" class="headerlink" title="5.分组"></a>5.分组</h5><p>重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号<strong>()</strong>来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了</p><h5 id="6-反义"><a href="#6-反义" class="headerlink" title="6.反义"></a>6.反义</h5><p>查找不属于某个能简单定义的字符类的字符</p><table><thead><tr><th align="left">代码/语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">\W</td><td align="left">匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td align="left">\S</td><td align="left">匹配任意不是空白符的字符</td></tr><tr><td align="left">\D</td><td align="left">匹配任意非数字的字符</td></tr><tr><td align="left">\B</td><td align="left">匹配不是单词开头或结束的位置</td></tr><tr><td align="left">[^x]</td><td align="left">匹配除了x以外的任意字符</td></tr><tr><td align="left">[^aeiou]</td><td align="left">匹配除了aeiou这几个字母以外的任意字符</td></tr></tbody></table><p>例：\S+匹配不包含空白符的字符串。&lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串。</p><h5 id="7-后向引用"><a href="#7-后向引用" class="headerlink" title="7.后向引用"></a>7.后向引用</h5><p>大概就是在后面的正则使用前面的正则匹配出来的分组结果。具体查看文章开头链接</p><table><thead><tr><th align="left">分类</th><th align="left">代码/语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">捕获</td><td align="left">(exp)</td><td align="left">匹配exp,并捕获文本到自动命名的组里。exp为表达式</td></tr><tr><td align="left">(?<name>exp)</td><td align="left">匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td><td align="left"></td></tr><tr><td align="left">(?:exp)</td><td align="left">匹配exp,不捕获匹配的文本，也不给此分组分配组号</td><td align="left"></td></tr><tr><td align="left">零宽断言</td><td align="left">(?=exp)</td><td align="left">匹配exp前面的位置</td></tr><tr><td align="left">(?&lt;=exp)</td><td align="left">匹配exp后面的位置</td><td align="left"></td></tr><tr><td align="left">(?!exp)</td><td align="left">匹配后面跟的不是exp的位置</td><td align="left"></td></tr><tr><td align="left">(?&lt;!exp)</td><td align="left">匹配前面不是exp的位置</td><td align="left"></td></tr><tr><td align="left">注释</td><td align="left">(?#comment)</td><td align="left">这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td></tr></tbody></table><p>例：\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)</p><h5 id="8-零宽断言"><a href="#8-零宽断言" class="headerlink" title="8.零宽断言"></a>8.零宽断言</h5><p>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。</p><p>例：(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。</p><p>(?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。</p><p>同理也有负向零宽断言</p><p>例：零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。</p><p>同理，我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字</p><h5 id="9-注释"><a href="#9-注释" class="headerlink" title="9.注释"></a>9.注释</h5><p>小括号通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25<a href="?#250-255">0-5</a>|[01]?\d\d?(?#0-199)</p><h5 id="10-贪婪匹配和懒惰匹配"><a href="#10-贪婪匹配和懒惰匹配" class="headerlink" title="10.贪婪匹配和懒惰匹配"></a>10.贪婪匹配和懒惰匹配</h5><p>就是在匹配的时候，其结果是匹配竟可能长的字符串，还是竟可能短短的字符串</p><table><thead><tr><th align="left">代码/语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">*?</td><td align="left">重复任意次，但尽可能少重复</td></tr><tr><td align="left">+?</td><td align="left">重复1次或更多次，但尽可能少重复</td></tr><tr><td align="left">??</td><td align="left">重复0次或1次，但尽可能少重复</td></tr><tr><td align="left">{n,m}?</td><td align="left">重复n到m次，但尽可能少重复</td></tr><tr><td align="left">{n,}?</td><td align="left">重复n次以上，但尽可能少重复</td></tr></tbody></table><p>例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。</p><p>a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）</p><h4 id="特别"><a href="#特别" class="headerlink" title="特别"></a>特别</h4><p>在js里面的正则似乎跟前面的正则有些不同</p><p>其语法为：</p><pre class=" language-js"><code class="language-js"><span class="token operator">/</span>正则表达式主体<span class="token operator">/</span><span class="token function">修饰符</span><span class="token punctuation">(</span>可选<span class="token punctuation">)</span>例：<span class="token keyword">var</span> patt <span class="token operator">=</span> <span class="token regex">/^\d+\.\d+$/g</span>  <span class="token comment" spellcheck="true">//匹配是否带有小数</span></code></pre><table><thead><tr><th align="left">修饰符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">执行对大小写不敏感的匹配。</td></tr><tr><td align="left">g</td><td align="left">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td align="left">m</td><td align="left">执行多行匹配。</td></tr></tbody></table><h5 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h5><p>方括号用于查找某个范围内的字符：</p><table><thead><tr><th align="left">表达式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[abc]</td><td align="left">查找方括号之间的任何字符。</td></tr><tr><td align="left">[0-9]</td><td align="left">查找任何从 0 至 9 的数字。</td></tr><tr><td align="left">(x|y)</td><td align="left">查找任何以 | 分隔的选项。</td></tr></tbody></table><p>元字符是拥有特殊含义的字符：</p><table><thead><tr><th align="left">元字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\d</td><td align="left">查找数字。</td></tr><tr><td align="left">\s</td><td align="left">查找空白字符。</td></tr><tr><td align="left">\b</td><td align="left">匹配单词边界。</td></tr><tr><td align="left">\uxxxx</td><td align="left">查找以十六进制数 xxxx 规定的 Unicode 字符。</td></tr></tbody></table><p>量词:</p><table><thead><tr><th align="left">量词</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">n+</td><td align="left">匹配任何包含至少一个 <em>n</em> 的字符串。</td></tr><tr><td align="left">n*</td><td align="left">匹配任何包含零个或多个 <em>n</em> 的字符串。</td></tr><tr><td align="left">n?</td><td align="left">匹配任何包含零个或一个 <em>n</em> 的字符串。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> regexp 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue项目axios封装与mock等使用</title>
      <link href="/2020/08/22/vue%E9%A1%B9%E7%9B%AEaxios%E5%B0%81%E8%A3%85%E4%B8%8Emock%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/08/22/vue%E9%A1%B9%E7%9B%AEaxios%E5%B0%81%E8%A3%85%E4%B8%8Emock%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>大概就是对B站老陈的一个vue企业项目视频的细节抄写</p><h5 id="1-axios封装和请求响应劫持"><a href="#1-axios封装和请求响应劫持" class="headerlink" title="1.axios封装和请求响应劫持"></a>1.axios封装和请求响应劫持</h5><p>对将后端传回的数据，前端需要自己对数据进行一个拦截检查，看数据是否正确。</p><pre class=" language-js"><code class="language-js"><span class="token function">interceptors</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span>url<span class="token punctuation">)</span><span class="token punctuation">{</span>        instance<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//处理config</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'拦截和处理请求'</span><span class="token punctuation">)</span>            config<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">{</span>                msg<span class="token punctuation">:</span><span class="token string">"helloworld"</span>            <span class="token punctuation">}</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span>            <span class="token keyword">return</span> config        <span class="token punctuation">}</span><span class="token punctuation">)</span>        instance<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//处理响应</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"处理响应"</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//console.log(res)</span>            <span class="token keyword">return</span> res<span class="token punctuation">.</span>data        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//请求出问题，处理问题</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span>error<span class="token punctuation">:</span><span class="token string">"网络出错了"</span><span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><p>跨域的处理，一般是在后端设置一个中间件，允许进行跨域请求</p><pre class=" language-js"><code class="language-js"> app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span>res<span class="token punctuation">,</span>next<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">,</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-headers'</span><span class="token punctuation">,</span><span class="token string">"*"</span><span class="token punctuation">)</span>    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>或者设置一个代理服务，使用8080的本地端口作为代理去进行后端数据请求，之后再通过8080端口将数据返回。</p><p>设置代理服务器，使用vue-cli的自带配置vue.config.js。在vue-cli官网配置指南里面有专门的文档</p><pre class=" language-js"><code class="language-js">devServer<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//设置代理服务器跨域请求</span>        proxy<span class="token punctuation">:</span><span class="token punctuation">{</span>            <span class="token string">'/api'</span><span class="token punctuation">:</span><span class="token punctuation">{</span>                target<span class="token punctuation">:</span><span class="token string">"http://localhost:3000"</span><span class="token punctuation">,</span>                pathRewrite<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//重写访问路径，这里是变为空</span>                    <span class="token string">'^/api'</span><span class="token punctuation">:</span><span class="token string">""</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h5 id="2-mock-js模拟后端数据"><a href="#2-mock-js模拟后端数据" class="headerlink" title="2.mock.js模拟后端数据"></a>2.mock.js模拟后端数据</h5><p>通过劫持axios请求，将数据返回。路径可使用正则表达式</p><p>首先需要在main.js里面进行引入，如果是在开发模式。需要npm安装。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> Mock <span class="token keyword">from</span> <span class="token string">'mockjs'</span><span class="token punctuation">;</span>Mock<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token string">'/api/posi'</span><span class="token punctuation">,</span>position<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//position和index_entry是数据。需要export dedfault导出</span>Mock<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token string">'/api/index_entry'</span><span class="token punctuation">,</span>index_entry<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//或者</span>Mock<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token string">'/api/user'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>    username<span class="token punctuation">:</span><span class="token string">"老陈"</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">,</span>    gender<span class="token punctuation">:</span><span class="token string">"男"</span><span class="token punctuation">,</span>    type<span class="token punctuation">:</span><span class="token string">"帅"</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>特别的重点是mock可进行随机数据生成，不用自己去想这些随机数据</p><pre class=" language-js"><code class="language-js"><span class="token string">'name|min-max'</span><span class="token punctuation">:</span> stringMock<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token string">"string|1-10"</span><span class="token punctuation">:</span> <span class="token string">"★"</span><span class="token comment" spellcheck="true">//结果为1-10颗★</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token string">'name|min-max'</span><span class="token punctuation">:</span> numberMock<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token string">"number|1-100"</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token comment" spellcheck="true">//结果为1-100里的一个数字</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><a href="http://mockjs.com/examples.html#Image" target="_blank" rel="noopener">具体详细操作查看官方文档</a></p><h5 id="3-布局"><a href="#3-布局" class="headerlink" title="3.布局"></a>3.布局</h5><p>对于一个项目来说，需要响应式的进行布局，可以在任何常用设备上的布局比例不变，一般使用响应式进行操作布局。此项目使用rem布局，大概就是可根据屏幕的大小进行字体的大小调整。</p><p>相当于先确定一个px大小，例如100px为一个标准1rem。后面都通过这个标准1rem进行调整大小。</p><h5 id="4-图标使用"><a href="#4-图标使用" class="headerlink" title="4.图标使用"></a>4.图标使用</h5><p>一般可在iconfont里面找到想要的图标并添加进购物车，选择fontclass方式进行下载到本地，之后里面会有一个html文件教你怎么进行使用，一般是将图标文件放入到项目里的public文件夹里面的一个样式文件夹。之后在public里面的index.html里面进行css文件引入。</p><p><img src="/images/loading.gif" data-original="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200823102646390.png" alt="image-20200823102646390"></p><h5 id="5-组件"><a href="#5-组件" class="headerlink" title="5.组件"></a>5.组件</h5><p>全部导入一般是用在开发环境之下，真正的使用都是按需使用，具体查看官方文档</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//全部导入</span><span class="token comment" spellcheck="true">//main.js</span><span class="token keyword">import</span> Vant <span class="token keyword">from</span> <span class="token string">'vant'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">'vant/lib/index.css'</span><span class="token punctuation">;</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vant<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//xxx.vue</span><span class="token keyword">import</span> Button <span class="token keyword">from</span> <span class="token string">'vant/lib/button'</span><span class="token punctuation">;</span>components<span class="token punctuation">:</span> <span class="token punctuation">{</span>Button<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//需要注册</span></code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//按需导入，需要npm安装一个babel-plugin-import插件，并在babel.config.js里面进行一些修改，具体查看官方文档</span><span class="token comment" spellcheck="true">//xxx.vue</span><span class="token keyword">import</span> <span class="token punctuation">{</span> NavBar<span class="token punctuation">,</span>Icon <span class="token punctuation">,</span>Swipe<span class="token punctuation">,</span> SwipeItem<span class="token punctuation">,</span>Grid<span class="token punctuation">,</span> GridItem<span class="token punctuation">,</span>Image <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vant'</span><span class="token punctuation">;</span>components<span class="token punctuation">:</span> <span class="token punctuation">{</span>NavBar<span class="token punctuation">,</span>Icon <span class="token punctuation">,</span>Swipe<span class="token punctuation">,</span> SwipeItem<span class="token punctuation">,</span>Grid<span class="token punctuation">,</span> GridItem<span class="token punctuation">,</span>Image <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//依旧需要注册</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node.js初学习</title>
      <link href="/2020/08/04/node-js%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/08/04/node-js%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>多个地方的node学习，<a href="https://www.runoob.com/nodejs/nodejs-http-server.html" target="_blank" rel="noopener">包括菜鸟教程</a>，B站，<a href="http://www.cpengx.cn/p/386.html" target="_blank" rel="noopener">老陈这些</a>。</p><p>1.介绍</p><p>主要用于编写服务端程序，类似于javaweb里面的jsp这些。</p><p><strong>二、Node.js与javaScript</strong></p><table><thead><tr><th align="left">javaScript</th><th align="left">Node.js</th></tr></thead><tbody><tr><td align="left">客户端技术，运行于浏览器中</td><td align="left">服务器端技术 ，与php,jsp等是类似的技术</td></tr><tr><td align="left">有多种解释器可以使用，如IE的Chakra,FF的猴子系列，Chrome的V8等等</td><td align="left">只能运行于基于V8引擎改进而来的运行时环境</td></tr><tr><td align="left">因为解释器有多种，所以存在代码兼容性问题</td><td align="left">只有一种解释器，所以不存在代码兼容性问题</td></tr><tr><td align="left">支持ES对象，自定义对象，BOM&amp;DOM对象</td><td align="left">支持ES对象，自定义对象，Node.js扩展对象（大量）</td></tr><tr><td align="left">主要用于网页DOM元素的操作，实现用户交互效果</td><td align="left">主要用于实现服务器端运行逻辑，如文件系统操作，数据库访问，其他服务器调用等</td></tr></tbody></table><p>3.Node.js 应用是由哪几部分组成的：</p><ol><li><p><strong>引入 required 模块：</strong>我们可以使用 <strong>require</strong> 指令来载入 Node.js 模块。当需要导入一个文件，在被导入的文件里需要通过module.exports导出</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//http是内置的模块</span><span class="token keyword">let</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./fs.js"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//导入一个fs.js文件</span></code></pre></li><li><p><strong>创建服务器：</strong>服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。</p><pre class=" language-js"><code class="language-js">http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 发送 HTTP 头部 </span>    <span class="token comment" spellcheck="true">// HTTP 状态值: 200 : OK</span>    <span class="token comment" spellcheck="true">// 内容类型: text/plain</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'Content-Type'</span><span class="token punctuation">:</span> <span class="token string">'text/plain'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 发送响应数据 "Hello World"</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Hello World\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//端口号</span></code></pre></li><li><p><strong>接收请求与响应请求</strong> 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。</p></li></ol><p>4.NPM</p><p>是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题</p><p>​    1.使用npm安装模块</p><pre class=" language-powershell"><code class="language-powershell">$ npm install &lt;Module Name><span class="token keyword">var</span> express = require<span class="token punctuation">(</span><span class="token string">'modele name'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span>使用require引用</code></pre><pre class=" language-powershell"><code class="language-powershell">npm install express          <span class="token comment" spellcheck="true"># 本地安装</span>npm install express <span class="token operator">-</span>g   <span class="token comment" spellcheck="true"># 全局安装</span></code></pre><h6 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h6><ul><li>\1. 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li><li>\2. 可以通过 require() 来引入本地安装的包。</li></ul><h6 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h6><ul><li>\1. 将安装包放在 /usr/local 下或者你 node 的安装目录。</li><li>\2. 可以直接在命令行里使用</li></ul><p>2.packag.json</p><p>package.json 位于模块的目录下，用于定义包的属性。位于 node_modules/modules name/package.json </p><p>在里面的最直观的是<strong>dependencies</strong> - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</p><p>5.回调函数，为了提高并发请求的处理，可不阻塞的执行代码</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"fs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'input.txt'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"程序执行结束!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//结果</span>$ node main<span class="token punctuation">.</span>js程序执行结束<span class="token operator">!</span>菜鸟教程官网地址：www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com</code></pre><p>6.EventEmitter</p><p>一个对事件的处理函数，类似于之前的sokect</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 引入 events 模块</span><span class="token keyword">var</span> events <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'events'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建 eventEmitter 对象</span><span class="token keyword">var</span> EventEmitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">events<span class="token punctuation">.</span>EventEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> event<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span>arg2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//监听事件</span>event<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'arg1'</span><span class="token punctuation">,</span><span class="token string">'arg2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//触发事件,可带参数</span></code></pre><p>7.buffer缓冲区</p><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在<strong>处理像TCP流或文件流</strong>时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。有自己的特定编码</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 创建一个长度为 10、且用 0 填充的 Buffer。</span><span class="token keyword">const</span> buf <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>、<span class="token comment" spellcheck="true">//写入缓冲区,如果 buffer 空间不足， 则只会写入部分字符串</span>len <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"www.runoob.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"写入字节数 : "</span><span class="token operator">+</span>  len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 写入字节数：14</span><span class="token comment" spellcheck="true">//从缓冲区读数据</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string">'ascii'</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//使用 'ascii' 编码, 并输出: www.r，后面两个参数为起始位置和结束位置</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用 'utf8' 编码, 并输出: www.r</span><span class="token comment" spellcheck="true">//将buffer转换为json,当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该 toJSON()。返回json对象</span><span class="token keyword">const</span> json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>后面还有一些方法，在<a href="https://www.runoob.com/nodejs/nodejs-buffer.html" target="_blank" rel="noopener">菜鸟</a>那里需要的时候看吧。</p><p>8.stream</p><p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）</p><p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p><ul><li><strong>data</strong> - 当有数据可读时触发。</li><li><strong>end</strong> - 没有更多的数据可读时触发。</li><li><strong>error</strong> - 在接收和写入过程中发生错误时触发。</li><li><strong>finish</strong> - 所有数据已被写入到底层系统时触发。</li></ul><p><a href="https://www.runoob.com/nodejs/nodejs-stream.html" target="_blank" rel="noopener">具体看菜鸟</a></p><p>9.模块化</p><p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。</p><p>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">var</span> name<span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>setName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>thyName<span class="token punctuation">)</span> <span class="token punctuation">{</span>         name <span class="token operator">=</span> thyName<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>sayHello <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello '</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Hello<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//进行导出</span><span class="token keyword">var</span> Hello <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//进行引入 </span>hello <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> hello<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">'BYVoid'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> hello<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>10.函数</p><p>一个函数可以作为另一个函数的参数,也可以在传递参数的地方直接定义函数.</p><p>11.路由</p><p>结合之下vue的路由来看基本没太大的变化，更多的是多了些关于相对底层的原理实现。</p><p><strong>setTimeout(cb, ms)</strong> 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。</p><p><strong>setInterval(cb, ms)</strong> 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。</p><p>12.node常用工具<strong>util</strong> </p><p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心 JavaScript 的功能 过于精简的不足。</p><p>使用方法如下：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> util <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'util'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a href="https://www.runoob.com/nodejs/nodejs-util.html" target="_blank" rel="noopener">具体函数看菜鸟</a></p><p>13.文件系统</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"fs"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//fileSystem</span></code></pre><h6 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h6><p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。</p><p>异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。建议使用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。就是可以直接执行读写文件后面的代码指令，而不需要等待文件读写完成。</p><pre class=" language-js"><code class="language-js">fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'input.txt'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//回调错误函数</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"异步读取: "</span> <span class="token operator">+</span> data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同步读取，主要看那sync</span><span class="token keyword">var</span> data <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'input.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="打开文件等"><a href="#打开文件等" class="headerlink" title="打开文件等"></a>打开文件等</h6><pre class=" language-js"><code class="language-js">fs<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> flags<span class="token punctuation">[</span><span class="token punctuation">,</span> mode<span class="token punctuation">]</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//flags为文件打开行为</span>fs<span class="token punctuation">.</span><span class="token function">stat</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取文件信息，会将stats类的实例返回给其回调函数。可以通过stats类中的提供方法判断文件的相关属性</span>fs<span class="token punctuation">.</span><span class="token function">stat</span><span class="token punctuation">(</span><span class="token string">'/Users/liuht/code/itbilu/demo/fs.js'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> stats<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//类似如此</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stats<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//true</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><a href="https://www.runoob.com/nodejs/nodejs-fs.html" target="_blank" rel="noopener">具体参数参考菜鸟</a></p><h6 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h6><pre class=" language-java"><code class="language-java">fs<span class="token punctuation">.</span><span class="token function">writeFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> data<span class="token punctuation">[</span><span class="token punctuation">,</span> options<span class="token punctuation">]</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span></code></pre><ul><li><strong>file</strong> - 文件名或文件描述符。</li><li><strong>data</strong> - 要写入文件的数据，可以是 String(字符串) 或 Buffer(缓冲) 对象。</li><li><strong>options</strong> - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’,该方法写入的内容会覆盖旧的文件内容。</li><li><strong>callback</strong> - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。</li></ul><h6 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h6><pre><code>fs.read(fd, buffer, offset, length, position, callback);//示例var buf = new Buffer.alloc(1024);fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){      if (err){         console.log(err);      }      console.log(bytes + &quot;  字节被读取&quot;);      // 仅输出读取的字节      if(bytes &gt; 0){         console.log(buf.slice(0, bytes).toString());      }   });</code></pre><ul><li><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</li><li><strong>buffer</strong> - 数据写入的缓冲区。</li><li><strong>offset</strong> - 缓冲区写入的写入偏移量。</li><li><strong>length</strong> - 要从文件中读取的字节数。</li><li><strong>position</strong> - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。</li><li><strong>callback</strong> - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript初学习</title>
      <link href="/2020/07/29/typescript%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/29/typescript%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>typescript学习,下面简称ts.有些语法类似于java</p><p>typescript是js的一个超集，添加了一些新的扩展.主要目的是为了开发大型应用。</p><ul><li>类型批注和编译时类型检查</li><li>类型推断</li><li>类型擦除</li><li>接口</li><li>枚举</li><li>Mixin</li><li>泛型编程</li><li>名字空间</li><li>元组</li><li>Await</li></ul><p>2.使用<strong>npm install -g typescript</strong>安装进行使用，<strong>tsc</strong>是使用的标识，<strong>.ts</strong>是typescript文件扩展名。执行以下命令将 TypeScript 转换为 JavaScript 代码：</p><pre class=" language-powershell"><code class="language-powershell">tsc test<span class="token punctuation">.</span>ts</code></pre><p>3.TypeScript 程序由以下几个部分组成：</p><ul><li>模块</li><li>函数</li><li>变量</li><li>语句和表达式</li><li>注释</li></ul><p>每一行指令都是一段语句，可使用分号进行语句隔开，使合理。</p><p>4.TypeScript 面向对象编程实例：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Site</span> <span class="token punctuation">{</span>    <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">void</span> <span class="token punctuation">{</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Runoob"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Site</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> obj<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 函数定义</span><span class="token keyword">function</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>string <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 返回一个字符串，需要写明返回类型</span>    <span class="token keyword">return</span> <span class="token string">"Hello World"</span> <span class="token punctuation">}</span> </code></pre><p>编译后生成的 JavaScript 代码如下：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> Site <span class="token operator">=</span> <span class="token comment" spellcheck="true">/** @class */</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">Site</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    Site<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Runoob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Site<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Site</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>ts有些特殊的变量类型，如<strong>any</strong>，一般用于用户的输入，定义存储各种类型的数组。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> arrayList<span class="token punctuation">:</span> any<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">'fine'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ts的变量声明格式</span><span class="token keyword">let</span> myts<span class="token punctuation">:</span> number <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">var</span> uname<span class="token punctuation">:</span>string <span class="token operator">=</span> <span class="token string">"Runoob"</span><span class="token punctuation">;</span> arrayList<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></code></pre><p>ts里定义函数的参数可设置可选(通过?)，在参数后面需要指明参数类型。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">buildName</span><span class="token punctuation">(</span>firstName<span class="token punctuation">:</span> string <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">,</span> lastName<span class="token operator">?</span><span class="token punctuation">:</span> string<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//可设置默认值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lastName<span class="token punctuation">)</span>        <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> lastName<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> firstName<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> result1 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正确</span><span class="token keyword">let</span> result2 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token string">"Adams"</span><span class="token punctuation">,</span> <span class="token string">"Sr."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 错误，</span><span class="token keyword">let</span> result3 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token string">"Adams"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正确</span></code></pre><p>ts的剩余参数，指不知道需要传入多少参数。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">addNumbers</span><span class="token punctuation">(</span><span class="token operator">...</span>nums<span class="token punctuation">:</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//一般是数组</span>    <span class="token keyword">var</span> i<span class="token punctuation">;</span>       <span class="token keyword">var</span> sum<span class="token punctuation">:</span>number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//ts的变量声明格式</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"和为："</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token function">addNumbers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> </code></pre><p>ts也可使用函数重载(函数名相同，参数不同)</p><p>ts数组可解构(将数组元素赋值给变量)</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">"Runoob"</span><span class="token punctuation">]</span> <span class="token keyword">var</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> a <span class="token comment" spellcheck="true">//解构，es6好像有新的解构方式(...)</span></code></pre><p>有一些常用数组方法</p><ul><li>contact(),链接两个数组元素</li><li>forEach(),对每个元素进行一次回调函数</li><li>pop(),删除最后一个元素</li><li>push(),在末尾添加一个元素</li><li>slice(),选取数组的一部分</li></ul><p>ts元组，就是一个数组，但里面的元素类型不同。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> mytuple <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">"Runoob"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建元组</span></code></pre><p>ts联合类型，就是一个变量可以有多个类型，以（|）分开。还可形成联合类型数组</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> val<span class="token punctuation">:</span>string<span class="token operator">|</span>number val <span class="token operator">=</span> <span class="token number">12</span> val <span class="token operator">=</span> <span class="token string">"Runoob"</span> </code></pre><p>ts接口，还是interface定义一个抽象接口，当做一个类型进行使用。也可使用extend继承多个接口进行扩展</p><pre class=" language-js"><code class="language-js"><span class="token keyword">interface</span> <span class="token class-name">IPerson</span> <span class="token punctuation">{</span>     firstName<span class="token punctuation">:</span>string<span class="token punctuation">,</span>     lastName<span class="token punctuation">:</span>string<span class="token punctuation">,</span>     sayHi<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span>string <span class="token punctuation">}</span> <span class="token keyword">var</span> customer<span class="token punctuation">:</span>IPerson <span class="token operator">=</span> <span class="token punctuation">{</span>     firstName<span class="token punctuation">:</span><span class="token string">"Tom"</span><span class="token punctuation">,</span>    lastName<span class="token punctuation">:</span><span class="token string">"Hanks"</span><span class="token punctuation">,</span>     sayHi<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>string <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">"Hi there"</span><span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>ts类，面向对象编程,也可extend继承,不能继承父类的私有成员(方法和属性)和构造函数，不支持多继承，支持多重继承，可进行重写，和super调用父类属性和方法类可使用接口，使用关键字 implements，并将接口的属性作为类的属性使用。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">car</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 类作用域,可包含以下几个模块</span><span class="token comment" spellcheck="true">//字段 - 是类里面声明的变量。字段表示对象的有关数据。</span><span class="token comment" spellcheck="true">//构造函数 − 类实例化时调用，可以为类的对象分配内存。</span><span class="token comment" spellcheck="true">//方法 − 方法为对象要执行的操作。</span>    engine<span class="token punctuation">:</span><span class="token keyword">string</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 构造函数 </span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span>engine<span class="token punctuation">:</span><span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>engine <span class="token operator">=</span> engine     <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 方法 </span>    <span class="token function">disp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">void</span> <span class="token punctuation">{</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"发动机为 :   "</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>engine<span class="token punctuation">)</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> car <span class="token operator">=</span> <span class="token comment" spellcheck="true">/** @class */</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//js代码</span>    <span class="token keyword">function</span> <span class="token function">Car</span><span class="token punctuation">(</span>engine<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>engine <span class="token operator">=</span> engine<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 方法 </span>    Car<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>disp <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"发动机为 :   "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>engine<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Car<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>ts命名空间，为了解决重名问题。命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的，命名空间可嵌套。使用 <strong>namespace</strong> 来定义，</p><pre class=" language-typescript"><code class="language-typescript">namespace SomeNameSpaceName <span class="token punctuation">{</span>    <span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">ISomeInterfaceName</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>     <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">SomeClassName</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//export导出表示可外部调用 </span><span class="token punctuation">}</span></code></pre><p>5.ts模块</p><p>模块是在其自身的作用域里执行，在外部不可见，除非使用 export进行导出，在其他需要使用的地方通过import进行导入。模块使用模块加载器去导入其它的模块，如服务于 Web 应用的 Require.js</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">SomeInterface</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 代码部分</span><span class="token punctuation">}</span><span class="token keyword">import</span> someInterfaceRef <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./SomeInterface"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue总结</title>
      <link href="/2020/07/27/vue%E6%80%BB%E7%BB%93/"/>
      <url>/2020/07/27/vue%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>先简单的学习了一些vue的基础知识，先做一个基础的总结，免得知识有些混乱和忘记，只是稍微提一下，并给一个例子</p><h5 id="1-基础常用语法"><a href="#1-基础常用语法" class="headerlink" title="1.基础常用语法"></a>1.<strong>基础常用语法</strong></h5><p>v-bind,v-on,v-model,v-for,v-if/v-show,</p><p>2.在vue实例里面，需要el挂载，data数据，methods方法，computed计算属性，watch侦听器侦听数据变化，</p><p>3.核心组件，专门建一个文件夹放置组件这些可复用的页面，在需要使用的时候，需要使用import引入组件。</p><p>组件里面包括<template></template>里面放置html代码，<script></script>放置js代码，<style></style>放置css代码。</p><p>还有组件之间传递值的方式。</p><p>4.动画，<transition> 需要动画效果的html代码</transition></p><p>5.路由，根据路径的不同显示不同地页面组件。路由守卫，就是对路由的传递进行验证看是否满足什么条件</p><p>6.css预编译less。</p><p>7.vuex，对大型vue应用的数据进行统一管理。</p><h5 id="8-B站vue商城项目总结"><a href="#8-B站vue商城项目总结" class="headerlink" title="8.B站vue商城项目总结"></a>8.B站vue商城项目总结</h5><p>​    跟着在B站老陈的视频进行vue的一些学习，最后面就是对前面学习的一些知识的总结性使用。做了一个仿网易严选的商城项目。这里面，你说技术并没有很难，最大的感受还是对现在前端的开发有了一些理解，特别是对ui组件的使用，可以直接就拿现有的组件进行开发，对前端的组件化开发有了一些理解。</p><p>​    在这个项目里面使用了路由，组件，vuex，axios等技术的使用，对后端返回的数据也有了一些认识。知道该如何获取和使用。在这里面，更多的感觉到了组件化开发的好处和开发一个组件的困难。在购物车的单选和全选那里，因为组件本身的改变，和官网页面的更新不及时(可能是这个原因),导致一直有一些问题存在，最后还是自己修改了后端传来的数据和添加了一些方法(这些方法，看着就写的一塌糊涂)，最后才实现的。</p><p>​    下一步，应该是对现在前端的typescript和前面只学了一点点的es6,7还有对现在css的一些学习模仿，和js跟深一点的东西的学习。还有node.js.</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6初学习</title>
      <link href="/2020/07/24/ES6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/24/ES6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>js的一种版本标准，只是为了学一些重点的新语法。</p><h4 id="1-箭头函数"><a href="#1-箭头函数" class="headerlink" title="1.箭头函数"></a>1.箭头函数</h4><p><strong>箭头函数的作用主要是定义匿名函数</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 转换成箭头函数</span><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>基本语法<strong>（参数）</strong>：</p><ul><li>匿名函数没有参数：() 不能省略，占位作用。<code>let foo = () =&gt; {};</code></li><li>只有一个参数：() 可以省略，也可以不省略。<code>let foo = a =&gt; {};</code></li><li>多个参数，() 不能省略。<code>let foo = (a,b) =&gt; {};</code></li></ul><p><strong>箭头函数的特点：</strong></p><p>1、不能做构造函数（不能实例化）</p><p>2、没有 arguments。 arguments就是函数带的实参，类似linux的argv，可用arguments获取调用的参数。</p><p><strong>3、箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，this指向上下文环境。（意思：箭头函数的外层的是否有函数，如果有，箭头函数的this就是外层函数的this，如果没有，则为 window）</strong></p><hr><h4 id="2-let-与-const"><a href="#2-let-与-const" class="headerlink" title="2.let 与 const"></a>2.let 与 const</h4><p>let 声明的变量只在 let 命令所在的代码块内有效。</p><p>const 声明一个只读的常量，一旦声明，常量的值就不能改变。</p><hr><h4 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3.解构赋值"></a>3.解构赋值</h4><p>解构赋值是对赋值运算符的扩展，他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</p><p><strong>从对象或数组中提取数据, 并赋值给变量(多个)</strong>。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>name <span class="token punctuation">:</span> <span class="token string">'kobe'</span><span class="token punctuation">,</span> age <span class="token punctuation">:</span> <span class="token number">39</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> name <span class="token operator">=</span> obj<span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token keyword">let</span> age <span class="token operator">=</span> obj<span class="token punctuation">.</span>age<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解构</span><span class="token keyword">let</span> <span class="token punctuation">{</span>name<span class="token punctuation">,</span>age<span class="token punctuation">}</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span></code></pre><hr><h4 id="4-展开符-三点运算符-…"><a href="#4-展开符-三点运算符-…" class="headerlink" title="4.展开符/三点运算符(…)"></a>4.展开符/三点运算符(…)</h4><p>用来取代 arguments 但比 arguments 灵活.</p><p><img src="/images/loading.gif" data-original="https://gitee.com/xxgw1997/Web-2/raw/master/12-ES6/images/9.png" alt="img"></p><p>或者可用来对数组进行扩展</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span>arr1<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1,2,3,4,5,6]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 2 3 4 5 6</span></code></pre><hr><h4 id="5-async-函数"><a href="#5-async-函数" class="headerlink" title="5.async 函数"></a>5.async 函数</h4><p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">helloAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token string">"helloAsync"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">helloAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// Promise {&lt;resolved>: "helloAsync"}</span><span class="token function">helloAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// helloAsync。async里的return返回会成为then()回调函数的参数。</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。</p><h4 id="6-class类"><a href="#6-class类" class="headerlink" title="6.class类"></a>6.class类</h4><p>为了方便创建对象。形似java里面的class类</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//定义类</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'('</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">', '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> newclass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建</span></code></pre><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p><hr><p>class可以继承。<strong>extends</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">ColorPoint</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用父类的constructor(x,y)，子类必须在constructor方法中调用super方法，主要构建父类的this对象。</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用父类的toString()</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><img src="/images/loading.gif" data-original="https://www.runoob.com/wp-content/uploads/2018/12/es6-tutorial.jpg" alt="img" style="zoom: 50%;" />]]></content>
      
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vant,插件,混入,自定义指令</title>
      <link href="/2020/07/23/vant,%E6%8F%92%E4%BB%B6,%E6%B7%B7%E5%85%A5,%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"/>
      <url>/2020/07/23/vant,%E6%8F%92%E4%BB%B6,%E6%B7%B7%E5%85%A5,%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>1.vuex插件</strong></p><p>Vuex 的 store 接受 <code>plugins</code> 选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 store 作为唯一参数：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> myPlugin <span class="token operator">=</span> store <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 当 store 初始化后调用</span>  store<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span>mutation<span class="token punctuation">,</span> state<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 每次 mutation 之后调用</span>    <span class="token comment" spellcheck="true">// mutation 的格式为 { type, payload }</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>然后像这样使用：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>myPlugin<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>在插件中不允许直接修改状态——类似于组件，只能通过提交 mutation 来触发变化,通过提交 mutation，插件可以用来同步数据源到 store</p><p><strong>2.混入</strong></p><p>相当于将各个部分分开，使其可复用，混在一起使用，与合在一起写的效果相同</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> mixin <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//定义需要混入的部分</span>  data<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      message<span class="token punctuation">:</span> <span class="token string">'hello'</span><span class="token punctuation">,</span>      foo<span class="token punctuation">:</span> <span class="token string">'abc'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  mixins<span class="token punctuation">:</span> <span class="token punctuation">[</span>mixin<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//使用mixins使用混入</span>  data<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      message<span class="token punctuation">:</span> <span class="token string">'goodbye'</span><span class="token punctuation">,</span>      bar<span class="token punctuation">:</span> <span class="token string">'def'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// => { message: "goodbye", foo: "abc", bar: "def" }</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>当出现同名属性，数据的时候，以组件中的为主，如果是方法(methods)，则都会调用，但混入的会先被调用。</p><p><strong>3.自定义指令</strong></p><p>使用Vue.directive进行指令创建</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 注册一个全局自定义指令 `v-focus`</span>Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'focus'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 当被绑定的元素插入到 DOM 中时……</span>  inserted<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 聚焦元素，el表示的是使用这个指令的标签的html代码</span>    el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h5 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a><a href="https://cn.vuejs.org/v2/guide/custom-directive.html#钩子函数" target="_blank" rel="noopener">钩子函数</a></h5><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><ul><li><p><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p></li><li><p><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p></li><li><p><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p></li><li><p><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</p></li><li><p><code>unbind</code>：只调用一次，指令与元素解绑时调用。</p></li></ul><p>接下来我们来看一下钩子函数的参数 (即 <code>el</code>、<code>binding</code>、<code>vnode</code> 和 <code>oldVnode</code>)。</p><h5 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a><a href="https://cn.vuejs.org/v2/guide/custom-directive.html#钩子函数参数" target="_blank" rel="noopener">钩子函数参数</a></h5><p>指令钩子函数会被传入以下参数：</p><ul><li><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM。</li><li><code>binding</code>：一个对象，包含以下 property：<ul><li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li><li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li><li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li><li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li><li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li><li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code>。</li></ul></li><li><code>vnode</code>：Vue 编译生成的虚拟节点。移步 <a href="https://cn.vuejs.org/v2/api/#VNode-接口" target="_blank" rel="noopener">VNode API</a> 来了解更多详情。</li><li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li></ul><p>除了 <code>el</code> 之外，其它参数都应该是只读的，切勿进行修改。</p><p>4.vue插件</p><p>通过全局方法 <code>Vue.use()</code> 使用插件</p><p>Vue.js 的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象：</p><pre class=" language-js"><code class="language-js">MyPlugin<span class="token punctuation">.</span>install <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>Vue<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 1. 添加全局方法或 property</span>  Vue<span class="token punctuation">.</span>myGlobalMethod <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 逻辑...</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 2. 添加全局资源</span>  Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'my-directive'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    bind <span class="token punctuation">(</span>el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 逻辑...</span>    <span class="token punctuation">}</span>    <span class="token operator">...</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 3. 注入组件选项</span>  Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 逻辑...</span>    <span class="token punctuation">}</span>    <span class="token operator">...</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 4. 添加实例方法</span>  Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$myMethod <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>methodOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 逻辑...</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>5.vant</p><p>参考官网<a href="https://youzan.github.io/vant/?source=vuejsorg#/zh-CN/button" target="_blank" rel="noopener">vant</a></p><p>ui组件。先<code>npm i vant -S</code>安装，之后</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Vant <span class="token keyword">from</span> <span class="token string">'vant'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//全局导入，不推荐</span><span class="token keyword">import</span> <span class="token string">'vant/lib/index.css'</span><span class="token punctuation">;</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vant<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//按需导入，推荐</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> Button <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vant'</span><span class="token punctuation">;</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Button<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>导入vant包和样式，并使用vue.use进行使用</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>van-button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>default<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>默认按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>van-button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>van-button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>primary<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>主要按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>van-button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>van-button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>信息按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>van-button</span><span class="token punctuation">></span></span></code></pre><p>具体使用和参数参考vant官网。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vuex vue vant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex</title>
      <link href="/2020/07/19/vuex/"/>
      <url>/2020/07/19/vuex/</url>
      
        <content type="html"><![CDATA[<p>Vuex 是一个专为 大型Vue.js 应用程序开发的<strong>状态管理模式</strong></p><p>1.简单来说，vuex就是用来集中管理组件的数据的(多组件共享的数据)。</p><p><strong>数据驱动视图，动作(action)更改数据</strong>，是一个环形单向数据流。</p><p>每一个 Vuex 应用的核心就是 store(数据仓库)。</p><p>2.vuex需要安装</p><pre><code>npm install vuex -S</code></pre><p>3.在vue应用的下面会多出来一个store的文件夹，在里面使用vuex。首先会在里面的index.js里面创建仓库对象。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//data</span>state<span class="token punctuation">:</span> <span class="token punctuation">{</span>    num<span class="token punctuation">:</span><span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> getters<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//methods,在mutation里处理状态</span>  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">addnum</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">{</span>      state<span class="token punctuation">.</span>num<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//异步方法</span> actions<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//模块</span> modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>  buyCar <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>在state里面添加全局数据，在mutation里面添加全局方法，修改数据。组件想要调用此方法，需要使用this.$store.commit(‘addnum’);进行调用。通过$store.state.num获得数据。</p><h5 id="4-state"><a href="#4-state" class="headerlink" title="4.state"></a><strong>4.state</strong></h5><p>在组件里的应用，一般放在computed里面当做一个函数，返回一个在state里面的数据，如</p><pre class=" language-js"><code class="language-js">msg<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> $store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>num<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="4-1-mapstate"><a href="#4-1-mapstate" class="headerlink" title="4.1 mapstate"></a>4.1 mapstate</h6><p>简化我们获取数据的方式，mapState的作用就是返回一个对象，这个对象可以直接丢给computed</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> mapState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token comment" spellcheck="true">//需要引用</span>   <span class="token comment" spellcheck="true">// computed: {//旧方法</span>    <span class="token comment" spellcheck="true">//     userList: function() {</span>    <span class="token comment" spellcheck="true">//         return this.$store.state.userList;</span>    <span class="token comment" spellcheck="true">//     },</span>    <span class="token comment" spellcheck="true">//     goodsList: function() {</span>    <span class="token comment" spellcheck="true">//         return this.$store.state.goodsList;</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">// }</span>computed<span class="token punctuation">:</span> <span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token function">title</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> state<span class="token punctuation">.</span>title<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">userList</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> state<span class="token punctuation">.</span>userList<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">goodsList</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> state<span class="token punctuation">.</span>goodsList<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre><p>如果state上有某个属性，可以直接赋值：</p><pre class=" language-js"><code class="language-js">computed<span class="token punctuation">:</span> <span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    title<span class="token punctuation">:</span> <span class="token string">'title'</span><span class="token punctuation">,</span>    userList<span class="token punctuation">:</span> <span class="token string">'userList'</span><span class="token punctuation">,</span>    goodsList<span class="token punctuation">:</span> <span class="token string">'goodsList'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre><p>如果mapState属性的名字和state中属性的名字相同的话，就可以采用下面更简单的写法：</p><pre class=" language-js"><code class="language-js">computed<span class="token punctuation">:</span> <span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">,</span> <span class="token string">'goodsList'</span><span class="token punctuation">,</span> <span class="token string">'userList'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>有些复杂数据还是推荐使用第一种。</p><h5 id="5-getter"><a href="#5-getter" class="headerlink" title="5.getter"></a><strong>5.getter</strong></h5><p>相当于store的一个计算属性，就是对state的数据进行计算，当组件需要取到state的属性然后进行计算得到想要的结果的时候，计算的过程可以在<code>getters</code> 中进行，组件从getters中就可以直接拿到计算好的值。如果所有组件都需要这个计算的话，那就方便多了。</p><pre class=" language-js"><code class="language-js">getters<span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...   ，可接受其他getter作为参数</span>  doneTodosCount<span class="token punctuation">:</span> <span class="token punctuation">(</span>state<span class="token punctuation">,</span> getters<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> getters<span class="token punctuation">.</span>doneTodos<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//return state.num++;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值</p><pre class=" language-js"><code class="language-js">computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">,</span> <span class="token string">'userList'</span><span class="token punctuation">,</span> <span class="token string">'goodsList'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 直接调用getters的countAge属性即可</span>    <span class="token function">allAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>countAge    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><h6 id="5-1-mapgetter"><a href="#5-1-mapgetter" class="headerlink" title="5.1 mapgetter"></a>5.1 mapgetter</h6><p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p><pre class=" language-js"><code class="language-js"> <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">{</span> allAge<span class="token punctuation">:</span> <span class="token string">'countAge'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// allAge() {</span>    <span class="token comment" spellcheck="true">//     return this.$store.getters.countAge</span>    <span class="token comment" spellcheck="true">// }</span></code></pre><h5 id="6-mutation"><a href="#6-mutation" class="headerlink" title="6.mutation"></a><strong>6.mutation</strong></h5><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation</p><p>当需要在store里面操作数据的增删的时候，需要使用mutation属性。</p><p>可以在mutation里面添加方法，进行修改数据</p><pre class=" language-js"><code class="language-js">mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">addUser</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>            state<span class="token punctuation">.</span>userList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> userName<span class="token punctuation">:</span> <span class="token string">'aaa'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//在组件里也使用进行调用。</span>methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 使用commit的方式调用</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'addUser'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p><strong>我们在commit的第二个参数传递数据。这里有个专业的术语叫做【载荷】，只能有一个</strong></p><pre class=" language-js"><code class="language-js"> mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// data接收commit的载荷</span>        <span class="token function">addUser</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>            state<span class="token punctuation">.</span>userList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                userName<span class="token punctuation">:</span> data<span class="token punctuation">.</span>name<span class="token punctuation">,</span>                age<span class="token punctuation">:</span> data<span class="token punctuation">.</span>age            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//组件里面</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// commit的第二个参数填写传递的载荷</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'addUser'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>                name<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span>                age<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>​    整个应用程序，只有mutations才可以操作state状态。</p><p>​    但是注意：</p><p>​    <strong>mutations中的属性，必须为纯函数，必须为同步代码。</strong></p><p>​    纯函数就是传入相同的参数，得到相同的结果。</p><p>​    同步代码就不能是异步的，比如ajax，比如setTimeout等。</p><h5 id="7-action"><a href="#7-action" class="headerlink" title="7.action"></a><strong>7.action</strong></h5><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><p><em>能操作state的只有mutations，<strong>actions也不行</strong>。只能调用mutations去操作state。</em></p><p>在action里面可通过commit调用mutation你的数据操纵方法，在组件你的methods里面使用dispatch调用action里的方法</p><pre class=" language-js"><code class="language-js"><span class="token function">addUserTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用dispatch调用actions的属性</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'addUserTimeout'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span>            age<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>总结mutations与actiosn的区别：</strong></p><p>​    1、commit方法用于调用mutation；dispatch 方法用于调用action；</p><p>​    2、mutation 函数必须是纯函数，而且不能有异步代码；action 可以不是纯函数，也可以有异步代码；</p><p>​    3、按照上述规则，可以用mutation完成的事情，可以直接调用mutation，mutation不能实现的事情丢给action来完成。</p><p>​    4、在action中，当完成异步操作，最终需要修改数据模型时，还是需要通过mutation来完成对数据模型的操作。action不允许直接操作数据模型。</p><h5 id="8-module"><a href="#8-module" class="headerlink" title="8.module"></a><strong>8.module</strong></h5><p>Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>  state<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  getters<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> moduleB <span class="token operator">=</span> <span class="token punctuation">{</span>  state<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//需要在index.js里导入，上面两个是一个各自单独的文件</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> moduleA<span class="token punctuation">,</span>    b<span class="token punctuation">:</span> moduleB  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>a <span class="token comment" spellcheck="true">// -> moduleA 的状态</span>store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>b <span class="token comment" spellcheck="true">// -> moduleB 的状态</span></code></pre><h6 id="8-1命名空间"><a href="#8-1命名空间" class="headerlink" title="8.1命名空间"></a>8.1命名空间</h6><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p><p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名，使用的时候会使用这个命名</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 开启命名空间</span>    namespaced<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    state<span class="token punctuation">:</span> <span class="token punctuation">{</span>        title<span class="token punctuation">:</span> <span class="token string">'我是首页'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue路由与less</title>
      <link href="/2020/07/15/vue%E8%B7%AF%E7%94%B1%E4%B8%8Eless/"/>
      <url>/2020/07/15/vue%E8%B7%AF%E7%94%B1%E4%B8%8Eless/</url>
      
        <content type="html"><![CDATA[<h5 id="B站老陈"><a href="#B站老陈" class="headerlink" title="B站老陈"></a>B站老陈</h5><p>1.socket.io(套接字),用于浏览器和服务器进行实时，双向，基于事件(异步)的通信。这是其他的知识点，不是vue本身的知识点</p><p>socket. emit(‘名’,’数据’),发送客户端数据。socket.on(‘名’,function(data){})监听客户端或服务器发送的内容</p><p>服务器与客户端之间的连接以一个唯一的id进行标识，当一个新的用户浏览器进行与服务器的连接时，需要进行广播(sockets.emit())，将此连接的id广播给其他客户端，方便进行数据交流,使用socket.to(目标id).emit(‘名’,{数据})</p><p>命名空间，用以区分。通过socket.join和leave可以加入和离开房间</p><p>2.vue实现原理</p><p>首先vue可以当做一个构造函数，传入一个参数为对象。</p><p>3.less。css扩展语言，预处理器。让其可重复使用，但浏览器不支持，需要编译转化为css。使用</p><pre><code>lessc 源文件.less 目标文件.css</code></pre><p>将less文件编译成css文件。</p><p>使用@变量名 = xxx,定义全局可使用的变量。可混合带参数使用，直接在一个class里面引入另一个class名，即可将样式复制过来，参数也可在样式里面当一个变量。参数需要@符号声明。参数可以使用一个默认值，当没有参数传入时，就使用默认值。@_匹配模式，相当于匹配一些class，再加上一些样式。还可对变量进行计算可进行样式直接嵌套(不建议使用嵌套)</p><p>可使用@argument将所有的默认变量传入。</p><pre><code>.border_arg(@width: 1.75rem, @color: #e6e6e6, @style: solid) {    border: @arguments}</code></pre><p>在vue里面使用less：</p><p>需要在sytle标签里面设置lang属性为less。lang=”less”。</p><p>4.router路由</p><p>根据不同的路径显示不同的页面。在router里面的index.js里面配置不同的路径显示的不同的组件或者页面。根据选择的<router-link>替换<router-view/>来显示内容。在本质上还是一个页面。</p><p>所有的核心配置都在index.js里面</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token punctuation">{</span>    path<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>    name<span class="token punctuation">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//component: Home</span>    components<span class="token punctuation">:</span><span class="token punctuation">{</span>      nav<span class="token punctuation">:</span>navView<span class="token punctuation">,</span>      aside<span class="token punctuation">:</span>asideView<span class="token punctuation">,</span>      <span class="token keyword">default</span><span class="token punctuation">:</span>Home    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    path<span class="token punctuation">:</span><span class="token string">"/a"</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//redirect:"/about"</span>    redirect<span class="token punctuation">:</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>query<span class="token punctuation">.</span>go<span class="token operator">==</span><span class="token string">'about'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">"about"</span><span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">"news"</span><span class="token punctuation">,</span>params<span class="token punctuation">:</span><span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token number">456789</span><span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span></code></pre><p>通过path，name，component设置。</p><p>我们可以在任何组件内通过 <code>this.$router</code> 访问路由器，也可以通过 <code>this.$route</code> 访问当前路由</p><p><strong>动态路由</strong>，把某种模式匹配到的所有路由，全都映射到同个组件。在path里面可使用通配符 <code>*</code>进行匹配任意路径，一般用于404页面。当使用一个通配符时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 URL 通过通配符被匹配的部分</p><pre class=" language-js"><code class="language-js">routes<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token comment" spellcheck="true">// 动态路径参数 以冒号开头</span><span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//通过$route.params.id可获得路径后的id参数值</span><span class="token keyword">const</span> User <span class="token operator">=</span> <span class="token punctuation">{</span>template<span class="token punctuation">:</span> <span class="token string">'&lt;div>User {{ $route.params.id }}&lt;/div>'</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 会匹配以 `/user-` 开头的任意路径</span>path<span class="token punctuation">:</span> <span class="token string">'/user-*'</span><span class="token punctuation">}</span>    </code></pre><p>可使用watch进行监听路由发生的变化</p><pre class=" language-js"><code class="language-js">watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">$route</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 对路由变化作出响应...</span>    <span class="token punctuation">}</span></code></pre><p><strong>嵌套路由</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User<span class="token punctuation">,</span>      children<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 当 /user/:id/profile 匹配成功，</span>          <span class="token comment" spellcheck="true">// UserProfile 会被渲染在 User 的 &lt;router-view> 中</span>          path<span class="token punctuation">:</span> <span class="token string">'profile'</span><span class="token punctuation">,</span>          component<span class="token punctuation">:</span> UserProfile        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 当 /user/:id/posts 匹配成功</span>          <span class="token comment" spellcheck="true">// UserPosts 会被渲染在 User 的 &lt;router-view> 中</span>          path<span class="token punctuation">:</span> <span class="token string">'posts'</span><span class="token punctuation">,</span>          component<span class="token punctuation">:</span> UserPosts        <span class="token punctuation">}</span>      <span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>使用children属性进行嵌套的配置。还可以继续进行嵌套。</p><p><strong>编程式导航</strong>(使用点击事件在js的mehtods里面使用)，除了使用 <code>&lt;router-link&gt;</code>，还可使用</p><p><code>router.push(location, onComplete?, onAbort?)</code>进行导航。使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 字符串</span>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'home'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 对象</span>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'home'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 命名的路由</span>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span> params<span class="token punctuation">:</span> <span class="token punctuation">{</span> userId<span class="token punctuation">:</span> <span class="token string">'123'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 带查询参数，变成 /register?plan=private</span>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'register'</span><span class="token punctuation">,</span> query<span class="token punctuation">:</span> <span class="token punctuation">{</span> plan<span class="token punctuation">:</span> <span class="token string">'private'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><strong>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，params将以path里面的为准</strong></p><p>router.go(n)这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步</p><p><strong>命名路由</strong></p><p>通过一个名称来标识一个路由</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/user/:userId'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> User    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token punctuation">:</span>to<span class="token operator">=</span><span class="token string">"{ name: 'user', params: { userId: 123 }}"</span><span class="token operator">></span>User<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">></span><span class="token comment" spellcheck="true">//这跟代码调用 router.push() 是一回事：</span>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span> params<span class="token punctuation">:</span> <span class="token punctuation">{</span> userId<span class="token punctuation">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><strong>命名视图</strong></p><p>同时 (同级) 展示多个视图，而不是嵌套展示，你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。之前router-link时，只有一个router-view进行替换，只会有一个视图，现在可通过命名视图将几个视图何在一个页面上。</p><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。需要使用components进行配置，默认为default。也可配合嵌套路由，在childern里面使用命名视图。</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>router<span class="token operator">-</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"view one"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span><span class="token operator">&lt;</span>router<span class="token operator">-</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"view two"</span> name<span class="token operator">=</span><span class="token string">"a"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span><span class="token operator">&lt;</span>router<span class="token operator">-</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"view three"</span> name<span class="token operator">=</span><span class="token string">"b"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token keyword">default</span><span class="token punctuation">:</span> Foo<span class="token punctuation">,</span>        a<span class="token punctuation">:</span> Bar<span class="token punctuation">,</span>        b<span class="token punctuation">:</span> Baz      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><strong>重定向和别名</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> redirect<span class="token punctuation">:</span> <span class="token string">'/b'</span> <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>重定向的目标也可以是一个命名的路由：<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> redirect<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'foo'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>甚至是一个方法，动态返回重定向目标：<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> redirect<span class="token punctuation">:</span> to <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 方法接收 目标路由 作为参数</span>      <span class="token comment" spellcheck="true">// return 重定向的 字符串路径/路径对象</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>​    <code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> A<span class="token punctuation">,</span> alias<span class="token punctuation">:</span> <span class="token string">'/b'</span> <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p><p><strong>路由组件传参</strong></p><p>在组件中使用 <code>$route</code> 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。使用 <code>props</code> 将组件和路由解耦：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> User <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;div>User {{ $route.params.id }}&lt;/div>'</span><span class="token punctuation">}</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//组件传参props</span><span class="token keyword">const</span> User <span class="token operator">=</span> <span class="token punctuation">{</span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;div>User {{ id }}&lt;/div>'</span><span class="token punctuation">}</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User<span class="token punctuation">,</span> props<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token punctuation">:</span> User<span class="token punctuation">,</span> sidebar<span class="token punctuation">:</span> Sidebar <span class="token punctuation">}</span><span class="token punctuation">,</span>      props<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> sidebar<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>在组件里也使用props将传入的数据拿到，进行数据显示。</p><p><strong>路由守卫</strong></p><p>简单来说就是路由在跳转之前的验证，当满足条件时才会进行跳转。分为<code>全局守卫</code>，<code>路由守卫</code>和<code>组件守卫</code></p><p>​    1.注册全局守卫应该在路由模块暴露出去之前定义，所有的路由跳转都会被调用使用<code>router.beforeEach(function(to,from,next){})</code>来注册一个全局守卫。</p><p>参数：</p><ul><li><p>to：代表目标路径对象</p></li><li><p>from：来源路径对象</p></li><li><p>next：用于决定是否继续进行跳转。</p><p>当next()函数不传参数或者传入true的时候 则允许正常跳转；</p><p>当next()函数传入false时 会中断跳转(阻止跳转)；</p><p>当next()函数中<strong>传入路径</strong>时或者<strong>对象</strong>时(比如:{name:’xxx’})则会重定向到指定路径。</p><p>2.路由守卫就是针对单个路由对象配置的守卫。</p></li></ul><p>假如我在users组件配置路由守卫，那么只有跳转到users路由时才会触发该守卫，跳转到其他路由时不会触发该守卫。</p><p>路由守卫的注册写在路由匹配规则数组里面：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token comment" spellcheck="true">//...        </span>    <span class="token punctuation">{</span>path<span class="token punctuation">:</span> <span class="token string">'/users'</span><span class="token punctuation">,</span>                 component<span class="token punctuation">:</span> Users<span class="token punctuation">,</span>                 name<span class="token punctuation">:</span> <span class="token string">'u'</span><span class="token punctuation">,</span>                 beforeEnter<span class="token punctuation">:</span> <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                                             <span class="token function">next</span><span class="token punctuation">(</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">'Entey Users?'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    3.组件守卫是针对单个组件进行监听，在访问到该组件时才会触发。</p><p>​    写在组件里</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">let</span> Home <span class="token operator">=</span> <span class="token punctuation">{</span>    template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`        &lt;div>            &lt;h1>首页&lt;/h1>            &lt;router-view>&lt;/router-view>            &lt;router-view name="b">&lt;/router-view>        &lt;/div>    `</span></span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 在路由跳转时,如果会访问到当前组件,则会触发该守卫</span>    <span class="token function">beforeRouteEnter</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">'Enter Home?'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 在路由跳转时,如果离开当前组件,则会触发该守卫</span>    beforeRouteLeave <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">'Leave Home?'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 在当前路径下,当路由的参数发生变化时，才会触发该路由守卫</span>    <span class="token function">beforeRouteUpdate</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>params<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>路由元信息</strong></p><p>路由的特有属性，写在meta:{ }里面，为后面的组件提供一些特定信息进行逻辑判断。</p><p><strong>过渡动效</strong></p><p>用 <code>&lt;transition&gt;</code> 组件给它添加一些过渡效果</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>transition name<span class="token operator">=</span><span class="token string">"slide"</span> mode<span class="token operator">=</span><span class="token string">"out-in"</span> enter<span class="token operator">-</span>active<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"animated bounceInLeft"</span> leave<span class="token operator">-</span>active<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"animated bounceOutRight"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive<span class="token operator">></span>        <span class="token operator">&lt;</span>router<span class="token operator">-</span>view<span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>transition<span class="token operator">></span></code></pre><p><strong>数据获取</strong></p><p>一般通过axio获取后端返回的数据，再进行操作</p><p><strong>滚动行为</strong></p><p>当创建一个 Router 实例，你可以提供一个 <code>scrollBehavior</code> 方法</p><pre class=" language-js"><code class="language-js">scrollBehavior <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> savedPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>savedPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> savedPosition  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>路由懒加载</strong></p><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue socket less route </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue进一步学习</title>
      <link href="/2020/07/13/vue%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/13/vue%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="vue的B站老陈学习"><a href="#vue的B站老陈学习" class="headerlink" title="vue的B站老陈学习"></a>vue的B站老陈学习</h4><p>那些基本的在vue初学习大多都说了，这一篇记一些没说到的。</p><h5 id="1-过渡动画，一般使用transition完成。"><a href="#1-过渡动画，一般使用transition完成。" class="headerlink" title="1.过渡动画，一般使用transition完成。"></a>1.过渡动画，一般使用transition完成。</h5><pre class=" language-html"><code class="language-html">&lt;transition name = "nameoftransition">   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">></span></span></code></pre><p>需要指定这个动画的名字(这里是fade)。</p><p><strong>重点是css里面的css类名和css动画效果</strong></p><p>一般是动画名(例如fade)再加一些特定标识，如</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.fade-enter-active</span>, <span class="token class">.fade-leave-active</span> </span><span class="token punctuation">{</span>    <span class="token property">transition</span><span class="token punctuation">:</span> opacity <span class="token number">2</span>s<span class="token punctuation">}</span><span class="token selector"><span class="token class">.fade-enter</span>, <span class="token class">.fade-leave-to</span>  </span><span class="token punctuation">{</span>    <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token comment" spellcheck="true">/*opacity表示透明效果*/</span><span class="token punctuation">}</span></code></pre><p>active表示动画的进行时间，enter和leave-to表示刚进入的效果和最终离开时的效果。还有enter-to和leave这两个表示动画最后的效果和离开开始的过渡状态。</p><img src="/images/loading.gif" data-original="https://www.runoob.com/wp-content/uploads/2018/06/transition.png" alt="img" style="zoom:50%;" /><p>还可以使用自定义的类名，可以和第三方css类插件库(如:animate.css)进行配合。</p><p>如：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span>    <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>custom-classes-transition<span class="token punctuation">"</span></span>    <span class="token attr-name">enter-active-class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>animated tada<span class="token punctuation">"</span></span>    <span class="token attr-name">leave-active-class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>animated bounceOutRight<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">></span></span></code></pre><p>此外还有enter-class,leave-class,enter-to-class,leave-to-class.与上面相对应。</p><p>过渡时间你也可以在transition里面是绑定duration进行设置。如：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span> <span class="token attr-name">:duration</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span> <span class="token attr-name">:duration</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{ enter: 500, leave: 800 }<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">></span></span></code></pre><h5 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2.生命周期"></a>2.生命周期</h5><img src="/images/loading.gif" data-original="https://cn.vuejs.org/images/lifecycle.png" alt="Vue å®ä¾çå½å¨æ" style="zoom:33%;" /><p>我们能拿到的只有红色框里面的东西，中间的都是vue自动完成，我们无法控制。一般直接在vue实例里面添加这些东西进行控制。如：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//进行控制.</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a is: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>在beforeCreate里面输出this和vue里面的data会有不同，this表示vue实例刚创建，但data里面的数据还没有绑定，会输出undefined，同时methods这些也没有绑定</p><p>在beforeCreate和created这中间就是绑定data和methods这些。</p><p>created之后就是渲染页面，在渲染之前绑定的一些数据在vue实例里面不会拿到，虽然在浏览器html里面有了。在渲染之后(mounted)就可以拿到这些dom对象。</p><p>当数据被修改，也会有两个阶段，在before阶段，虽然数据修改了，但内容还没渲染修改，在updated后，就会重新渲染，内容也改变了。</p><p>销毁一般很少调用。</p><h5 id="3-组件感觉还有一些东西要写。"><a href="#3-组件感觉还有一些东西要写。" class="headerlink" title="3.组件感觉还有一些东西要写。"></a>3.组件感觉还有一些东西要写。</h5><p>prop传递数据（子组件用来接受父组件传递过来的数据的一个自定义属性）：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">message</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hello!<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parentMsg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>//动态prop传递数据      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>message1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parentMsg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token comment" spellcheck="true">// 注册</span>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'child'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 声明 props</span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'message'</span><span class="token punctuation">,</span><span class="token string">'message1'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 同样也可以在 vm 实例中像 "this.message" 这样使用</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;span>{{ message }}+{{message1}}&lt;/span>'</span><span class="token punctuation">}</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>自定义事件（子组件要把数据传递回去，就需要使用自定义事件）</p><pre class=" language-vue"><code class="language-vue"><div id="app">    <div id="counter-event-example">      <p>{{ total }}</p>      <button-counter v-on:increment="incrementTotal"></button-counter>      <button-counter v-on:increment="incrementTotal"></button-counter>    </div></div><script>Vue.component('button-counter', {  template: '<button v-on:click="incrementHandler">{{ counter }}</button>',  data: function () {    return {      counter: 0    }  },  methods: {    incrementHandler: function () {      this.counter += 1      this.$emit('increment')//触发increment事件,在v-on监听里面触发，调用vue实例里面的函数    }  },})new Vue({  el: '#counter-event-example',  data: {    total: 0  },  methods: {    incrementTotal: function () {      this.total += 1    }  }})</script></code></pre><p>component里面的data必须是一个函数，为了保证每个组件的数据不共用。注意驼峰命名法在html里面需要转换成横线格式。</p><p>同时有$parent,$children,$root属性，可以在组件中找到父元素的vue对象，子元素的，根(最外层对象)的这些，之后就可以当做vue对象进行调用方法之类的。</p><p>v-model也可以绑定到组件上，默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，需要在组件的template里面添加相应监听和$emit()调用。</p><p><strong>一般使用.vue分开使用组件的话</strong></p><p><strong>父组件给子组件传递数据：在父组件的子组件标签里面通过v-bind绑定一个<u>特定名</u>和数据。在子组件里使用props声明这个<u>特定名</u>，然后就可以使用这个特定名进行数据使用。</strong></p><p><strong>子组件给父组件传递数据和使用父组件的方法：</strong></p><p>​    <strong>1.在父组件的子组件标签里面通过v-on监听一个<u>特定名</u>和一个在父组件里面的methods的方法名，在子组件里面自定义一个点击事件之类的，触发在子组件里面自定义的方法，在这个方法里面通过this.$emit(‘<u>特定名</u>‘,’数据’)，就会通过这个特定名调用父组件里面的方法，数据也作为参数传递了过去。</strong></p><p>​    <strong>2.在父组件里通过v-bind绑定一个<u>特定名</u>和<u>父组件方法</u>，在子组件里通过props声明这个特定名，然后就可以把这个<u>特定名</u>当做一个方法进行使用</strong></p><h5 id="4-插槽。"><a href="#4-插槽。" class="headerlink" title="4.插槽。"></a>4.插槽。</h5><p>整体结构不变，但要插入一些内容。<slot></slot>,新版本(2.6.0)可使用v-slot。一般来说，在自定义组件的标签里面添加内容，是不会被渲染到页面上去的，但slot解决了这个问题。<slot>在组件的template里面添加使用，添加之后，当在组件标签里面添加内容时，slot将会被替换掉，内容可被渲染到页面上。一个组件的template最外层只会有一个标签，一般可使用一个div将所有元素进行包裹。</p><p><strong>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</strong></p><h5 id="5-动态组件。"><a href="#5-动态组件。" class="headerlink" title="5.动态组件。"></a>5.动态组件。</h5><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>is</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>currentTabComponent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">></span></span></code></pre><p>可使用is属性切换不同的组件。</p><p>is用法。其中currentTabComponent是在vue实例里面进行数据定义，然后在局部定义组件和方法进行切换currentTabComponent，在this.$options.components[id]，this表示vue实例，获取到组件实例，之后将component标签替换成这个组件。</p><p>一般切换的时候，都会重新渲染组件。当我们不想让其重新渲染的时候，就可以使用<keep-alive>标签。如</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>is</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>currentTabComponent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">></span></span></code></pre><p> keep-alive要求被切换到的组件都有自己的名字，不论是通过组件的 <code>name</code>选项还是局部/全局注册。</p><p>因为一些标签 有一些限制出现的地方，如<li>，为了避免这些情况，在组件中的template使用<strong>单文件组件(.vue文件)</strong>就不会存在这些限制，这也是重点。</p><h5 id="6-单文件组件-vue文件"><a href="#6-单文件组件-vue文件" class="headerlink" title="6.单文件组件(.vue文件)"></a>6.<strong>单文件组件(.vue文件)</strong></h5><p>脚手架。.vue文件解决了<strong>全局定义</strong> <strong>字符串模板</strong> <strong>不支持组件 CSS</strong>  <strong>没有构建步骤</strong>这些缺点</p><p>1.解决了<strong>全局定义</strong> <strong>字符串模板</strong> <strong>不支持组件 CSS</strong>  <strong>没有构建步骤</strong>这些缺点，使关注点分离，模块化开发。</p><p>2.vue-cli    vue.js的<a href="https://cli.vuejs.org/zh/guide/prototyping.html" target="_blank" rel="noopener">标准开发工具</a></p><p>3.安装vue-cli按照官方文档的命令进行就可以了，不要其他的不加@符号的命令，在vscode终端里面目前是需要3版本以上。推荐使用git-bash进行npm下载或者cnpm下载。如果出现了什么命令没找到，注意添加安装路径到环境变量。如果安装好了，在bash里面vue –version没有问题，但在vscode终端里无法使用，将vscode设置成管理员打开。vue ui可以进行更简易化的创建配置操作。</p><p>4.在src目录里面开发，使用npm run serve看效果，npm run build打包到dist文件夹，可将dist文件夹部署到服务器，当做平常网站。注意绝对路径(/)，和相对路径(./)</p><p>5.将文件模块化，明确文件关系</p><p><strong>6.app.vue文件</strong>。核心文件，在template里面写html代码，script里面写js，style里面写css。注意全局使用驼峰命名，防止一些奇怪错误，注意在使用组件时，需要将驼峰命名变为横线。</p><pre class=" language-vue"><code class="language-vue"><template>  <div id="app">    <chat-com></chat-com>    <userlist-com></userlist-com>  </div></template><script>import chatCom from './components/chatcom'import userlistCom from './components/userlistcom'export default {  name: 'App',  components: {    chatCom,    userlistCom  }}</script><style>#app {  font-family: Avenir, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;}</style></code></pre><p>使用import引入自定义组件，并在export default的component里面声明，里面的<strong>数据data是返回一个对象</strong>.</p><hr><p>报错和解决方法：</p><p>1.Newline required at end of file but not found eol-last</p><p>在.vue文件的最后一行后面加一个空行，还只能加一个空行，多了不行</p><p>2.miss什么什么的，在miss的地方加空格。好吧，这是最考试创建的时候开启了eclint选项，是一个严格语法结构。不能使用tab，空格多了两个。</p><p>3.推荐使用vscode的格式化文档(代码格式化为：alt+shift+f)，再对照错误进行修改，字符串使用单引号。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue laochen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue初学习</title>
      <link href="/2020/07/08/vue%E5%88%9D%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/08/vue%E5%88%9D%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="关于自己对Vue初学习的一些知识点和理解，基本无用"><a href="#关于自己对Vue初学习的一些知识点和理解，基本无用" class="headerlink" title="关于自己对Vue初学习的一些知识点和理解，基本无用"></a>关于自己对Vue初学习的一些知识点和理解，基本无用</h4><p>学习的地方包括Vue自己的网站，菜鸟教程，B站等。主要是在vue.js里面看的一些知识点，有些不清，需要修改。</p><h5 id="1-vue对象中会有两个重要的属性，el和data，表示绑定的属性和数据。"><a href="#1-vue对象中会有两个重要的属性，el和data，表示绑定的属性和数据。" class="headerlink" title="1.vue对象中会有两个重要的属性，el和data，表示绑定的属性和数据。"></a>1.vue对象中会有两个重要的属性，el和data，表示绑定的属性和数据。</h5><h5 id="2-模板语法"><a href="#2-模板语法" class="headerlink" title="2.模板语法"></a>2.模板语法</h5><p>插值：数据绑定：文本：, v-once；原始html：v-html，将html文本转换为html样式；作用于html 的attribute：v-bind,</p><p>指令：指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute,一些指令可以带参数。</p><p>动态参数：可以用方括号括起来的 JavaScript 表达式作为一个指令的参数。可以使用null字符串显式的移除此属性。</p><p><strong><code>v-bind</code> 指令可以用于响应式地更新 HTML attribute，</strong></p><p><strong><code>v-on</code> 指令，它用于监听 DOM 事件,</strong>进行事件处理</p><h5 id="3-计算属性和侦听器"><a href="#3-计算属性和侦听器" class="headerlink" title="3.计算属性和侦听器"></a>3.计算属性和侦听器</h5><p>​    1.对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>computed。</p><p>​    2.我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。只要值没有发生变化，就不会再次计算属性，直接返回上一次的计算结果。而方法会每一次重新渲染时都重新计算。</p><p>​    3.Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：<strong>侦听属性</strong> </p><h5 id="4-class和style绑定"><a href="#4-class和style绑定" class="headerlink" title="4.class和style绑定"></a>4.class和style绑定</h5><p>​    1.对象语法，使用v-bind:class指令。</p><p>​    2.绑定内联样式，v-bind:style指令。是一个js对象</p><h5 id="5-条件渲染"><a href="#5-条件渲染" class="headerlink" title="5.条件渲染"></a>5.条件渲染</h5><p>​    1.v-if条件性的渲染一部分内容，一般使用<template>进行包裹，根据if的条件看是否显示，再使用v-if可以渲染多个内容。还有配套的 v-else,还有v-else-if进行连续使用。</p><p>​    2.v-show的使用与v-if差不多，但没有v-else这些。同时因为各自特性，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p><h5 id="6-列表渲染"><a href="#6-列表渲染" class="headerlink" title="6.列表渲染"></a>6.列表渲染</h5><p>​    1.v-for，使用(item,index) in items的格式执行。其中items需要在vue里面的data里指定数据。也可使用value in object进行对象循环，也可使用(value, name, index)进行对象里面的数据，键名，索引访问。也可以使用n in 10进行循环。类似于 <code>v-if</code>，你也可以利用带有 <code>v-for</code> 的 <code>&lt;template&gt;</code> 来循环渲染一段包含多个元素的内容。</p><h5 id="7-事件处理"><a href="#7-事件处理" class="headerlink" title="7.事件处理"></a>7.事件处理</h5><p>​    1.v-on监听dom事件，并执行一些js代码。还可以接收一个需要调用的方法名称。在vue的methods里面添加方法。</p><p>​    Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><pre class=" language-vue"><code class="language-vue"><!-- 阻止单击事件继续传播 --><a v-on:click.stop="doThis"></a><!-- 提交事件不再重载页面 --><form v-on:submit.prevent="onSubmit"></form><!-- 修饰符可以串联 --><a v-on:click.stop.prevent="doThat"></a><!-- 只有修饰符 --><form v-on:submit.prevent></form><!-- 添加事件监听器时使用事件捕获模式 --><!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --><div v-on:click.capture="doThis">...</div><!-- 只当在 event.target 是当前元素自身时触发处理函数 --><!-- 即事件不是从内部元素触发的 --><div v-on:click.self="doThat">...</div><!-- 点击事件将只会触发一次 --><a v-on:click.once="doThis"></a></code></pre><p>​    使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p><p>​    2.监听按键事件时，可以使用按键修饰符，如：v-on:keyup.enter，只有enter键可以触发事件。</p><h5 id="8-表单输入绑定"><a href="#8-表单输入绑定" class="headerlink" title="8.表单输入绑定"></a>8.表单输入绑定</h5><p>​    1.v-model，创建双向数据绑定，一处数据发生变化，另一处也会发生变化。</p><p>​    <code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li><li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</li><li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li></ul><p>​    2.文本，多行文本，复选框，单选按钮，选择框。</p><p>​    3.值绑定</p><p>​    4.修饰符，.lazy;.number;.trim</p><h5 id="9-组件"><a href="#9-组件" class="headerlink" title="9.组件"></a>9.组件</h5><p>​    1.组件可以扩展 HTML 元素，封装可重用的代码，是可复用的vue实例。组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树。<strong>每个组件都只有一个根元素</strong></p><p>​    2.Vue.component创建组件，第一个参数是组件名称，第二个参数是以对象的实例描述一个组件。通过将组件名作为标签进行调用。<strong>一个组件的 <code>data</code> 选项必须是一个函数</strong>，多个组件的使用，其数据都是分开的，不会互相影响。</p><p>​    3.组件需要注册，Vue.component全局注册，先在js里定义组件，再在vue实例中通过component定义想使用的组件局部注册。</p><p>​    4.组件里使用prop向子组件传递数据，当做自定义的attribute传递数据。也可使用v-bind动态传递prop，且是单向的。</p><p>​    5.监听子组件事件，父级组件可以像处理 native DOM 事件一样通过 <code>v-on</code> 监听子组件实例的任意事件：</p><pre class=" language-vue"><code class="language-vue"><blog-post  ...  v-on:enlarge-text="postFontSize += 0.1"></blog-post></code></pre><p>同时子组件可以通过调用内建的 <a href="https://cn.vuejs.org/v2/api/#vm-emit" target="_blank" rel="noopener"><strong><code>$emit</code></strong> 方法</a>并传入事件名称来触发一个事件：</p><pre class=" language-vue"><code class="language-vue"><button v-on:click="$emit('enlarge-text')">  Enlarge text</button></code></pre><p>​    6.<slot>内容</slot>，在组件里面通过vue自定义的slot可以实现插槽效果。</p><p>​    7.动态组件，通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 <code>is</code> attribute 来实现。</p><h5 id="10-自定义事件"><a href="#10-自定义事件" class="headerlink" title="10.自定义事件"></a>10.自定义事件</h5><p>​    1.Vue.directive自定义指令，第一个参数是名字，或在vue实例中通过directives局部注册。会有几个钩子函数bind,inserted,update,componentUpdated,unbind.</p><p>差不多这篇文章就不想写了，看其他的吧,基本无用。</p><h4 id="vue的黑马学习，就是一些简单指令的使用"><a href="#vue的黑马学习，就是一些简单指令的使用" class="headerlink" title="vue的黑马学习，就是一些简单指令的使用"></a>vue的黑马学习，就是一些简单指令的使用</h4><p>1.vue作用范围，只有在vue实例的el挂载点里面及其后代元素才会进行这个vue实例的操作。不仅可以使用id选择器，class选择器也行，使用.class进行el挂载。其他的选择器也都能行。可以使用其他的双标签，但不能是body和html标签。</p><p>2.Vue中用到的数据定义在data中，data中可以写复杂类型的数据，渲染复杂类型数据时,遵守js的语法即可</p><p>3.dom操作是获取元素，操作它们。vue使用指令操作</p><p>4.v-text指令。直接替换标签里面的所有文字和数据。跟两个大括号没什么差别。</p><p>5.v-html，设置标签的innerHTML，就是将纯html文本解析成html效果。</p><p>6.v-on，为元素绑定事件，类似onclick等。v-on:click=”函数名”,函数在vue实例的methods里面定义，methods:{click:function(){ }, other:{ } }。同时，在函数名后面可以传递参数，相应在定义函数时也要添加这个参数。还可以使用(.)表示的指令后缀调用修饰符。如@click.once=””,只会调用一次，@keyup.enter=””这些。</p><p>7.v-show,根据表达值的真假，切换元素的显示和隐藏。本质就是切换display属性。</p><p>8.v-if,v-if=”值”,根据值的真假，判断是否显示，但不是操纵display，而是直接操纵dom元素。</p><p>9.v-bind,设置元素的属性。v-bind:属性名=”属性值”，一般属性值在data里面进行定义。</p><p>10.v-for,生成列表。格式v-for=”item in items”，在data里面对items进行数据设置，一般是数组或者对象或者对象数组。使用对象时，可使用(value,key,index) in object 对对象进行数据访问。</p><p>11.v-model，获取和设置表单元素的值(进行双向数据绑定)。就是表单中的数据发生改变时，另一个绑定的数据元素也会发生改变。一般用来获取输入文本框中的输入数据.</p><p>12.网络请求(axios).一般使用get和post</p><p>例如：</p><pre class=" language-js"><code class="language-js">axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"https://autumnfish.cn/api/joke/list?num=1"</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">{</span>                        that<span class="token punctuation">.</span>joke<span class="token operator">=</span>response<span class="token punctuation">.</span>data<span class="token punctuation">.</span>jokes<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里不能通过this访问joke，this的范围已经发生了变化</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>data<span class="token punctuation">.</span>jokes<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猎奇作品(以后有新的会更新)</title>
      <link href="/2020/07/08/%E7%8C%8E%E5%A5%87%E4%BD%9C%E5%93%81/"/>
      <url>/2020/07/08/%E7%8C%8E%E5%A5%87%E4%BD%9C%E5%93%81/</url>
      
        <content type="html"><![CDATA[<h4 id="就是记录一下一些看过的猎奇作品"><a href="#就是记录一下一些看过的猎奇作品" class="headerlink" title="就是记录一下一些看过的猎奇作品"></a>就是记录一下一些看过的猎奇作品</h4><p>1.鱼毛骨悚然的蠕动</p><p>​        动漫观感一般，后遗感2小时以内，留的坑有些多，不讨论其内涵，就画面来说对于猎奇这点还是有一些诠释，就是有些地方密恐慎入。</p><p>2.芽衣恶虐，恶梦轮回</p><p>​        这两部作品着实有些血腥，生理性有些不适。都是漫画，大概50页左右，后遗感1小时左右吧，血腥，色情，生理性不适，<strong>慎看</strong> 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 猎奇,记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android room简单学习</title>
      <link href="/2020/07/07/android-room%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/07/android-room%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="room"><a href="#room" class="headerlink" title="room"></a>room</h3><p>1.要使用room需要先声明依赖，<a href="https://developer.android.google.cn/jetpack/androidx/releases/room#declaring_dependencies" target="_blank" rel="noopener">声明方法</a><br><strong>注意要在app模式下的build.gradle(module:app)里面添加依赖，不要在project里面的gradle里面添加。</strong></p><p>2.room由3个主要的组件，分别为<br>Database：数据库，<br>Entity：数据库中的表，<br>DAO：访问数据库的方法。</p><p>3.room可以使用一个Java类文件当做数据库的表，只需使用@Entity注解。<br>里面有几个主要的注解使用<br><strong>也可以在@Entity注解后面使用tablename声明表的名称</strong><br> <strong>@PrimaryKey(autoGenerate = true) // 设置主键，并且自动生长</strong><br> <strong>@ColumnInfo(name = “true_name”) // 设置别名，如果不设置就默认为变量名</strong><br> 在其中可以定义需要的变量且对其中每一个变量都需要写出其set方法和get方法。</p><p> 4.之后我们使用DAO来对数据库进行访问<br> 同样我们需要使用一个Java接口类文件，同时使用@DAO 注解<br> 其中里面有4个主要的注解进行使用<br> <strong>@Insert 表示插入记录。<br>@Update 表示修改数据库中的记录。<br>@Delete 表示删除数据库中记录。<br>@Query(“ “) 中可以写入SQL语句，来执行操作。</strong></p><p>5.创建一个Database，同样要使用@Database注解，且在其中需要指明entities和version<br><strong>Database 文件必须要继承 **androidx.room.RoomDatabase</strong>，并且得是抽象类。**</p><p>之后就是建立一个布局，将数据库里面的数据显示出来，并与DAO的几个操作通过点击进行交互。</p><p><a href="https://github.com/chengsong-hunnu/local-github/tree/master/room" target="_blank" rel="noopener">主要代码在这里</a></p><p>主要借鉴了<a href="https://blog.csdn.net/weixin_43734095/article/details/100182369?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">萌宅鹿</a>和<a href="https://developer.android.google.cn/training/data-storage/room" target="_blank" rel="noopener">android studio官方</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> csdn room </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp fork的一些代码运行和理解</title>
      <link href="/2020/07/07/csapp-fork%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%92%8C%E7%90%86%E8%A7%A3/"/>
      <url>/2020/07/07/csapp-fork%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%92%8C%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p><strong>1.</strong> 先说一点简单的fork定义<br>1.创建一个新进程，新进程被称为子进程。两者最大的区别在于pid不同，一般通过返回值分辨是哪个进程。<br>2.fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。<br>3.子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。各自都有自己的独立地址。<br>4.两者的执行顺序是随机并发执行的，也就是不能判断执行顺序。</p><p><strong>2</strong> 为什么fork会返回两次？<br>由于在复制时复制了父进程的堆栈段，所以两个进程都停留在fork函数中，等待返回。因此fork函数会返回两次，一次是在父进程中返回，另一次是在子进程中返回，这两次的返回值是不一样的，<strong>父进程返回子进程的pid，子进程返回0</strong><br><strong>3</strong>现在来看下一些代码吧：<br>1.</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fork1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child has x = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">++</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Parent has x = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">--</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Bye from process %d with x = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>结果：<img src="./images/loading.gif" data-original="https://img-blog.csdnimg.cn/2019110910200816.png" alt="在这里插入图片描述"><br>先fork一个子进程，这次子进程先执行，之后再试父进程，最后得到这个结果。</p><p>下面有一些关键字，<a href="https://blog.csdn.net/GEAUSE/article/details/102933742" target="_blank" rel="noopener">waitpid等</a>，可以去看一下。</p><p>2.下一个是关于僵尸进程的问题</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">fork7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Child */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Terminating Child, PID = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Running Parent, PID = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Infinite loop */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：<img src="./images/loading.gif" data-original="https://img-blog.csdnimg.cn/20191109103227316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>僵死进程</strong>：是指子进程退出时，父进程并未对其发出的SIGCHLD信号进行适当处理，导致子进程停留在僵死状态等待其父进程为其回收，这个状态下的子进程就是僵死进程。</p><p>主进程运行然后fork一个子进程，父进程因为while（1），一直在后台运行，但是子进程正常执行完程序。最后在后台卡住，使用Ctrl+z挂起这个程序，之后ps命令去看可看见这个程序的父进程（pid=4300）还是在后台挂起，只能用kill命令强制结束。</p><p><strong>3.</strong> 这个是关于孤儿进程</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">fork8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Child */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Running Child, PID = %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Infinite loop */</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Terminating Parent, PID = %d\n"</span><span class="token punctuation">,</span>                   <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：<br><img src="./images/loading.gif" data-original="https://img-blog.csdnimg.cn/20191109104910232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>孤儿进程</strong>：父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(pid=1)所收养，并由init进程对它们完成状态收集工作。</p><p>由ps命令可看见子进程（pid=4304）还在后台运行，这就是一个孤儿进程。</p><p><strong>4.</strong>关于wait</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> N 5</span><span class="token keyword">void</span> <span class="token function">fork10</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> child_status<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Child */</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Parent */</span>        pid_t wpid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>child_status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated with exit status %d\n"</span><span class="token punctuation">,</span>                   wpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">else</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminate abnormally\n"</span><span class="token punctuation">,</span> wpid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fork11</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> child_status<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Child */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> N<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pid_t wpid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>child_status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated with exit status %d\n"</span><span class="token punctuation">,</span>                   wpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">else</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminate abnormally\n"</span><span class="token punctuation">,</span> wpid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：<img src="./images/loading.gif" data-original="https://img-blog.csdnimg.cn/20191109113504188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于<strong>fork10</strong>，通过for循环先fork一个子进程，父进程进行到wait暂停，之后子进程运行exit正常退出，给出一个信号给父进程，然后根据wait的特点，父进程继续执行输出语句。</p><p>对于<strong>fork11</strong>，通过for循环先fork一个子进程，父进程进行到waitpid(pid[i],&amp;child_status, 0)暂停，之后waitpid等待着pid[i]的子进程结束，之后for（0-4）正常结束子进程，for（4-0）waitpid返回子进程结束值，之后执行输出语句。</p><p><strong>5</strong>关于信号</p><pre class=" language-c"><code class="language-c"> <span class="token operator">*</span><span class="token operator">/</span><span class="token keyword">void</span> <span class="token function">fork12</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> child_status<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Child: Infinite Loop */</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Killing process %d\n"</span><span class="token punctuation">,</span> pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">kill</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> SIGINT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//杀死此进程</span>        <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pid_t wpid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>child_status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated with exit status %d\n"</span><span class="token punctuation">,</span>wpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">else</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated abnormally\n"</span><span class="token punctuation">,</span> wpid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">*</span> fork12 <span class="token operator">-</span> Sending signals with the <span class="token function">kill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> function<span class="token punctuation">,</span>发送信号给前一个参数的进程 cheng@晟松<span class="token punctuation">:</span><span class="token operator">/</span>mnt<span class="token operator">/</span>d<span class="token operator">/</span>计算机基础代码测试<span class="token operator">/</span>chap8_code$ <span class="token punctuation">.</span><span class="token operator">/</span>forks <span class="token number">12</span>Killing process <span class="token number">34</span>Killing process <span class="token number">35</span>Killing process <span class="token number">36</span>Killing process <span class="token number">37</span>Killing process <span class="token number">38</span>Child <span class="token number">34</span> terminated abnormallyChild <span class="token number">35</span> terminated abnormallyChild <span class="token number">36</span> terminated abnormallyChild <span class="token number">37</span> terminated abnormallyChild <span class="token number">38</span> terminated abnormally <span class="token operator">*</span><span class="token operator">/</span></code></pre><p>kill（）函数就是给一个信号给进程。<a href="https://blog.csdn.net/qq_42152681/article/details/90261295" target="_blank" rel="noopener">参考kill()函数</a><br>此函数里面父进程被强制结束，子进程一直循环，结果子进程被系统自动回收，WIFEXITED()不能得到信号，最后显示出子进程被异常终止。</p>]]></content>
      
      
      
        <tags>
            
            <tag> csdn fork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的建立</title>
      <link href="/2020/07/07/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
      <url>/2020/07/07/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
      
        <content type="html"><![CDATA[<p>对这个博客，确实有很多的问题，自己都删了好几次文件，从新来搞，才搞成这样，可能还有一些的问题在里面，等后面发现了，就继续改进。现在就有一些问题就很烦，就是github.io过一段时间就不能进行访问了，相当于这个网页就没了，就是这个问题搞了好久，最后只能重新重头开始再搞一次。在网上也没找到什么解决办法，看后面怎么搞。下一个就是关于这个github和自己的域名的链接，上次一搞就崩了，希望这次不崩。</p><h4 id="首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。"><a href="#首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。" class="headerlink" title="首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。"></a>首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。</h4><p>1.<a href="https://yafine-blog.cn/posts/4ab2.html#1-%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B8%83%E5%88%B0Github-Pages" target="_blank" rel="noopener">过客～励む</a></p><p>2.<a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">遇见西门</a></p><p>3.<a href="https://space.bilibili.com/384068749/" target="_blank" rel="noopener">B站codesheep</a></p><h5 id="后面再说一下一些我碰见的问题和解决方法。"><a href="#后面再说一下一些我碰见的问题和解决方法。" class="headerlink" title="后面再说一下一些我碰见的问题和解决方法。"></a>后面再说一下一些我碰见的问题和解决方法。</h5><p>首先是域名的问题，这里参考遇见西门的博客的域名方法就行，记住不要直接在github建立CNAME文件，需要在本地建立CNAME文件，再上传，之后在github链接域名。</p><p>后面的一个问题是新建博客，使用的命令是<strong>hexo n “新建的博客名”</strong>,因为是md文件，所以需要你自己下一个md文件格式的编辑器，例如typora等，最后，你的文件写的时候，一般会添加tag，一定要tag:后面加一个空格，再加你的tag，不然会出现错误。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客建立 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
