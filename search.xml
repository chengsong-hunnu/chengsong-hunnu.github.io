<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js复习</title>
      <link href="/2020/08/25/js%E5%A4%8D%E4%B9%A0/"/>
      <url>/2020/08/25/js%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p> 之前对js只是在菜鸟上面简单的看了一遍，并没有进行一个熟练地使用，后面发现需要补一些基础原理方面的，特在这里对前面的js进行一个复习</p><h5 id="1-js组成"><a href="#1-js组成" class="headerlink" title="1.js组成"></a>1.js组成</h5><blockquote><p><strong>js = ECMAScript + DOM + BOM + 高级</strong></p></blockquote><p><strong>ECMAScript</strong>（前身为欧洲计算机制造商协会）：JavaScript的语法规范</p><p><strong>DOM</strong>（Document Object Model 的文档对象模型简称）：JavaScript操作网页上元素的API</p><p><strong>BOM</strong>（Browser Object Model 的浏览器对象模型简称）：JavaScript操作浏览器部分功能的API</p><h5 id="2-记录一些常用的方法"><a href="#2-记录一些常用的方法" class="headerlink" title="2.记录一些常用的方法"></a>2.记录一些常用的方法</h5><p>字符串：</p><table><thead><tr><th>名</th><th></th></tr></thead><tbody><tr><td>trim()</td><td>去除字符串的左右空格，不包括在中间的空格</td></tr><tr><td>indexOf()</td><td>返回一个字符在字符串的位置</td></tr><tr><td>split()</td><td>把字符串分割成字符串数组</td></tr><tr><td>slice()</td><td>得到一个字符串的一部分</td></tr></tbody></table><p>json：</p><table><thead><tr><th>名</th><th></th></tr></thead><tbody><tr><td>JSON.parse(string name)</td><td>json字符串转成js对象</td></tr><tr><td>JSON.stringify(json name)</td><td>js值(对象或数组)转成json字符串</td></tr></tbody></table><p>算了，用的时候还不如直接查参考手册</p><h5 id="3-js-promise"><a href="#3-js-promise" class="headerlink" title="3.js promise"></a>3.js promise</h5><p>之前一直听说promise，但不知道是何，现在才来进行一个理解。</p><p>promise是es6新增的一个类，专门为了简单化异步编程而进行。避免了层层的回调函数，将回调函数转换成一条执行链。</p><p>Promise 构造函数只有一个参数，是一个函数，这个函数在构造之后会直接被异步运行，所以我们称之为起始函数。起始函数包含两个参数 <strong>resolve 和 reject</strong>。resolve表示函数正常运行，reject表示出现错误时运行</p><p><strong>在初始化Promise实例对象的时候，Promise的状态为pending；在调用resolve回调函数的时候，Promise的状态为fullfilled，表示成功状态；在调用reject回调函数的时候，Promise的状态为rejected，表示失败状态；</strong></p><p>Promise 类有 .then() .catch() 和 .finally() 三个方法，这三个方法的参数都是一个函数，<strong>.then()</strong> 可以将参数中的函数添加到当前 Promise 的正常执行序列，.catch() 则是设定 Promise 的异常处理序列，.finally() 是在 Promise 执行的最后一定会执行的序列。 .then() 传入的函数会按顺序依次执行，有任何异常都会直接跳到 catch 序列。</p><p>如果 then 中返回的是一个 Promise 对象，那么<strong>下一个 then</strong> 将相当于对这个返回的 Promise 进行操作</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 执行异步操作</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 执行异步操作成功,此时修改promise的状态fullfilled</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"success!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 执行异步操作成功,此时修改promise的状态rejected</span>    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">"failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// promise的状态fullfilled的操作</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"成功"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// promise的状态rejected的操作</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"失败"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//111 222 成功 success</span></code></pre><p>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。<strong>resolve或reject总是在本轮事件循环的末尾执行</strong>，所以最后才打印success。当调用resolve()函数将promise状态改变成fullfilled时，后面的reject()就不会执行</p><hr><p><strong>重点异步函数</strong>：async 和 await。方便，简洁.但await 指令后必须跟着一个 Promise，异步函数会在这个 Promise 运行中暂停，直到其运行结束再继续运行。</p><p>例：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">"First"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">await</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">4000</span><span class="token punctuation">,</span> <span class="token string">"Second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">await</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token string">"Third"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="4-DOM文档对象模型"><a href="#4-DOM文档对象模型" class="headerlink" title="4.DOM文档对象模型"></a>4.DOM文档对象模型</h5><p>通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素。</p><p>改变 <strong>HTML</strong> 元素的属性，请使用这个语法：</p><p>document.getElementById(<em>id</em>).<em>attribute=新属性值</em></p><hr><p>改变 HTML 元素的<strong>样式</strong>，请使用这个语法：</p><p>document.getElementById(<em>id</em>).style.<em>property</em>=<em>新样式</em></p><hr><p>添加<strong>监听</strong>事件。addEventListener() 方法允许向同一个元素添加多个事件，且不会覆盖已存在的事件。不论是同一种类型，还是不同的类型</p><p><em>element</em>.addEventListener(<em>event, function, useCapture</em>);</p><p>第一个参数是事件的类型 (如 “click” 或 “mousedown”).</p><p>第二个参数是事件触发后调用的函数。</p><p>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。</p><hr><p><strong>冒泡，捕获</strong>定义了事件触发的顺序</p><p>在 <em>冒泡</em> 中，<strong>内部</strong>元素的事件会先被触发，然后再触发外部元素</p><p>在 <em>捕获</em> 中，<strong>外部</strong>元素的事件会先被触发，然后才会触发内部元素的事件</p><h5 id="5-BOM浏览器对象模型"><a href="#5-BOM浏览器对象模型" class="headerlink" title="5.BOM浏览器对象模型"></a>5.BOM浏览器对象模型</h5><p>所有 JavaScript 全局对象、函数以及变量均自动成为 <strong>window 对象</strong>的成员。</p><p>window的常用方法：</p><ul><li>window.innerHeight - 浏览器窗口的内部高度(包括滚动条)</li><li>window.innerWidth - 浏览器窗口的内部宽度(包括滚动条)</li><li>window.open() - 打开新窗口</li><li>window.close() - 关闭当前窗口</li><li>window.moveTo() - 移动当前窗口</li><li>window.resizeTo() - 调整当前窗口的尺寸</li></ul><hr><p>window.<strong>location</strong> 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。使用时可省略window。</p><ul><li>location.href 属性返回当前页面的 URL。// <a href="https://www.runoob.com/js/js-window-location.html" target="_blank" rel="noopener">https://www.runoob.com/js/js-window-location.html</a></li><li>location.pathname 属性返回 URL 的路径名。 // /js/js-window-location.html</li><li>location.assign() 方法加载新的文档，打开新的网页。// window.location.assign(“<a href="https://www.runoob.com&quot;" target="_blank" rel="noopener">https://www.runoob.com&quot;</a>)</li></ul><hr><ul><li>history.back() - 与在浏览器点击后退按钮相同</li><li>history.forward() - 与在浏览器中点击向前按钮相同</li></ul><hr><p><strong>计时事件</strong></p><ul><li>setInterval(fucntion,time) - 间隔指定的毫秒数不停地执行指定的代码。</li><li>setTimeout(function,time) - 在指定的毫秒数后执行指定代码。</li><li>clearInterval() 方法用于停止 setInterval() 方法执行的函数代码。</li><li>clearTimeout() 方法用于停止执行setTimeout()方法的函数代码。</li></ul><hr><p><strong>cookie</strong></p><p>Cookie 的作用就是用于解决 “如何记录客户端的用户信息”.当用户访问 web 页面时，他的名字可以记录在 cookie 中.下一次访问就可以通过cookie读取用户访问记录。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//创建 cookie 如下所示：</span>document<span class="token punctuation">.</span>cookie<span class="token operator">=</span><span class="token string">"username=John Doe"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//读取 cookie：</span><span class="token keyword">var</span> x <span class="token operator">=</span> document<span class="token punctuation">.</span>cookie<span class="token punctuation">;</span></code></pre><h5 id="6-this"><a href="#6-this" class="headerlink" title="6.this"></a>6.this</h5><p>根据函数的调用方式的不同，this会指向不同的对象：【重要】</p><ul><li>1.以函数的形式调用时，this永远都是window。比如<code>fun();</code>相当于<code>window.fun();</code></li><li>2.以方法的形式调用时，this是调用方法的那个对象</li><li>3.以构造函数的形式调用时，this是新创建的那个对象</li><li>4.使用call和apply调用时，this是指定的那个对象</li></ul><h5 id="7-原型对象-原型链"><a href="#7-原型对象-原型链" class="headerlink" title="7.原型对象(原型链)"></a>7.原型对象(原型链)</h5><p><a href="http://www.cpengx.cn/p/357.html" target="_blank" rel="noopener">具体细节查看</a></p><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><p>我们所创建的每一个函数，解析器都会向函数中添加一个属性 prototype。这个属性对应着一个对象，这个对象就是我们所谓的原型对象。每个原型都有一个 constructor 属性指向关联的构造函数 实例原型指向构造函数</p><p>当函数以<strong>构造函数</strong>的形式调用时，它所创建的实例对象中都会有一个隐含的属性，指向该构造函数的原型，我们可以通过<strong>proto</strong>来访问该属性</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 定义构造函数</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> per1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> per2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 打印结果：[object object]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>per1<span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//注意后面是构造函数的prototype，前面为实例的__proti__</span><span class="token comment" spellcheck="true">// 打印结果：true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Person <span class="token operator">===</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p><code>实例.__proto__</code> 和 <code>构造函数.prototype</code>都指的是原型对象。</p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/1490251-e7476a8697e97aab.png?imageMogr2/auto-orient/strip|imageView2/2/w/567/format/webp" alt="图解" style="zoom:80%;" /><p>原型对象就相当于一个<strong>公共</strong>的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p><h6 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h6><p>原型对象也是对象，所以它也有原型，当我们使用或访问一个对象的属性或方法时：</p><ul><li>它会先在对象自身中寻找，如果有则直接使用；</li><li>如果没有则会去原型对象中寻找，如果找到则直接使用；</li><li>如果没有则去原型的原型中寻找，直到找到Object对象的原型。</li><li>Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回 null</li></ul><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/1490251-3089c135df71c956.png?imageMogr2/auto-orient/strip|imageView2/2/w/604/format/webp" alt="原型链" style="zoom:60%;" />]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则入门笔记</title>
      <link href="/2020/08/24/%E6%AD%A3%E5%88%99%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/24/%E6%AD%A3%E5%88%99%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>大概就是网上的30分钟入门正则表达的一个个人总结。<a href="https://www.runoob.com/w3cnote/regular-expression-30-minutes-tutorial.html" target="_blank" rel="noopener">链接</a></p><p>不过就只是进行一个简单的学习和简单实用。<a href="https://blog.csdn.net/ZYC88888/article/details/98479629" target="_blank" rel="noopener">一些方便常用的正则早有人进行了总结</a></p><h5 id="1-元字符"><a href="#1-元字符" class="headerlink" title="1.元字符"></a>1.元字符</h5><p>(\b)，代表单词的开头或者结尾，并不匹配任何字符，只表明是匹配这个位置。</p><p>(.)元字符，匹配除了换行符以外的任意字符。(*)同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定(*)前边的内容可以连续重复使用任意次(可以是0次)以使整个表达式得到匹配。因此，(.*)连在一起就意味着任意数量的不包含换行的字符。如果是(+),这表示至少匹配一次或更多次</p><table><thead><tr><th align="left">代码</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">.</td><td align="left">匹配除换行符以外的任意字符</td></tr><tr><td align="left">\w</td><td align="left">匹配字母或数字或下划线或汉字</td></tr><tr><td align="left">\s</td><td align="left">匹配任意的空白符</td></tr><tr><td align="left">\d</td><td align="left">匹配数字</td></tr><tr><td align="left">\b</td><td align="left">匹配单词的开始或结束</td></tr><tr><td align="left">^</td><td align="left">匹配字符串的开始</td></tr><tr><td align="left">$</td><td align="left">匹配字符串的结束</td></tr></tbody></table><h5 id="2-匹配重复"><a href="#2-匹配重复" class="headerlink" title="2.匹配重复"></a>2.匹配重复</h5><p>就是进行多少次重复的匹配。一般是为了减少正则表达式的长度。</p><table><thead><tr><th align="left">代码/语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">重复零次或更多次</td></tr><tr><td align="left">+</td><td align="left">重复一次或更多次</td></tr><tr><td align="left">?</td><td align="left">重复零次或一次</td></tr><tr><td align="left">{n}</td><td align="left">重复n次</td></tr><tr><td align="left">{n,}</td><td align="left">重复n次或更多次</td></tr><tr><td align="left">{n,m}</td><td align="left">重复n到m次</td></tr></tbody></table><p>例：^\w+匹配一行的第一个单词或整个字符串的第一个单词</p><h5 id="3-字符类"><a href="#3-字符类" class="headerlink" title="3.字符类"></a>3.字符类</h5><p>为了解决一些特定的字符没有专门的匹配元字符，使用<strong>[]</strong>方括号包含这些特殊字符就行。</p><p>例：[.?!]匹配标点符号(.或?或!)。[0-9]代表的含意与\d就是完全一致的</p><p>\(?0\d{2}[) -]?\d{8}  首先是一个转义字符(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字(\d{2})，然后是)或-或空格中的一个(方括号中间有一个<strong>空格</strong>)，它出现1次或不出现(?)，最后是8个数字(\d{8})。匹配例如(010)88886666，或022-22334455，或02912345678。</p><h5 id="4-分枝条件"><a href="#4-分枝条件" class="headerlink" title="4.分枝条件"></a>4.分枝条件</h5><p><strong>|</strong>，就是当成多个匹配式进行匹配。</p><p>例：0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。但要注意顺序，从左往右进行匹配，当匹配成功之后，后面的就不会再进行匹配了，有时候会出现一些奇怪的问题</p><h5 id="5-分组"><a href="#5-分组" class="headerlink" title="5.分组"></a>5.分组</h5><p>重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号<strong>()</strong>来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了</p><h5 id="6-反义"><a href="#6-反义" class="headerlink" title="6.反义"></a>6.反义</h5><p>查找不属于某个能简单定义的字符类的字符</p><table><thead><tr><th align="left">代码/语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">\W</td><td align="left">匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td align="left">\S</td><td align="left">匹配任意不是空白符的字符</td></tr><tr><td align="left">\D</td><td align="left">匹配任意非数字的字符</td></tr><tr><td align="left">\B</td><td align="left">匹配不是单词开头或结束的位置</td></tr><tr><td align="left">[^x]</td><td align="left">匹配除了x以外的任意字符</td></tr><tr><td align="left">[^aeiou]</td><td align="left">匹配除了aeiou这几个字母以外的任意字符</td></tr></tbody></table><p>例：\S+匹配不包含空白符的字符串。&lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串。</p><h5 id="7-后向引用"><a href="#7-后向引用" class="headerlink" title="7.后向引用"></a>7.后向引用</h5><p>大概就是在后面的正则使用前面的正则匹配出来的分组结果。具体查看文章开头链接</p><table><thead><tr><th align="left">分类</th><th align="left">代码/语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">捕获</td><td align="left">(exp)</td><td align="left">匹配exp,并捕获文本到自动命名的组里。exp为表达式</td></tr><tr><td align="left">(?<name>exp)</td><td align="left">匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td><td align="left"></td></tr><tr><td align="left">(?:exp)</td><td align="left">匹配exp,不捕获匹配的文本，也不给此分组分配组号</td><td align="left"></td></tr><tr><td align="left">零宽断言</td><td align="left">(?=exp)</td><td align="left">匹配exp前面的位置</td></tr><tr><td align="left">(?&lt;=exp)</td><td align="left">匹配exp后面的位置</td><td align="left"></td></tr><tr><td align="left">(?!exp)</td><td align="left">匹配后面跟的不是exp的位置</td><td align="left"></td></tr><tr><td align="left">(?&lt;!exp)</td><td align="left">匹配前面不是exp的位置</td><td align="left"></td></tr><tr><td align="left">注释</td><td align="left">(?#comment)</td><td align="left">这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td></tr></tbody></table><p>例：\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)</p><h5 id="8-零宽断言"><a href="#8-零宽断言" class="headerlink" title="8.零宽断言"></a>8.零宽断言</h5><p>断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。</p><p>例：(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。</p><p>(?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。</p><p>同理也有负向零宽断言</p><p>例：零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。</p><p>同理，我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字</p><h5 id="9-注释"><a href="#9-注释" class="headerlink" title="9.注释"></a>9.注释</h5><p>小括号通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25<a href="?#250-255">0-5</a>|[01]?\d\d?(?#0-199)</p><h5 id="10-贪婪匹配和懒惰匹配"><a href="#10-贪婪匹配和懒惰匹配" class="headerlink" title="10.贪婪匹配和懒惰匹配"></a>10.贪婪匹配和懒惰匹配</h5><p>就是在匹配的时候，其结果是匹配竟可能长的字符串，还是竟可能短短的字符串</p><table><thead><tr><th align="left">代码/语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">*?</td><td align="left">重复任意次，但尽可能少重复</td></tr><tr><td align="left">+?</td><td align="left">重复1次或更多次，但尽可能少重复</td></tr><tr><td align="left">??</td><td align="left">重复0次或1次，但尽可能少重复</td></tr><tr><td align="left">{n,m}?</td><td align="left">重复n到m次，但尽可能少重复</td></tr><tr><td align="left">{n,}?</td><td align="left">重复n次以上，但尽可能少重复</td></tr></tbody></table><p>例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。</p><p>a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）</p><h4 id="特别"><a href="#特别" class="headerlink" title="特别"></a>特别</h4><p>在js里面的正则似乎跟前面的正则有些不同</p><p>其语法为：</p><pre class=" language-js"><code class="language-js"><span class="token operator">/</span>正则表达式主体<span class="token operator">/</span><span class="token function">修饰符</span><span class="token punctuation">(</span>可选<span class="token punctuation">)</span>例：<span class="token keyword">var</span> patt <span class="token operator">=</span> <span class="token regex">/^\d+\.\d+$/g</span>  <span class="token comment" spellcheck="true">//匹配是否带有小数</span></code></pre><table><thead><tr><th align="left">修饰符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">执行对大小写不敏感的匹配。</td></tr><tr><td align="left">g</td><td align="left">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td align="left">m</td><td align="left">执行多行匹配。</td></tr></tbody></table><h5 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h5><p>方括号用于查找某个范围内的字符：</p><table><thead><tr><th align="left">表达式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[abc]</td><td align="left">查找方括号之间的任何字符。</td></tr><tr><td align="left">[0-9]</td><td align="left">查找任何从 0 至 9 的数字。</td></tr><tr><td align="left">(x|y)</td><td align="left">查找任何以 | 分隔的选项。</td></tr></tbody></table><p>元字符是拥有特殊含义的字符：</p><table><thead><tr><th align="left">元字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\d</td><td align="left">查找数字。</td></tr><tr><td align="left">\s</td><td align="left">查找空白字符。</td></tr><tr><td align="left">\b</td><td align="left">匹配单词边界。</td></tr><tr><td align="left">\uxxxx</td><td align="left">查找以十六进制数 xxxx 规定的 Unicode 字符。</td></tr></tbody></table><p>量词:</p><table><thead><tr><th align="left">量词</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">n+</td><td align="left">匹配任何包含至少一个 <em>n</em> 的字符串。</td></tr><tr><td align="left">n*</td><td align="left">匹配任何包含零个或多个 <em>n</em> 的字符串。</td></tr><tr><td align="left">n?</td><td align="left">匹配任何包含零个或一个 <em>n</em> 的字符串。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> regexp 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue企业项目细节</title>
      <link href="/2020/08/22/vue%E4%BC%81%E4%B8%9A%E9%A1%B9%E7%9B%AE%E7%BB%86%E8%8A%82/"/>
      <url>/2020/08/22/vue%E4%BC%81%E4%B8%9A%E9%A1%B9%E7%9B%AE%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>大概就是对B站老陈的一个vue企业项目视频的细节抄写</p><h5 id="1-axios封装和请求响应劫持"><a href="#1-axios封装和请求响应劫持" class="headerlink" title="1.axios封装和请求响应劫持"></a>1.axios封装和请求响应劫持</h5><p>对将后端传回的数据，前端需要自己对数据进行一个拦截检查，看数据是否正确。</p><pre class=" language-js"><code class="language-js"><span class="token function">interceptors</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span>url<span class="token punctuation">)</span><span class="token punctuation">{</span>        instance<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//处理config</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'拦截和处理请求'</span><span class="token punctuation">)</span>            config<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">{</span>                msg<span class="token punctuation">:</span><span class="token string">"helloworld"</span>            <span class="token punctuation">}</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span>            <span class="token keyword">return</span> config        <span class="token punctuation">}</span><span class="token punctuation">)</span>        instance<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//处理响应</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"处理响应"</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//console.log(res)</span>            <span class="token keyword">return</span> res<span class="token punctuation">.</span>data        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//请求出问题，处理问题</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span>error<span class="token punctuation">:</span><span class="token string">"网络出错了"</span><span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span></code></pre><p>跨域的处理，一般是在后端设置一个中间件，允许进行跨域请求</p><pre class=" language-js"><code class="language-js"> app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span>res<span class="token punctuation">,</span>next<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">,</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-headers'</span><span class="token punctuation">,</span><span class="token string">"*"</span><span class="token punctuation">)</span>    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>或者设置一个代理服务，使用8080的本地端口作为代理去进行后端数据请求，之后再通过8080端口将数据返回。</p><p>设置代理服务器，使用vue-cli的自带配置vue.config.js。在vue-cli官网配置指南里面有专门的文档</p><pre class=" language-js"><code class="language-js">devServer<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//设置代理服务器跨域请求</span>        proxy<span class="token punctuation">:</span><span class="token punctuation">{</span>            <span class="token string">'/api'</span><span class="token punctuation">:</span><span class="token punctuation">{</span>                target<span class="token punctuation">:</span><span class="token string">"http://localhost:3000"</span><span class="token punctuation">,</span>                pathRewrite<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//重写访问路径</span>                    <span class="token string">'^/api'</span><span class="token punctuation">:</span><span class="token string">""</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h5 id="2-mock-js模拟后端数据"><a href="#2-mock-js模拟后端数据" class="headerlink" title="2.mock.js模拟后端数据"></a>2.mock.js模拟后端数据</h5><p>通过劫持axios请求，将数据返回。路径可使用正则表达式</p><p>首先需要在main.js里面进行引入，如果是在开发模式。需要npm安装。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> Mock <span class="token keyword">from</span> <span class="token string">'mockjs'</span><span class="token punctuation">;</span>Mock<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token string">'/api/posi'</span><span class="token punctuation">,</span>position<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//position和index_entry是数据。需要export dedfault导出</span>Mock<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token string">'/api/index_entry'</span><span class="token punctuation">,</span>index_entry<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//或者</span>Mock<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token string">'/api/user'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>    username<span class="token punctuation">:</span><span class="token string">"老陈"</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">,</span>    gender<span class="token punctuation">:</span><span class="token string">"男"</span><span class="token punctuation">,</span>    type<span class="token punctuation">:</span><span class="token string">"帅"</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>特别的重点是mock可进行随机数据生成，不用自己去想这些随机数据</p><pre class=" language-js"><code class="language-js"><span class="token string">'name|min-max'</span><span class="token punctuation">:</span> stringMock<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token string">"string|1-10"</span><span class="token punctuation">:</span> <span class="token string">"★"</span><span class="token comment" spellcheck="true">//结果为1-10颗★</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token string">'name|min-max'</span><span class="token punctuation">:</span> numberMock<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token string">"number|1-100"</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token comment" spellcheck="true">//结果为1-100里的一个数字</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><a href="http://mockjs.com/examples.html#Image" target="_blank" rel="noopener">具体详细操作查看官方文档</a></p><h5 id="3-布局"><a href="#3-布局" class="headerlink" title="3.布局"></a>3.布局</h5><p>对于一个项目来说，需要响应式的进行布局，可以在任何常用设备上的布局比例不变，一般使用响应式进行操作布局。此项目使用rem布局，大概就是可根据屏幕的大小进行字体的大小调整。</p><p>相当于先确定一个px大小，例如100px为一个标准1rem。后面都通过这个标准1rem进行调整大小。</p><h5 id="4-图标使用"><a href="#4-图标使用" class="headerlink" title="4.图标使用"></a>4.图标使用</h5><p>一般可在iconfont里面找到想要的图标并添加进购物车，选择fontclass方式进行下载到本地，之后里面会有一个html文件教你怎么进行使用，一般是将图标文件放入到项目里的public文件夹里面的一个样式文件夹。之后在public里面的index.html里面进行css文件引入。</p><p><img src="/images/loading.gif" data-original="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200823102646390.png" alt="image-20200823102646390"></p><h5 id="5-组件"><a href="#5-组件" class="headerlink" title="5.组件"></a>5.组件</h5><p>全部导入一般是用在开发环境之下，真正的使用都是按需使用，具体查看官方文档</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//全部导入</span><span class="token comment" spellcheck="true">//main.js</span><span class="token keyword">import</span> Vant <span class="token keyword">from</span> <span class="token string">'vant'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">'vant/lib/index.css'</span><span class="token punctuation">;</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vant<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//xxx.vue</span><span class="token keyword">import</span> Button <span class="token keyword">from</span> <span class="token string">'vant/lib/button'</span><span class="token punctuation">;</span>components<span class="token punctuation">:</span> <span class="token punctuation">{</span>Button<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//需要注册</span></code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//按需导入，需要npm安装一个babel-plugin-import插件，并在babel.config.js里面进行一些修改，具体查看官方文档</span><span class="token comment" spellcheck="true">//xxx.vue</span><span class="token keyword">import</span> <span class="token punctuation">{</span> NavBar<span class="token punctuation">,</span>Icon <span class="token punctuation">,</span>Swipe<span class="token punctuation">,</span> SwipeItem<span class="token punctuation">,</span>Grid<span class="token punctuation">,</span> GridItem<span class="token punctuation">,</span>Image <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vant'</span><span class="token punctuation">;</span>components<span class="token punctuation">:</span> <span class="token punctuation">{</span>NavBar<span class="token punctuation">,</span>Icon <span class="token punctuation">,</span>Swipe<span class="token punctuation">,</span> SwipeItem<span class="token punctuation">,</span>Grid<span class="token punctuation">,</span> GridItem<span class="token punctuation">,</span>Image <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//依旧需要注册</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node.js学习</title>
      <link href="/2020/08/04/node-js%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/08/04/node-js%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>多个地方的node学习，<a href="https://www.runoob.com/nodejs/nodejs-http-server.html" target="_blank" rel="noopener">包括菜鸟教程</a>，B站，<a href="http://www.cpengx.cn/p/386.html" target="_blank" rel="noopener">老陈这些</a>。</p><p>1.介绍</p><p>主要用于编写服务端程序，类似于javaweb里面的jsp这些。</p><p><strong>二、Node.js与javaScript</strong></p><table><thead><tr><th align="left">javaScript</th><th align="left">Node.js</th></tr></thead><tbody><tr><td align="left">客户端技术，运行于浏览器中</td><td align="left">服务器端技术 ，与php,jsp等是类似的技术</td></tr><tr><td align="left">有多种解释器可以使用，如IE的Chakra,FF的猴子系列，Chrome的V8等等</td><td align="left">只能运行于基于V8引擎改进而来的运行时环境</td></tr><tr><td align="left">因为解释器有多种，所以存在代码兼容性问题</td><td align="left">只有一种解释器，所以不存在代码兼容性问题</td></tr><tr><td align="left">支持ES对象，自定义对象，BOM&amp;DOM对象</td><td align="left">支持ES对象，自定义对象，Node.js扩展对象（大量）</td></tr><tr><td align="left">主要用于网页DOM元素的操作，实现用户交互效果</td><td align="left">主要用于实现服务器端运行逻辑，如文件系统操作，数据库访问，其他服务器调用等</td></tr></tbody></table><p>3.Node.js 应用是由哪几部分组成的：</p><ol><li><p><strong>引入 required 模块：</strong>我们可以使用 <strong>require</strong> 指令来载入 Node.js 模块。当需要导入一个文件，在被导入的文件里需要通过module.exports导出</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//http是内置的模块</span><span class="token keyword">let</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./fs.js"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//导入一个fs.js文件</span></code></pre></li><li><p><strong>创建服务器：</strong>服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。</p><pre class=" language-js"><code class="language-js">http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 发送 HTTP 头部 </span>    <span class="token comment" spellcheck="true">// HTTP 状态值: 200 : OK</span>    <span class="token comment" spellcheck="true">// 内容类型: text/plain</span>    response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'Content-Type'</span><span class="token punctuation">:</span> <span class="token string">'text/plain'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 发送响应数据 "Hello World"</span>    response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Hello World\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//端口号</span></code></pre></li><li><p><strong>接收请求与响应请求</strong> 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。</p></li></ol><p>4.NPM</p><p>是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题</p><p>​    1.使用npm安装模块</p><pre class=" language-powershell"><code class="language-powershell">$ npm install &lt;Module Name><span class="token keyword">var</span> express = require<span class="token punctuation">(</span><span class="token string">'modele name'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span>使用require引用</code></pre><pre class=" language-powershell"><code class="language-powershell">npm install express          <span class="token comment" spellcheck="true"># 本地安装</span>npm install express <span class="token operator">-</span>g   <span class="token comment" spellcheck="true"># 全局安装</span></code></pre><h6 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h6><ul><li>\1. 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li><li>\2. 可以通过 require() 来引入本地安装的包。</li></ul><h6 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h6><ul><li>\1. 将安装包放在 /usr/local 下或者你 node 的安装目录。</li><li>\2. 可以直接在命令行里使用</li></ul><p>2.packag.json</p><p>package.json 位于模块的目录下，用于定义包的属性。位于 node_modules/modules name/package.json </p><p>在里面的最直观的是<strong>dependencies</strong> - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</p><p>5.回调函数，为了提高并发请求的处理，可不阻塞的执行代码</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"fs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'input.txt'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"程序执行结束!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//结果</span>$ node main<span class="token punctuation">.</span>js程序执行结束<span class="token operator">!</span>菜鸟教程官网地址：www<span class="token punctuation">.</span>runoob<span class="token punctuation">.</span>com</code></pre><p>6.EventEmitter</p><p>一个对事件的处理函数，类似于之前的sokect</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 引入 events 模块</span><span class="token keyword">var</span> events <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'events'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建 eventEmitter 对象</span><span class="token keyword">var</span> EventEmitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">events<span class="token punctuation">.</span>EventEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> event<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span>arg2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//监听事件</span>event<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'arg1'</span><span class="token punctuation">,</span><span class="token string">'arg2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//触发事件,可带参数</span></code></pre><p>7.buffer缓冲区</p><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在<strong>处理像TCP流或文件流</strong>时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。有自己的特定编码</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 创建一个长度为 10、且用 0 填充的 Buffer。</span><span class="token keyword">const</span> buf <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>、<span class="token comment" spellcheck="true">//写入缓冲区,如果 buffer 空间不足， 则只会写入部分字符串</span>len <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"www.runoob.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"写入字节数 : "</span><span class="token operator">+</span>  len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 写入字节数：14</span><span class="token comment" spellcheck="true">//从缓冲区读数据</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string">'ascii'</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//使用 'ascii' 编码, 并输出: www.r，后面两个参数为起始位置和结束位置</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用 'utf8' 编码, 并输出: www.r</span><span class="token comment" spellcheck="true">//将buffer转换为json,当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该 toJSON()。返回json对象</span><span class="token keyword">const</span> json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>后面还有一些方法，在<a href="https://www.runoob.com/nodejs/nodejs-buffer.html" target="_blank" rel="noopener">菜鸟</a>那里需要的时候看吧。</p><p>8.stream</p><p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）</p><p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p><ul><li><strong>data</strong> - 当有数据可读时触发。</li><li><strong>end</strong> - 没有更多的数据可读时触发。</li><li><strong>error</strong> - 在接收和写入过程中发生错误时触发。</li><li><strong>finish</strong> - 所有数据已被写入到底层系统时触发。</li></ul><p><a href="https://www.runoob.com/nodejs/nodejs-stream.html" target="_blank" rel="noopener">具体看菜鸟</a></p><p>9.模块化</p><p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。</p><p>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">var</span> name<span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>setName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>thyName<span class="token punctuation">)</span> <span class="token punctuation">{</span>         name <span class="token operator">=</span> thyName<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>sayHello <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello '</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Hello<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//进行导出</span><span class="token keyword">var</span> Hello <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//进行引入 </span>hello <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> hello<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">'BYVoid'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> hello<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>10.函数</p><p>一个函数可以作为另一个函数的参数,也可以在传递参数的地方直接定义函数.</p><p>11.路由</p><p>结合之下vue的路由来看基本没太大的变化，更多的是多了些关于相对底层的原理实现。</p><p><strong>setTimeout(cb, ms)</strong> 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。</p><p><strong>setInterval(cb, ms)</strong> 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。</p><p>12.node常用工具<strong>util</strong> </p><p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心 JavaScript 的功能 过于精简的不足。</p><p>使用方法如下：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> util <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'util'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a href="https://www.runoob.com/nodejs/nodejs-util.html" target="_blank" rel="noopener">具体函数看菜鸟</a></p><p>13.文件系统</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"fs"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//fileSystem</span></code></pre><h6 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h6><p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。</p><p>异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。建议使用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。就是可以直接执行读写文件后面的代码指令，而不需要等待文件读写完成。</p><pre class=" language-js"><code class="language-js">fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'input.txt'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//回调错误函数</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"异步读取: "</span> <span class="token operator">+</span> data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同步读取，主要看那sync</span><span class="token keyword">var</span> data <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'input.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="打开文件等"><a href="#打开文件等" class="headerlink" title="打开文件等"></a>打开文件等</h6><pre class=" language-js"><code class="language-js">fs<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> flags<span class="token punctuation">[</span><span class="token punctuation">,</span> mode<span class="token punctuation">]</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//flags为文件打开行为</span>fs<span class="token punctuation">.</span><span class="token function">stat</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取文件信息，会将stats类的实例返回给其回调函数。可以通过stats类中的提供方法判断文件的相关属性</span>fs<span class="token punctuation">.</span><span class="token function">stat</span><span class="token punctuation">(</span><span class="token string">'/Users/liuht/code/itbilu/demo/fs.js'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> stats<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//类似如此</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stats<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//true</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><a href="https://www.runoob.com/nodejs/nodejs-fs.html" target="_blank" rel="noopener">具体参数参考菜鸟</a></p><h6 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h6><pre class=" language-java"><code class="language-java">fs<span class="token punctuation">.</span><span class="token function">writeFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> data<span class="token punctuation">[</span><span class="token punctuation">,</span> options<span class="token punctuation">]</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span></code></pre><ul><li><strong>file</strong> - 文件名或文件描述符。</li><li><strong>data</strong> - 要写入文件的数据，可以是 String(字符串) 或 Buffer(缓冲) 对象。</li><li><strong>options</strong> - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’,该方法写入的内容会覆盖旧的文件内容。</li><li><strong>callback</strong> - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。</li></ul><h6 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h6><pre><code>fs.read(fd, buffer, offset, length, position, callback);//示例var buf = new Buffer.alloc(1024);fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){      if (err){         console.log(err);      }      console.log(bytes + &quot;  字节被读取&quot;);      // 仅输出读取的字节      if(bytes &gt; 0){         console.log(buf.slice(0, bytes).toString());      }   });</code></pre><ul><li><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</li><li><strong>buffer</strong> - 数据写入的缓冲区。</li><li><strong>offset</strong> - 缓冲区写入的写入偏移量。</li><li><strong>length</strong> - 要从文件中读取的字节数。</li><li><strong>position</strong> - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。</li><li><strong>callback</strong> - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript学习</title>
      <link href="/2020/07/29/typescript%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/29/typescript%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>typescript学习,下面简称ts.有些语法类似于java</p><p>typescript是js的一个超集，添加了一些新的扩展.主要目的是为了开发大型应用。</p><ul><li>类型批注和编译时类型检查</li><li>类型推断</li><li>类型擦除</li><li>接口</li><li>枚举</li><li>Mixin</li><li>泛型编程</li><li>名字空间</li><li>元组</li><li>Await</li></ul><p>2.使用<strong>npm install -g typescript</strong>安装进行使用，<strong>tsc</strong>是使用的标识，<strong>.ts</strong>是typescript文件扩展名。执行以下命令将 TypeScript 转换为 JavaScript 代码：</p><pre class=" language-powershell"><code class="language-powershell">tsc test<span class="token punctuation">.</span>ts</code></pre><p>3.TypeScript 程序由以下几个部分组成：</p><ul><li>模块</li><li>函数</li><li>变量</li><li>语句和表达式</li><li>注释</li></ul><p>每一行指令都是一段语句，可使用分号进行语句隔开，使合理。</p><p>4.TypeScript 面向对象编程实例：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Site</span> <span class="token punctuation">{</span>    <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">void</span> <span class="token punctuation">{</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Runoob"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Site</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> obj<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 函数定义</span><span class="token keyword">function</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>string <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 返回一个字符串，需要写明返回类型</span>    <span class="token keyword">return</span> <span class="token string">"Hello World"</span> <span class="token punctuation">}</span> </code></pre><p>编译后生成的 JavaScript 代码如下：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> Site <span class="token operator">=</span> <span class="token comment" spellcheck="true">/** @class */</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">Site</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    Site<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Runoob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Site<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Site</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>ts有些特殊的变量类型，如<strong>any</strong>，一般用于用户的输入，定义存储各种类型的数组。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> arrayList<span class="token punctuation">:</span> any<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">'fine'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ts的变量声明格式</span><span class="token keyword">let</span> myts<span class="token punctuation">:</span> number <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">var</span> uname<span class="token punctuation">:</span>string <span class="token operator">=</span> <span class="token string">"Runoob"</span><span class="token punctuation">;</span> arrayList<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></code></pre><p>ts里定义函数的参数可设置可选(通过?)，在参数后面需要指明参数类型。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">buildName</span><span class="token punctuation">(</span>firstName<span class="token punctuation">:</span> string <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">,</span> lastName<span class="token operator">?</span><span class="token punctuation">:</span> string<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//可设置默认值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lastName<span class="token punctuation">)</span>        <span class="token keyword">return</span> firstName <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> lastName<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> firstName<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> result1 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正确</span><span class="token keyword">let</span> result2 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token string">"Adams"</span><span class="token punctuation">,</span> <span class="token string">"Sr."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 错误，</span><span class="token keyword">let</span> result3 <span class="token operator">=</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token string">"Adams"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正确</span></code></pre><p>ts的剩余参数，指不知道需要传入多少参数。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">addNumbers</span><span class="token punctuation">(</span><span class="token operator">...</span>nums<span class="token punctuation">:</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//一般是数组</span>    <span class="token keyword">var</span> i<span class="token punctuation">;</span>       <span class="token keyword">var</span> sum<span class="token punctuation">:</span>number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//ts的变量声明格式</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"和为："</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token function">addNumbers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> </code></pre><p>ts也可使用函数重载(函数名相同，参数不同)</p><p>ts数组可解构(将数组元素赋值给变量)</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">"Runoob"</span><span class="token punctuation">]</span> <span class="token keyword">var</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> a <span class="token comment" spellcheck="true">//解构，es6好像有新的解构方式(...)</span></code></pre><p>有一些常用数组方法</p><ul><li>contact(),链接两个数组元素</li><li>forEach(),对每个元素进行一次回调函数</li><li>pop(),删除最后一个元素</li><li>push(),在末尾添加一个元素</li><li>slice(),选取数组的一部分</li></ul><p>ts元组，就是一个数组，但里面的元素类型不同。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> mytuple <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">"Runoob"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建元组</span></code></pre><p>ts联合类型，就是一个变量可以有多个类型，以（|）分开。还可形成联合类型数组</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> val<span class="token punctuation">:</span>string<span class="token operator">|</span>number val <span class="token operator">=</span> <span class="token number">12</span> val <span class="token operator">=</span> <span class="token string">"Runoob"</span> </code></pre><p>ts接口，还是interface定义一个抽象接口，当做一个类型进行使用。也可使用extend继承多个接口进行扩展</p><pre class=" language-js"><code class="language-js"><span class="token keyword">interface</span> <span class="token class-name">IPerson</span> <span class="token punctuation">{</span>     firstName<span class="token punctuation">:</span>string<span class="token punctuation">,</span>     lastName<span class="token punctuation">:</span>string<span class="token punctuation">,</span>     sayHi<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span>string <span class="token punctuation">}</span> <span class="token keyword">var</span> customer<span class="token punctuation">:</span>IPerson <span class="token operator">=</span> <span class="token punctuation">{</span>     firstName<span class="token punctuation">:</span><span class="token string">"Tom"</span><span class="token punctuation">,</span>    lastName<span class="token punctuation">:</span><span class="token string">"Hanks"</span><span class="token punctuation">,</span>     sayHi<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>string <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">"Hi there"</span><span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>ts类，面向对象编程,也可extend继承,不能继承父类的私有成员(方法和属性)和构造函数，不支持多继承，支持多重继承，可进行重写，和super调用父类属性和方法类可使用接口，使用关键字 implements，并将接口的属性作为类的属性使用。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">class</span> <span class="token class-name">car</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 类作用域,可包含以下几个模块</span><span class="token comment" spellcheck="true">//字段 - 是类里面声明的变量。字段表示对象的有关数据。</span><span class="token comment" spellcheck="true">//构造函数 − 类实例化时调用，可以为类的对象分配内存。</span><span class="token comment" spellcheck="true">//方法 − 方法为对象要执行的操作。</span>    engine<span class="token punctuation">:</span><span class="token keyword">string</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 构造函数 </span>    <span class="token keyword">constructor</span><span class="token punctuation">(</span>engine<span class="token punctuation">:</span><span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>engine <span class="token operator">=</span> engine     <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 方法 </span>    <span class="token function">disp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">void</span> <span class="token punctuation">{</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"发动机为 :   "</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>engine<span class="token punctuation">)</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> car <span class="token operator">=</span> <span class="token comment" spellcheck="true">/** @class */</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//js代码</span>    <span class="token keyword">function</span> <span class="token function">Car</span><span class="token punctuation">(</span>engine<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>engine <span class="token operator">=</span> engine<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 方法 </span>    Car<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>disp <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"发动机为 :   "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>engine<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Car<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>ts命名空间，为了解决重名问题。命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的，命名空间可嵌套。使用 <strong>namespace</strong> 来定义，</p><pre class=" language-typescript"><code class="language-typescript">namespace SomeNameSpaceName <span class="token punctuation">{</span>    <span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">ISomeInterfaceName</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>     <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">SomeClassName</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//export导出表示可外部调用 </span><span class="token punctuation">}</span></code></pre><p>5.ts模块</p><p>模块是在其自身的作用域里执行，在外部不可见，除非使用 export进行导出，在其他需要使用的地方通过import进行导入。模块使用模块加载器去导入其它的模块，如服务于 Web 应用的 Require.js</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">SomeInterface</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 代码部分</span><span class="token punctuation">}</span><span class="token keyword">import</span> someInterfaceRef <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./SomeInterface"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B站vue商城项目总结</title>
      <link href="/2020/07/29/B%E7%AB%99vue%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2020/07/29/B%E7%AB%99vue%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>​    跟着在B站老陈的视频进行vue的一些学习，最后面就是对前面学习的一些知识的总结性使用。做了一个仿网易严选的商城项目。这里面，你说技术并没有很难，最大的感受还是对现在前端的开发有了一些理解，特别是对ui组件的使用，可以直接就拿现有的组件进行开发，对前端的组件化开发有了一些理解。</p><p>​    在这个项目里面使用了路由，组件，vuex，axios等技术的使用，对后端返回的数据也有了一些认识。知道该如何获取和使用。在这里面，跟多的感觉到了组件化开发的好处和开发一个组件的困难。在购物车的单选和全选那里，因为组件本身的改变，和官网页面的更新不及时(可能是这个原因),导致一直有一些问题存在，最后还是自己修改了后端传来的数据和添加了一些方法(这些方法，看着就写的一塌糊涂)，最后才实现的。</p><p>​    下一步，应该是对现在前端的typescript和前面只学了一点点的es6,7还有对现在css的一些学习模仿，和js跟深一点的东西的学习。还有node.js.</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue laochen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue总结</title>
      <link href="/2020/07/27/vue%E6%80%BB%E7%BB%93/"/>
      <url>/2020/07/27/vue%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>先简单的学习了一些vue的基础知识，先做一个基础的总结，免得知识有些混乱和忘记，只是稍微提一下，并给一个例子</p><p>1.<strong>基础常用语法</strong></p><p>v-bind,v-on,v-model,v-for,v-if/v-show,</p><p>2.在vue实例里面，需要el挂载，data数据，methods方法，computed计算属性，watch侦听器侦听数据变化，</p><p>3.核心组件，专门建一个文件夹放置组件这些可复用的页面，在需要使用的时候，需要使用import引入组件。</p><p>组件里面包括<template></template>里面放置html代码，<script></script>放置js代码，<style></style>放置css代码。</p><p>还有组件之间传递值的方式。</p><p>4.动画，<transition> 需要动画效果的html代码</transition></p><p>5.路由，根据路径的不同显示不同地页面组件。路由守卫，就是对路由的传递进行验证看是否满足什么条件</p><p>6.css预编译less。</p><p>7.vuex，对大型vue应用的数据进行统一管理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习</title>
      <link href="/2020/07/24/ES6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/24/ES6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>js的一种版本标准，只是为了学一些重点的新语法。</p><img src="/images/loading.gif" data-original="https://www.runoob.com/wp-content/uploads/2018/12/es6-tutorial.jpg" alt="img" style="zoom: 50%;" /><h4 id="1-箭头函数"><a href="#1-箭头函数" class="headerlink" title="1.箭头函数"></a>1.箭头函数</h4><p><strong>箭头函数的作用主要是定义匿名函数</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 转换成箭头函数</span><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>基本语法<strong>（参数）</strong>：</p><ul><li>匿名函数没有参数：() 不能省略，占位作用。<code>let foo = () =&gt; {};</code></li><li>只有一个参数：() 可以省略，也可以不省略。<code>let foo = a =&gt; {};</code></li><li>多个参数，() 不能省略。<code>let foo = (a,b) =&gt; {};</code></li></ul><p><strong>箭头函数的特点：</strong></p><p>1、不能做构造函数（不能实例化）</p><p>2、没有 arguments。 arguments就是函数带的实参，类似linux的argv，可用arguments获取调用的参数。</p><p><strong>3、箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，this指向上下文环境。（意思：箭头函数的外层的是否有函数，如果有，箭头函数的this就是外层函数的this，如果没有，则为 window）</strong></p><hr><h4 id="2-let-与-const"><a href="#2-let-与-const" class="headerlink" title="2.let 与 const"></a>2.let 与 const</h4><p>let 声明的变量只在 let 命令所在的代码块内有效。</p><p>const 声明一个只读的常量，一旦声明，常量的值就不能改变。</p><hr><h4 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3.解构赋值"></a>3.解构赋值</h4><p>解构赋值是对赋值运算符的扩展，他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</p><p><strong>从对象或数组中提取数据, 并赋值给变量(多个)</strong>。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>name <span class="token punctuation">:</span> <span class="token string">'kobe'</span><span class="token punctuation">,</span> age <span class="token punctuation">:</span> <span class="token number">39</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> name <span class="token operator">=</span> obj<span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token keyword">let</span> age <span class="token operator">=</span> obj<span class="token punctuation">.</span>age<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解构</span><span class="token keyword">let</span> <span class="token punctuation">{</span>name<span class="token punctuation">,</span>age<span class="token punctuation">}</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span></code></pre><hr><h4 id="4-展开符-三点运算符-…"><a href="#4-展开符-三点运算符-…" class="headerlink" title="4.展开符/三点运算符(…)"></a>4.展开符/三点运算符(…)</h4><p>用来取代 arguments 但比 arguments 灵活.</p><p><img src="/images/loading.gif" data-original="https://gitee.com/xxgw1997/Web-2/raw/master/12-ES6/images/9.png" alt="img"></p><p>或者可用来对数组进行扩展</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">...</span>arr1<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1,2,3,4,5,6]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 2 3 4 5 6</span></code></pre><hr><h4 id="5-async-函数"><a href="#5-async-函数" class="headerlink" title="5.async 函数"></a>5.async 函数</h4><p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">helloAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token string">"helloAsync"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">helloAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// Promise {&lt;resolved>: "helloAsync"}</span><span class="token function">helloAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// helloAsync。async里的return返回会成为then()回调函数的参数。</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。</p><h4 id="6-class类"><a href="#6-class类" class="headerlink" title="6.class类"></a>6.class类</h4><p>为了方便创建对象。形似java里面的class类</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//定义类</span><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">'('</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">', '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> newclass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建</span></code></pre><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p><hr><p>class可以继承。<strong>extends</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">ColorPoint</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用父类的constructor(x,y)，子类必须在constructor方法中调用super方法，主要构建父类的this对象。</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用父类的toString()</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex插件和vant</title>
      <link href="/2020/07/23/vuex%E6%8F%92%E4%BB%B6%E5%92%8Cvant/"/>
      <url>/2020/07/23/vuex%E6%8F%92%E4%BB%B6%E5%92%8Cvant/</url>
      
        <content type="html"><![CDATA[<p><strong>1.vuex插件</strong></p><p>Vuex 的 store 接受 <code>plugins</code> 选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 store 作为唯一参数：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> myPlugin <span class="token operator">=</span> store <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 当 store 初始化后调用</span>  store<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span>mutation<span class="token punctuation">,</span> state<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 每次 mutation 之后调用</span>    <span class="token comment" spellcheck="true">// mutation 的格式为 { type, payload }</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>然后像这样使用：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>myPlugin<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>在插件中不允许直接修改状态——类似于组件，只能通过提交 mutation 来触发变化,通过提交 mutation，插件可以用来同步数据源到 store</p><p><strong>2.混入</strong></p><p>相当于将各个部分分开，使其可复用，混在一起使用，与合在一起写的效果相同</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> mixin <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//定义需要混入的部分</span>  data<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      message<span class="token punctuation">:</span> <span class="token string">'hello'</span><span class="token punctuation">,</span>      foo<span class="token punctuation">:</span> <span class="token string">'abc'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  mixins<span class="token punctuation">:</span> <span class="token punctuation">[</span>mixin<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//使用mixins使用混入</span>  data<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      message<span class="token punctuation">:</span> <span class="token string">'goodbye'</span><span class="token punctuation">,</span>      bar<span class="token punctuation">:</span> <span class="token string">'def'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// => { message: "goodbye", foo: "abc", bar: "def" }</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>当出现同名属性，数据的时候，以组件中的为主，如果是方法(methods)，则都会调用，但混入的会先被调用。</p><p><strong>3.自定义指令</strong></p><p>使用Vue.directive进行指令创建</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 注册一个全局自定义指令 `v-focus`</span>Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'focus'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 当被绑定的元素插入到 DOM 中时……</span>  inserted<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 聚焦元素，el表示的是使用这个指令的标签的html代码</span>    el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h5 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a><a href="https://cn.vuejs.org/v2/guide/custom-directive.html#钩子函数" target="_blank" rel="noopener">钩子函数</a></h5><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><ul><li><p><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p></li><li><p><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p></li><li><p><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p></li><li><p><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</p></li><li><p><code>unbind</code>：只调用一次，指令与元素解绑时调用。</p></li></ul><p>接下来我们来看一下钩子函数的参数 (即 <code>el</code>、<code>binding</code>、<code>vnode</code> 和 <code>oldVnode</code>)。</p><h5 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a><a href="https://cn.vuejs.org/v2/guide/custom-directive.html#钩子函数参数" target="_blank" rel="noopener">钩子函数参数</a></h5><p>指令钩子函数会被传入以下参数：</p><ul><li><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM。</li><li><code>binding</code>：一个对象，包含以下 property：<ul><li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li><li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li><li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li><li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li><li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li><li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code>。</li></ul></li><li><code>vnode</code>：Vue 编译生成的虚拟节点。移步 <a href="https://cn.vuejs.org/v2/api/#VNode-接口" target="_blank" rel="noopener">VNode API</a> 来了解更多详情。</li><li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li></ul><p>除了 <code>el</code> 之外，其它参数都应该是只读的，切勿进行修改。</p><p>4.vue插件</p><p>通过全局方法 <code>Vue.use()</code> 使用插件</p><p>Vue.js 的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象：</p><pre class=" language-js"><code class="language-js">MyPlugin<span class="token punctuation">.</span>install <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>Vue<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 1. 添加全局方法或 property</span>  Vue<span class="token punctuation">.</span>myGlobalMethod <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 逻辑...</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 2. 添加全局资源</span>  Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'my-directive'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    bind <span class="token punctuation">(</span>el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 逻辑...</span>    <span class="token punctuation">}</span>    <span class="token operator">...</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 3. 注入组件选项</span>  Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 逻辑...</span>    <span class="token punctuation">}</span>    <span class="token operator">...</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 4. 添加实例方法</span>  Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$myMethod <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>methodOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 逻辑...</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>5.vant</p><p>参考官网<a href="https://youzan.github.io/vant/?source=vuejsorg#/zh-CN/button" target="_blank" rel="noopener">vant</a></p><p>ui组件。先<code>npm i vant -S</code>安装，之后</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Vant <span class="token keyword">from</span> <span class="token string">'vant'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//全局导入，不推荐</span><span class="token keyword">import</span> <span class="token string">'vant/lib/index.css'</span><span class="token punctuation">;</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vant<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//按需导入，推荐</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> Button <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vant'</span><span class="token punctuation">;</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Button<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>导入vant包和样式，并使用vue.use进行使用</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>van-button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>default<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>默认按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>van-button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>van-button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>primary<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>主要按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>van-button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>van-button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>信息按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>van-button</span><span class="token punctuation">></span></span></code></pre><p>具体使用和参数参考vant官网。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vuex vue vant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex</title>
      <link href="/2020/07/19/vuex/"/>
      <url>/2020/07/19/vuex/</url>
      
        <content type="html"><![CDATA[<p>Vuex 是一个专为 大型Vue.js 应用程序开发的<strong>状态管理模式</strong></p><p>1.简单来说，vuex就是用来集中管理组件的数据的(多组件共享的数据)。</p><p><strong>数据驱动视图，动作(action)更改数据</strong>，是一个环形单向数据流。</p><p>每一个 Vuex 应用的核心就是 store(数据仓库)。</p><p>2.vuex需要安装</p><pre><code>npm install vuex -S</code></pre><p>3.在vue应用的下面会多出来一个store的文件夹，在里面使用vuex。首先会在里面的index.js里面创建仓库对象。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//data</span>state<span class="token punctuation">:</span> <span class="token punctuation">{</span>    num<span class="token punctuation">:</span><span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> getters<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//methods,在mutation里处理状态</span>  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">addnum</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">{</span>      state<span class="token punctuation">.</span>num<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//异步方法</span> actions<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//模块</span> modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>  buyCar <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>在state里面添加全局数据，在mutation里面添加全局方法，修改数据。组件想要调用此方法，需要使用this.$store.commit(‘addnum’);进行调用。通过$store.state.num获得数据。</p><p><strong>4.state</strong></p><p>在组件里的应用，一般放在computed里面当做一个函数，返回一个在state里面的数据，如</p><pre class=" language-js"><code class="language-js">msg<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> $store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>num<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>​        4.1 mapstate</p><p>简化我们获取数据的方式，mapState的作用就是返回一个对象，这个对象可以直接丢给computed</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> mapState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token comment" spellcheck="true">//需要引用</span>   <span class="token comment" spellcheck="true">// computed: {</span>    <span class="token comment" spellcheck="true">//     userList: function() {</span>    <span class="token comment" spellcheck="true">//         return this.$store.state.userList;</span>    <span class="token comment" spellcheck="true">//     },</span>    <span class="token comment" spellcheck="true">//     goodsList: function() {</span>    <span class="token comment" spellcheck="true">//         return this.$store.state.goodsList;</span>    <span class="token comment" spellcheck="true">//     }</span>    <span class="token comment" spellcheck="true">// }</span>computed<span class="token punctuation">:</span> <span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token function">title</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> state<span class="token punctuation">.</span>title<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">userList</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> state<span class="token punctuation">.</span>userList<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">goodsList</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> state<span class="token punctuation">.</span>goodsList<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre><p>如果state上有某个属性，可以直接赋值：</p><pre class=" language-js"><code class="language-js">computed<span class="token punctuation">:</span> <span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    title<span class="token punctuation">:</span> <span class="token string">'title'</span><span class="token punctuation">,</span>    userList<span class="token punctuation">:</span> <span class="token string">'userList'</span><span class="token punctuation">,</span>    goodsList<span class="token punctuation">:</span> <span class="token string">'goodsList'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre><p>如果mapState属性的名字和state中属性的名字相同的话，就可以采用下面更简单的写法：</p><pre class=" language-js"><code class="language-js">computed<span class="token punctuation">:</span> <span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">,</span> <span class="token string">'goodsList'</span><span class="token punctuation">,</span> <span class="token string">'userList'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>有些复杂数据还是推荐使用第一种。</p><p><strong>5.getter</strong></p><p>相当于store的一个计算属性，就是对state的数据进行计算，当组件需要取到state的属性然后进行计算得到想要的结果的时候，计算的过程可以在<code>getters</code> 中进行，组件从getters中就可以直接拿到计算好的值。如果所有组件都需要这个计算的话，那就方便多了。</p><pre class=" language-js"><code class="language-js">getters<span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...   ，可接受其他getter作为参数</span>  doneTodosCount<span class="token punctuation">:</span> <span class="token punctuation">(</span>state<span class="token punctuation">,</span> getters<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> getters<span class="token punctuation">.</span>doneTodos<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//return state.num++;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值</p><pre class=" language-js"><code class="language-js">computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">,</span> <span class="token string">'userList'</span><span class="token punctuation">,</span> <span class="token string">'goodsList'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 直接调用getters的countAge属性即可</span>    <span class="token function">allAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>countAge    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>​    5.1 mapgetter    </p><p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p><pre class=" language-js"><code class="language-js"> <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">{</span> allAge<span class="token punctuation">:</span> <span class="token string">'countAge'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// allAge() {</span>    <span class="token comment" spellcheck="true">//     return this.$store.getters.countAge</span>    <span class="token comment" spellcheck="true">// }</span></code></pre><p><strong>6.mutation</strong>    更改 Vuex 的 store 中的状态的唯一方法是提交 mutation</p><p>当需要在store里面操作数据的增删的时候，需要使用mutation属性。</p><p>可以在mutation里面添加方法，进行修改数据</p><pre class=" language-js"><code class="language-js">mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">addUser</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>            state<span class="token punctuation">.</span>userList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> userName<span class="token punctuation">:</span> <span class="token string">'aaa'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">10</span>             <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//在组件里也使用进行调用。</span>methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 使用commit的方式调用</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'addUser'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p><strong>我们在commit的第二个参数传递数据。这里有个专业的术语叫做【载荷】，只能有一个</strong></p><pre class=" language-js"><code class="language-js"> mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// data接收commit的载荷</span>        <span class="token function">addUser</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>            state<span class="token punctuation">.</span>userList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                userName<span class="token punctuation">:</span> data<span class="token punctuation">.</span>name<span class="token punctuation">,</span>                age<span class="token punctuation">:</span> data<span class="token punctuation">.</span>age            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//组件里面</span>    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">addUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// commit的第二个参数填写传递的载荷</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'addUser'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>                name<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span>                age<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>​    整个应用程序，只有mutations才可以操作state状态。</p><p>​    但是注意：</p><p>​    <strong>mutations中的属性，必须为纯函数，必须为同步代码。</strong></p><p>​    纯函数就是传入相同的参数，得到相同的结果。</p><p>​    同步代码就不能是异步的，比如ajax，比如setTimeout等。</p><p><strong>7.action</strong></p><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><p><em>能操作state的只有mutations，actions也不行。只能调用mutations去操作state。</em></p><p>在action里面可通过commit调用mutation你的数据操纵方法，在组件你的methods里面使用dispatch调用action里的方法</p><pre class=" language-js"><code class="language-js"><span class="token function">addUserTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用dispatch调用actions的属性</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'addUserTimeout'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span>            age<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>总结mutations与actiosn的区别：</strong></p><p>​    1、commit方法用于调用mutation；dispatch 方法用于调用action；</p><p>​    2、mutation 函数必须是纯函数，而且不能有异步代码；action 可以不是纯函数，也可以有异步代码；</p><p>​    3、按照上述规则，可以用mutation完成的事情，可以直接调用mutation，mutation不能实现的事情丢给action来完成。</p><p>​    4、在action中，当完成异步操作，最终需要修改数据模型时，还是需要通过mutation来完成对数据模型的操作。action不允许直接操作数据模型。</p><p><strong>8.module</strong></p><p>Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>  state<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  getters<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> moduleB <span class="token operator">=</span> <span class="token punctuation">{</span>  state<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//需要在index.js里导入，上面两个是一个各自单独的文件</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> moduleA<span class="token punctuation">,</span>    b<span class="token punctuation">:</span> moduleB  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>a <span class="token comment" spellcheck="true">// -> moduleA 的状态</span>store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>b <span class="token comment" spellcheck="true">// -> moduleB 的状态</span></code></pre><h5 id="8-1命名空间"><a href="#8-1命名空间" class="headerlink" title="8.1命名空间"></a>8.1命名空间</h5><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p><p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名，使用的时候会使用这个命名</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 开启命名空间</span>    namespaced<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    state<span class="token punctuation">:</span> <span class="token punctuation">{</span>        title<span class="token punctuation">:</span> <span class="token string">'我是首页'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue高级知识</title>
      <link href="/2020/07/15/vue%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/07/15/vue%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h5 id="B站老陈"><a href="#B站老陈" class="headerlink" title="B站老陈"></a>B站老陈</h5><p>1.socket.io(套接字),用于浏览器和服务器进行实时，双向，基于事件(异步)的通信。</p><p>socket. emit(‘名’,’数据’),发送客户端数据。socket.on(‘名’,function(data){})监听客户端或服务器发送的内容</p><p>服务器与客户端之间的连接以一个唯一的id进行标识，当一个新的用户浏览器进行与服务器的连接时，需要进行广播(sockets.emit())，将此连接的id广播给其他客户端，方便进行数据交流,使用socket.to(目标id).emit(‘名’,{数据})</p><p>命名空间，用以区分。通过socket.join和leave可以加入和离开房间</p><p>2.vue实现原理</p><p>首先vue可以当做一个构造函数，传入一个参数为对象。</p><p>3.less。css扩展语言，预处理器。让其可重复使用，但浏览器不支持，需要编译转化为css。使用</p><pre><code>lessc 源文件.less 目标文件.css</code></pre><p>将less文件编译成css文件。</p><p>使用@变量名 = xxx,定义全局可使用的变量。可混合带参数使用，直接在一个class里面引入另一个class名，即可将样式复制过来，参数也可在样式里面当一个变量。参数需要@符号声明。参数可以使用一个默认值，当没有参数传入时，就使用默认值。@_匹配模式，相当于匹配一些class，再加上一些样式。还可对变量进行计算可进行样式直接嵌套(不建议使用嵌套)</p><p>可使用@argument将所有的默认变量传入。</p><pre><code>.border_arg(@width: 1.75rem, @color: #e6e6e6, @style: solid) {    border: @arguments}</code></pre><p>在vue里面使用less：</p><p>需要在sytle标签里面设置lang属性为less。lang=”less”。</p><p>4.router路由</p><p>根据不同的路径显示不同的页面。在router里面的index.js里面配置不同的路径显示的不同的组件或者页面。根据选择的<router-link>替换<router-view/>来显示内容。在本质上还是一个页面。</p><p>所有的核心配置都在index.js里面</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token punctuation">{</span>    path<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>    name<span class="token punctuation">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//component: Home</span>    components<span class="token punctuation">:</span><span class="token punctuation">{</span>      nav<span class="token punctuation">:</span>navView<span class="token punctuation">,</span>      aside<span class="token punctuation">:</span>asideView<span class="token punctuation">,</span>      <span class="token keyword">default</span><span class="token punctuation">:</span>Home    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    path<span class="token punctuation">:</span><span class="token string">"/a"</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//redirect:"/about"</span>    redirect<span class="token punctuation">:</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>query<span class="token punctuation">.</span>go<span class="token operator">==</span><span class="token string">'about'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">"about"</span><span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">"news"</span><span class="token punctuation">,</span>params<span class="token punctuation">:</span><span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token number">456789</span><span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span></code></pre><p>通过path，name，component设置。</p><p>我们可以在任何组件内通过 <code>this.$router</code> 访问路由器，也可以通过 <code>this.$route</code> 访问当前路由</p><p><strong>动态路由</strong>，把某种模式匹配到的所有路由，全都映射到同个组件。在path里面可使用通配符 <code>*</code>进行匹配任意路径，一般用于404页面。当使用一个通配符时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 URL 通过通配符被匹配的部分</p><pre class=" language-js"><code class="language-js"> routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token comment" spellcheck="true">// 动态路径参数 以冒号开头</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User <span class="token punctuation">}</span>  <span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">//通过$route.params.id可获得路径后的id参数值</span>  <span class="token keyword">const</span> User <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;div>User {{ $route.params.id }}&lt;/div>'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 会匹配以 `/user-` 开头的任意路径</span>  path<span class="token punctuation">:</span> <span class="token string">'/user-*'</span>  <span class="token punctuation">}</span>    </code></pre><p>可使用watch进行监听路由发生的变化</p><pre class=" language-js"><code class="language-js">watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">$route</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 对路由变化作出响应...</span>    <span class="token punctuation">}</span></code></pre><p><strong>嵌套路由</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User<span class="token punctuation">,</span>      children<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 当 /user/:id/profile 匹配成功，</span>          <span class="token comment" spellcheck="true">// UserProfile 会被渲染在 User 的 &lt;router-view> 中</span>          path<span class="token punctuation">:</span> <span class="token string">'profile'</span><span class="token punctuation">,</span>          component<span class="token punctuation">:</span> UserProfile        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 当 /user/:id/posts 匹配成功</span>          <span class="token comment" spellcheck="true">// UserPosts 会被渲染在 User 的 &lt;router-view> 中</span>          path<span class="token punctuation">:</span> <span class="token string">'posts'</span><span class="token punctuation">,</span>          component<span class="token punctuation">:</span> UserPosts        <span class="token punctuation">}</span>      <span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>使用children属性进行嵌套的配置。还可以继续进行嵌套。</p><p><strong>编程式导航</strong>(使用点击事件在js的mehtods里面使用)，除了使用 <code>&lt;router-link&gt;</code>，还可使用</p><p><code>router.push(location, onComplete?, onAbort?)</code>进行导航。使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 字符串</span>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'home'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 对象</span>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'home'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 命名的路由</span>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span> params<span class="token punctuation">:</span> <span class="token punctuation">{</span> userId<span class="token punctuation">:</span> <span class="token string">'123'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 带查询参数，变成 /register?plan=private</span>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'register'</span><span class="token punctuation">,</span> query<span class="token punctuation">:</span> <span class="token punctuation">{</span> plan<span class="token punctuation">:</span> <span class="token string">'private'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><strong>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，params将以path里面的为准</strong></p><p>router.go(n)这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步</p><p><strong>命名路由</strong></p><p>通过一个名称来标识一个路由</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/user/:userId'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> User    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token punctuation">:</span>to<span class="token operator">=</span><span class="token string">"{ name: 'user', params: { userId: 123 }}"</span><span class="token operator">></span>User<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">></span><span class="token comment" spellcheck="true">//这跟代码调用 router.push() 是一回事：</span>router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span> params<span class="token punctuation">:</span> <span class="token punctuation">{</span> userId<span class="token punctuation">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><strong>命名视图</strong></p><p>同时 (同级) 展示多个视图，而不是嵌套展示，你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。之前router-link时，只有一个router-view进行替换，只会有一个视图，现在可通过命名视图将几个视图何在一个页面上。</p><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。需要使用components进行配置，默认为default。也可配合嵌套路由，在childern里面使用命名视图。</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>router<span class="token operator">-</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"view one"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span><span class="token operator">&lt;</span>router<span class="token operator">-</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"view two"</span> name<span class="token operator">=</span><span class="token string">"a"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span><span class="token operator">&lt;</span>router<span class="token operator">-</span>view <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"view three"</span> name<span class="token operator">=</span><span class="token string">"b"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token keyword">default</span><span class="token punctuation">:</span> Foo<span class="token punctuation">,</span>        a<span class="token punctuation">:</span> Bar<span class="token punctuation">,</span>        b<span class="token punctuation">:</span> Baz      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><strong>重定向和别名</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> redirect<span class="token punctuation">:</span> <span class="token string">'/b'</span> <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>重定向的目标也可以是一个命名的路由：<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> redirect<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'foo'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>甚至是一个方法，动态返回重定向目标：<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> redirect<span class="token punctuation">:</span> to <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 方法接收 目标路由 作为参数</span>      <span class="token comment" spellcheck="true">// return 重定向的 字符串路径/路径对象</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>​    <code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> A<span class="token punctuation">,</span> alias<span class="token punctuation">:</span> <span class="token string">'/b'</span> <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p><p><strong>路由组件传参</strong></p><p>在组件中使用 <code>$route</code> 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。使用 <code>props</code> 将组件和路由解耦：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> User <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;div>User {{ $route.params.id }}&lt;/div>'</span><span class="token punctuation">}</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//组件传参props</span><span class="token keyword">const</span> User <span class="token operator">=</span> <span class="token punctuation">{</span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;div>User {{ id }}&lt;/div>'</span><span class="token punctuation">}</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User<span class="token punctuation">,</span> props<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token punctuation">:</span> User<span class="token punctuation">,</span> sidebar<span class="token punctuation">:</span> Sidebar <span class="token punctuation">}</span><span class="token punctuation">,</span>      props<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> sidebar<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>在组件里也使用props将传入的数据拿到，进行数据显示。</p><p><strong>路由守卫</strong></p><p>简单来说就是路由在跳转之前的验证，当满足条件时才会进行跳转。分为<code>全局守卫</code>，<code>路由守卫</code>和<code>组件守卫</code></p><p>​    1.注册全局守卫应该在路由模块暴露出去之前定义，所有的路由跳转都会被调用使用<code>router.beforeEach(function(to,from,next){})</code>来注册一个全局守卫。</p><p>参数：</p><ul><li><p>to：代表目标路径对象</p></li><li><p>from：来源路径对象</p></li><li><p>next：用于决定是否继续进行跳转。</p><p>当next()函数不传参数或者传入true的时候 则允许正常跳转；</p><p>当next()函数传入false时 会中断跳转(阻止跳转)；</p><p>当next()函数中<strong>传入路径</strong>时或者<strong>对象</strong>时(比如:{name:’xxx’})则会重定向到指定路径。</p><p>2.路由守卫就是针对单个路由对象配置的守卫。</p></li></ul><p>假如我在users组件配置路由守卫，那么只有跳转到users路由时才会触发该守卫，跳转到其他路由时不会触发该守卫。</p><p>路由守卫的注册写在路由匹配规则数组里面：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token comment" spellcheck="true">//...        </span>        <span class="token punctuation">{</span>path<span class="token punctuation">:</span> <span class="token string">'/users'</span><span class="token punctuation">,</span>                     component<span class="token punctuation">:</span> Users<span class="token punctuation">,</span>                     name<span class="token punctuation">:</span> <span class="token string">'u'</span><span class="token punctuation">,</span>                     beforeEnter<span class="token punctuation">:</span> <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                                    <span class="token function">next</span><span class="token punctuation">(</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">'Entey Users?'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    3.组件守卫是针对单个组件进行监听，在访问到该组件时才会触发。</p><p>​    写在组件里</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">let</span> Home <span class="token operator">=</span> <span class="token punctuation">{</span>    template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`        &lt;div>            &lt;h1>首页&lt;/h1>            &lt;router-view>&lt;/router-view>            &lt;router-view name="b">&lt;/router-view>        &lt;/div>    `</span></span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 在路由跳转时,如果会访问到当前组件,则会触发该守卫</span>    <span class="token function">beforeRouteEnter</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">'Enter Home?'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 在路由跳转时,如果离开当前组件,则会触发该守卫</span>    beforeRouteLeave <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">next</span><span class="token punctuation">(</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">'Leave Home?'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 在当前路径下,当路由的参数发生变化时，才会触发该路由守卫</span>    <span class="token function">beforeRouteUpdate</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>params<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>路由元信息</strong></p><p>路由的特有属性，写在meta:{ }里面，为后面的组件提供一些特定信息进行逻辑判断。</p><p><strong>过渡动效</strong></p><p>用 <code>&lt;transition&gt;</code> 组件给它添加一些过渡效果</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>transition name<span class="token operator">=</span><span class="token string">"slide"</span> mode<span class="token operator">=</span><span class="token string">"out-in"</span> enter<span class="token operator">-</span>active<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"animated bounceInLeft"</span> leave<span class="token operator">-</span>active<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"animated bounceOutRight"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive<span class="token operator">></span>        <span class="token operator">&lt;</span>router<span class="token operator">-</span>view<span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>transition<span class="token operator">></span></code></pre><p><strong>数据获取</strong></p><p><strong>滚动行为</strong></p><p>当创建一个 Router 实例，你可以提供一个 <code>scrollBehavior</code> 方法</p><pre class=" language-js"><code class="language-js">scrollBehavior <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> savedPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>savedPosition<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> savedPosition  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>路由懒加载</strong></p><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue socket less route </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue学习(二)</title>
      <link href="/2020/07/13/vue%E5%AD%A6%E4%B9%A0-%E4%BA%8C/"/>
      <url>/2020/07/13/vue%E5%AD%A6%E4%B9%A0-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="vue的B站老陈学习"><a href="#vue的B站老陈学习" class="headerlink" title="vue的B站老陈学习"></a>vue的B站老陈学习</h4><p>那些基本的在前一篇大多都说了，这一篇记一些没说到的。</p><p>1.过渡动画，一般使用transition完成。例如</p><pre class=" language-html"><code class="language-html">&lt;transition name = "nameoftransition">   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">></span></span></code></pre><p>需要指定这个动画的名字。</p><p><strong>重点是css里面的css类名和css动画效果</strong></p><p>一般是动画名(例如fade)再加一些特定标识，如</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.fade-enter-active</span>, <span class="token class">.fade-leave-active</span> </span><span class="token punctuation">{</span>    <span class="token property">transition</span><span class="token punctuation">:</span> opacity <span class="token number">2</span>s<span class="token punctuation">}</span><span class="token selector"><span class="token class">.fade-enter</span>, <span class="token class">.fade-leave-to</span>  </span><span class="token punctuation">{</span>    <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token comment" spellcheck="true">/*opacity表示透明效果*/</span><span class="token punctuation">}</span></code></pre><p>active表示动画的进行时间，enter和leave-to表示刚进入的效果和最终离开时的效果。还有enter-to和leave这两个表示动画最后的效果和离开开始的过渡状态。</p><img src="./images/loading.gif" data-original="https://www.runoob.com/wp-content/uploads/2018/06/transition.png" alt="img" style="zoom:50%;" /><p>还可以使用自定义的类名，可以和第三方css类插件库(如:animate.css)进行配合。</p><p>如：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span>    <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>custom-classes-transition<span class="token punctuation">"</span></span>    <span class="token attr-name">enter-active-class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>animated tada<span class="token punctuation">"</span></span>    <span class="token attr-name">leave-active-class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>animated bounceOutRight<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">></span></span></code></pre><p>此外还有enter-class,leave-class,enter-to-class,leave-to-class.与上面相对应。</p><p>过渡时间你也可以在transition里面是绑定duration进行设置。如：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span> <span class="token attr-name">:duration</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span> <span class="token attr-name">:duration</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{ enter: 500, leave: 800 }<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">></span></span></code></pre><p>2.生命周期</p><img src="./images/loading.gif" data-original="https://cn.vuejs.org/images/lifecycle.png" alt="Vue å®ä¾çå½å¨æ" style="zoom:33%;" /><p>我们能拿到的只有红色框里面的东西，中间的都是vue自动完成，我们无法控制。一般直接在vue实例里面添加这些东西进行控制。如：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//进行控制.</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a is: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>在beforeCreate里面输出this和vue里面的data会有不同，this表示vue实例刚创建，但data里面的数据还没有绑定，会输出undefined，同时methods这些也没有绑定</p><p>在beforeCreate和created这中间就是绑定data和methods这些。</p><p>created之后就是渲染页面，在渲染之前绑定的一些数据在vue实例里面不会拿到，虽然在浏览器html里面有了。在渲染之后(mounted)就可以拿到这些dom对象。</p><p>当数据被修改，也会有两个阶段，在before阶段，虽然数据修改了，但内容还没渲染修改，在updated后，就会重新渲染，内容也改变了。</p><p>销毁一般很少调用。</p><p>3.组件感觉还有一些东西要写。</p><p>prop传递数据（子组件用来接受父组件传递过来的数据的一个自定义属性）：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">message</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hello!<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parentMsg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>//动态prop传递数据      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>message1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parentMsg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token comment" spellcheck="true">// 注册</span>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'child'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 声明 props</span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'message'</span><span class="token punctuation">,</span><span class="token string">'message1'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 同样也可以在 vm 实例中像 "this.message" 这样使用</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;span>{{ message }}+{{message1}}&lt;/span>'</span><span class="token punctuation">}</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>自定义事件（子组件要把数据传递回去，就需要使用自定义事件）</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>counter-event-example<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>{{ total }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button-counter</span> <span class="token attr-name"><span class="token namespace">v-on:</span>increment</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>incrementTotal<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button-counter</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button-counter</span> <span class="token attr-name"><span class="token namespace">v-on:</span>increment</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>incrementTotal<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button-counter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'button-counter'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;button v-on:click="incrementHandler">{{ counter }}&lt;/button>'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      counter<span class="token punctuation">:</span> <span class="token number">0</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    incrementHandler<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>counter <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//触发increment事件,在v-on监听里面触发，调用vue实例里面的函数</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">'#counter-event-example'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    total<span class="token punctuation">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    incrementTotal<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>total <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>component里面的data必须是一个函数，为了保证每个组件的数据不共用。注意驼峰命名法在html里面需要转换成横线格式。</p><p>同时有$parent,$children,$root属性，可以在组件中找到父元素的vue对象，子元素的，根(最外层对象)的这些，之后就可以当做vue对象进行调用方法之类的。</p><p>v-model也可以绑定到组件上，默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，需要在组件的template里面添加相应监听和$emit()调用。</p><p><strong>一般使用.vue分开使用组件的话</strong></p><p><strong>父组件给子组件传递数据：在父组件的子组件标签里面通过v-bind绑定一个<u>特定名</u>和数据。在子组件里使用props声明这个<u>特定名</u>，然后就可以使用这个特定名进行数据使用。</strong></p><p><strong>子组件给父组件传递数据和使用父组件的方法：</strong></p><p>​    <strong>1.在父组件的子组件标签里面通过v-on监听一个<u>特定名</u>和一个在父组件里面的methods的方法名，在子组件里面自定义一个点击事件之类的，触发在子组件里面自定义的方法，在这个方法里面通过this.$emit(‘<u>特定名</u>‘,’数据’)，就会通过这个特定名调用父组件里面的方法，数据也作为参数传递了过去。</strong></p><p>​    <strong>2.在父组件里通过v-bind绑定一个<u>特定名</u>和<u>父组件方法</u>，在子组件里通过props声明这个特定名，然后就可以把这个<u>特定名</u>当做一个方法进行使用</strong></p><p>4.插槽。整体结构不变，但要插入一些内容。<slot></slot>,新版本(2.6.0)可使用v-slot。一般来说，在自定义组件的标签里面添加内容，是不会被渲染到页面上去的，但slot解决了这个问题。<slot>在组件的template里面添加使用，添加之后，当在组件标签里面添加内容时，slot将会被替换掉，内容可被渲染到页面上。一个组件的template最外层只会有一个标签，一般可使用一个div将所有元素进行包裹。</p><p><strong>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</strong></p><p>5.动态组件。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>is</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>currentTabComponent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">></span></span></code></pre><p>可使用is属性切换不同的组件。</p><p>is用法。其中currentTabComponent是在vue实例里面进行数据定义，然后在局部定义组件和方法进行切换currentTabComponent，在this.$options.components[id]，this表示vue实例，获取到组件实例，之后将component标签替换成这个组件。</p><p>一般切换的时候，都会重新渲染组件。当我们不想让其重新渲染的时候，就可以使用<keep-alive>标签。如</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>is</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>currentTabComponent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">></span></span></code></pre><p> keep-alive要求被切换到的组件都有自己的名字，不论是通过组件的 <code>name</code>选项还是局部/全局注册。</p><p>因为一些标签 有一些限制出现的地方，如<li>，为了避免这些情况，在组件中的template使用<strong>单文件组件(.vue文件)</strong>就不会存在这些限制，这也是重点。</p><p>6.<strong>单文件组件(.vue文件)</strong></p><p>脚手架。.vue文件解决了<strong>全局定义</strong> <strong>字符串模板</strong> <strong>不支持组件 CSS</strong>  <strong>没有构建步骤</strong>这些缺点</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue 老陈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue学习(一)</title>
      <link href="/2020/07/11/vue%E5%AD%A6%E4%B9%A0-%E4%B8%80/"/>
      <url>/2020/07/11/vue%E5%AD%A6%E4%B9%A0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h5 id="vue的黑马学习"><a href="#vue的黑马学习" class="headerlink" title="vue的黑马学习"></a>vue的黑马学习</h5><p>1.vue作用范围，只有在vue实例的el挂载点里面及其后代元素才会进行这个vue实例的操作。不仅可以使用id选择器，class选择器也行，使用.class进行el挂载。其他的选择器也都能行。可以使用其他的双标签，但不能是body和html标签。</p><p>2.Vue中用到的数据定义在data中，data中可以写复杂类型的数据，渲染复杂类型数据时,遵守js的语法即可</p><p>3.dom操作是获取元素，操作它们。vue使用指令操作</p><p>4.v-text指令。直接替换标签里面的所有文字和数据。跟两个大括号没什么差别。</p><p>5.v-html，设置标签的innerHTML，就是将纯html文本解析成html效果。</p><p>6.v-on，为元素绑定事件，类似onclick等。v-on:click=”函数名”,函数在vue实例的methods里面定义，methods:{click:function(){ }, other:{ } }。同时，在函数名后面可以传递参数，相应在定义函数时也要添加这个参数。还可以使用(.)表示的指令后缀调用修饰符。如@click.once=””,只会调用一次，@keyup.enter=””这些。</p><p>7.v-show,根据表达值的真假，切换元素的显示和隐藏。本质就是切换display属性。</p><p>8.v-if,v-if=”值”,根据值的真假，判断是否显示，但不是操纵display，而是直接操纵dom元素。</p><p>9.v-bind,设置元素的属性。v-bind:属性名=”属性值”，一般属性值在data里面进行定义。</p><p>10.v-for,生成列表。格式v-for=”item in items”，在data里面对items进行数据设置，一般是数组或者对象或者对象数组。使用对象时，可使用(value,key,index) in object 对对象进行数据访问。</p><p>11.v-model，获取和设置表单元素的值(进行双向数据绑定)。就是表单中的数据发生改变时，另一个绑定的数据元素也会发生改变。一般用来获取输入文本框中的输入数据.</p><p>12.网络请求(axios).一般使用get和post</p><p>例如：</p><pre class=" language-js"><code class="language-js">axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"https://autumnfish.cn/api/joke/list?num=1"</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">{</span>                        that<span class="token punctuation">.</span>joke<span class="token operator">=</span>response<span class="token punctuation">.</span>data<span class="token punctuation">.</span>jokes<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里不能通过this访问joke，this的范围已经发生了变化</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>data<span class="token punctuation">.</span>jokes<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue学习</title>
      <link href="/2020/07/08/vue%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/08/vue%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="关于自己对Vue学习的一些重点和理解"><a href="#关于自己对Vue学习的一些重点和理解" class="headerlink" title="关于自己对Vue学习的一些重点和理解"></a>关于自己对Vue学习的一些重点和理解</h4><p>学习的地方包括Vue自己的网站，菜鸟教程，B站等</p><h5 id="1-vue对象中会有两个重要的属性，el和data，表示绑定的属性和数据。"><a href="#1-vue对象中会有两个重要的属性，el和data，表示绑定的属性和数据。" class="headerlink" title="1.vue对象中会有两个重要的属性，el和data，表示绑定的属性和数据。"></a>1.vue对象中会有两个重要的属性，el和data，表示绑定的属性和数据。</h5><h5 id="2-模板语法"><a href="#2-模板语法" class="headerlink" title="2.模板语法"></a>2.模板语法</h5><p>插值：数据绑定：文本：, v-once；原始html：v-html，将html文本转换为html样式；作用于html 的attribute：v-bind,</p><p>指令：指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute,一些指令可以带参数。</p><p>动态参数：可以用方括号括起来的 JavaScript 表达式作为一个指令的参数。可以使用null字符串显式的移除此属性。</p><p><strong><code>v-bind</code> 指令可以用于响应式地更新 HTML attribute，</strong></p><p><strong><code>v-on</code> 指令，它用于监听 DOM 事件,</strong>进行事件处理</p><h5 id="3-计算属性和侦听器"><a href="#3-计算属性和侦听器" class="headerlink" title="3.计算属性和侦听器"></a>3.计算属性和侦听器</h5><p>​    1.对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>computed。</p><p>​    2.我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是<strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。只要值没有发生变化，就不会再次计算属性，直接返回上一次的计算结果。而方法会每一次重新渲染时都重新计算。</p><p>​    3.Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：<strong>侦听属性</strong> </p><h5 id="4-class和style绑定"><a href="#4-class和style绑定" class="headerlink" title="4.class和style绑定"></a>4.class和style绑定</h5><p>​    1.对象语法，使用v-bind:class指令。</p><p>​    2.绑定内联样式，v-bind:style指令。是一个js对象</p><h5 id="5-条件渲染"><a href="#5-条件渲染" class="headerlink" title="5.条件渲染"></a>5.条件渲染</h5><p>​    1.v-if条件性的渲染一部分内容，使用<template>进行包裹，再使用v-if可以渲染多个内容。还有配套的 v-else,还有v-else-if进行连续使用。</p><p>​    2.v-show的使用与v-if差不多，但没有v-else这些。同时因为各自特性，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p><h5 id="6-列表渲染"><a href="#6-列表渲染" class="headerlink" title="6.列表渲染"></a>6.列表渲染</h5><p>​    1.v-for，使用item in items的格式执行。其中items需要在vue里面的data里指定数据。也可使用value in object进行对象循环，也可使用(value, name, index)进行对象里面的数据，键名，索引访问。也可以使用n in 10进行循环。类似于 <code>v-if</code>，你也可以利用带有 <code>v-for</code> 的 <code>&lt;template&gt;</code> 来循环渲染一段包含多个元素的内容。</p><h5 id="7-事件处理"><a href="#7-事件处理" class="headerlink" title="7.事件处理"></a>7.事件处理</h5><p>​    1.v-on监听dom事件，并执行一些js代码。还可以接收一个需要调用的方法名称。在vue的methods里面添加方法。</p><p>​    Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><pre><code>&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</code></pre><p>​    使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p><p>​    2.监听按键事件时，可以使用按键修饰符，如：v-on:keyup.enter，只有enter键可以触发事件。</p><h5 id="8-表单输入绑定"><a href="#8-表单输入绑定" class="headerlink" title="8.表单输入绑定"></a>8.表单输入绑定</h5><p>​    1.v-model，创建双向数据绑定，一处数据发生变化，另一处也会发生变化。</p><p>​    <code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li><li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</li><li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li></ul><p>​    2.文本，多行文本，复选框，单选按钮，选择框。</p><p>​    3.值绑定</p><p>​    4.修饰符，.lazy;.number;.trim</p><h5 id="9-组件"><a href="#9-组件" class="headerlink" title="9.组件"></a>9.组件</h5><p>​    1.组件可以扩展 HTML 元素，封装可重用的代码，是可复用的vue实例。组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树。<strong>每个组件都只有一个根元素</strong></p><p>​    2.Vue.component创建组件，第一个参数是组件名称，第二个参数是以对象的实例描述一个组件。通过将组件名作为标签进行调用。<strong>一个组件的 <code>data</code> 选项必须是一个函数</strong>，多个组件的使用，其数据都是分开的，不会互相影响。</p><p>​    3.组件需要注册，Vue.component全局注册，先在js里定义组件，再在vue实例中通过component定义想使用的组件局部注册。</p><p>​    4.组件里使用prop向子组件传递数据，当做自定义的attribute传递数据。也可使用v-bind动态传递prop，且是单向的。</p><p>​    5.监听子组件事件，父级组件可以像处理 native DOM 事件一样通过 <code>v-on</code> 监听子组件实例的任意事件：</p><pre><code>&lt;blog-post  ...  v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&gt;&lt;/blog-post&gt;</code></pre><p>同时子组件可以通过调用内建的 <a href="https://cn.vuejs.org/v2/api/#vm-emit" target="_blank" rel="noopener"><strong><code>$emit</code></strong> 方法</a>并传入事件名称来触发一个事件：</p><pre><code>&lt;button v-on:click=&quot;$emit(&#39;enlarge-text&#39;)&quot;&gt;  Enlarge text&lt;/button&gt;</code></pre><p>​    6.<slot>内容</slot>，在组件里面通过vue自定义的slot可以实现插槽效果。</p><p>​    7.动态组件，通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 <code>is</code> attribute 来实现。</p><h5 id="10-自定义事件"><a href="#10-自定义事件" class="headerlink" title="10.自定义事件"></a>10.自定义事件</h5><p>​    1.Vue.directive自定义指令，第一个参数是名字，或在vue实例中通过directives局部注册。会有几个钩子函数bind,inserted,update,componentUpdated,unbind.</p><p>差不多这篇文章就不想写了，看其他的吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猎奇作品(以后有时间会更新)</title>
      <link href="/2020/07/08/%E7%8C%8E%E5%A5%87%E4%BD%9C%E5%93%81/"/>
      <url>/2020/07/08/%E7%8C%8E%E5%A5%87%E4%BD%9C%E5%93%81/</url>
      
        <content type="html"><![CDATA[<h4 id="就是记录一下一些看过的猎奇作品"><a href="#就是记录一下一些看过的猎奇作品" class="headerlink" title="就是记录一下一些看过的猎奇作品"></a>就是记录一下一些看过的猎奇作品</h4><p>1.鱼毛骨悚然的蠕动</p><p>​        动漫观感一般，后遗感2小时以内，留的坑有些多，不讨论其内涵，就画面来说对于猎奇这点还是有一些诠释，就是有些地方密恐慎入。</p><p>2.芽衣恶虐，恶梦轮回</p><p>​        这两部作品着实有些血腥，生理性有些不适。都是漫画，大概50页左右，后遗感1小时左右吧，血腥，色情，生理性不适，<strong>慎看</strong> 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 猎奇,记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android room简单学习</title>
      <link href="/2020/07/07/android-room%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/07/android-room%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="room"><a href="#room" class="headerlink" title="room"></a>room</h3><p>1.要使用room需要先声明依赖，<a href="https://developer.android.google.cn/jetpack/androidx/releases/room#declaring_dependencies" target="_blank" rel="noopener">声明方法</a><br><strong>注意要在app模式下的build.gradle(module:app)里面添加依赖，不要在project里面的gradle里面添加。</strong></p><p>2.room由3个主要的组件，分别为<br>Database：数据库，<br>Entity：数据库中的表，<br>DAO：访问数据库的方法。</p><p>3.room可以使用一个Java类文件当做数据库的表，只需使用@Entity注解。<br>里面有几个主要的注解使用<br><strong>也可以在@Entity注解后面使用tablename声明表的名称</strong><br> <strong>@PrimaryKey(autoGenerate = true) // 设置主键，并且自动生长</strong><br> <strong>@ColumnInfo(name = “true_name”) // 设置别名，如果不设置就默认为变量名</strong><br> 在其中可以定义需要的变量且对其中每一个变量都需要写出其set方法和get方法。</p><p> 4.之后我们使用DAO来对数据库进行访问<br> 同样我们需要使用一个Java接口类文件，同时使用@DAO 注解<br> 其中里面有4个主要的注解进行使用<br> <strong>@Insert 表示插入记录。<br>@Update 表示修改数据库中的记录。<br>@Delete 表示删除数据库中记录。<br>@Query(“ “) 中可以写入SQL语句，来执行操作。</strong></p><p>5.创建一个Database，同样要使用@Database注解，且在其中需要指明entities和version<br><strong>Database 文件必须要继承 **androidx.room.RoomDatabase</strong>，并且得是抽象类。**</p><p>之后就是建立一个布局，将数据库里面的数据显示出来，并与DAO的几个操作通过点击进行交互。</p><p><a href="https://github.com/chengsong-hunnu/local-github/tree/master/room" target="_blank" rel="noopener">主要代码在这里</a></p><p>主要借鉴了<a href="https://blog.csdn.net/weixin_43734095/article/details/100182369?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">萌宅鹿</a>和<a href="https://developer.android.google.cn/training/data-storage/room" target="_blank" rel="noopener">android studio官方</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> csdn room </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp fork的一些代码运行和理解</title>
      <link href="/2020/07/07/csapp-fork%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%92%8C%E7%90%86%E8%A7%A3/"/>
      <url>/2020/07/07/csapp-fork%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%92%8C%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p><strong>1.</strong> 先说一点简单的fork定义<br>1.创建一个新进程，新进程被称为子进程。两者最大的区别在于pid不同，一般通过返回值分辨是哪个进程。<br>2.fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。<br>3.子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。各自都有自己的独立地址。<br>4.两者的执行顺序是随机并发执行的，也就是不能判断执行顺序。</p><p><strong>2</strong> 为什么fork会返回两次？<br>由于在复制时复制了父进程的堆栈段，所以两个进程都停留在fork函数中，等待返回。因此fork函数会返回两次，一次是在父进程中返回，另一次是在子进程中返回，这两次的返回值是不一样的，<strong>父进程返回子进程的pid，子进程返回0</strong><br><strong>3</strong>现在来看下一些代码吧：<br>1.</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fork1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child has x = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">++</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Parent has x = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">--</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Bye from process %d with x = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>结果：<img src="./images/loading.gif" data-original="https://img-blog.csdnimg.cn/2019110910200816.png" alt="在这里插入图片描述"><br>先fork一个子进程，这次子进程先执行，之后再试父进程，最后得到这个结果。</p><p>下面有一些关键字，<a href="https://blog.csdn.net/GEAUSE/article/details/102933742" target="_blank" rel="noopener">waitpid等</a>，可以去看一下。</p><p>2.下一个是关于僵尸进程的问题</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">fork7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Child */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Terminating Child, PID = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Running Parent, PID = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Infinite loop */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：<img src="./images/loading.gif" data-original="https://img-blog.csdnimg.cn/20191109103227316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>僵死进程</strong>：是指子进程退出时，父进程并未对其发出的SIGCHLD信号进行适当处理，导致子进程停留在僵死状态等待其父进程为其回收，这个状态下的子进程就是僵死进程。</p><p>主进程运行然后fork一个子进程，父进程因为while（1），一直在后台运行，但是子进程正常执行完程序。最后在后台卡住，使用Ctrl+z挂起这个程序，之后ps命令去看可看见这个程序的父进程（pid=4300）还是在后台挂起，只能用kill命令强制结束。</p><p><strong>3.</strong> 这个是关于孤儿进程</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">fork8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Child */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Running Child, PID = %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Infinite loop */</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Terminating Parent, PID = %d\n"</span><span class="token punctuation">,</span>                   <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：<br><img src="./images/loading.gif" data-original="https://img-blog.csdnimg.cn/20191109104910232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>孤儿进程</strong>：父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(pid=1)所收养，并由init进程对它们完成状态收集工作。</p><p>由ps命令可看见子进程（pid=4304）还在后台运行，这就是一个孤儿进程。</p><p><strong>4.</strong>关于wait</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> N 5</span><span class="token keyword">void</span> <span class="token function">fork10</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> child_status<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Child */</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Parent */</span>        pid_t wpid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>child_status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated with exit status %d\n"</span><span class="token punctuation">,</span>                   wpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">else</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminate abnormally\n"</span><span class="token punctuation">,</span> wpid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fork11</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> child_status<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Child */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> N<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pid_t wpid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>child_status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated with exit status %d\n"</span><span class="token punctuation">,</span>                   wpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">else</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminate abnormally\n"</span><span class="token punctuation">,</span> wpid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：<img src="./images/loading.gif" data-original="https://img-blog.csdnimg.cn/20191109113504188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于<strong>fork10</strong>，通过for循环先fork一个子进程，父进程进行到wait暂停，之后子进程运行exit正常退出，给出一个信号给父进程，然后根据wait的特点，父进程继续执行输出语句。</p><p>对于<strong>fork11</strong>，通过for循环先fork一个子进程，父进程进行到waitpid(pid[i],&amp;child_status, 0)暂停，之后waitpid等待着pid[i]的子进程结束，之后for（0-4）正常结束子进程，for（4-0）waitpid返回子进程结束值，之后执行输出语句。</p><p><strong>5</strong>关于信号</p><pre class=" language-c"><code class="language-c"> <span class="token operator">*</span><span class="token operator">/</span><span class="token keyword">void</span> <span class="token function">fork12</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> child_status<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Child: Infinite Loop */</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Killing process %d\n"</span><span class="token punctuation">,</span> pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">kill</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> SIGINT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//杀死此进程</span>        <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pid_t wpid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>child_status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated with exit status %d\n"</span><span class="token punctuation">,</span>wpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">else</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated abnormally\n"</span><span class="token punctuation">,</span> wpid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">*</span> fork12 <span class="token operator">-</span> Sending signals with the <span class="token function">kill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> function<span class="token punctuation">,</span>发送信号给前一个参数的进程 cheng@晟松<span class="token punctuation">:</span><span class="token operator">/</span>mnt<span class="token operator">/</span>d<span class="token operator">/</span>计算机基础代码测试<span class="token operator">/</span>chap8_code$ <span class="token punctuation">.</span><span class="token operator">/</span>forks <span class="token number">12</span>Killing process <span class="token number">34</span>Killing process <span class="token number">35</span>Killing process <span class="token number">36</span>Killing process <span class="token number">37</span>Killing process <span class="token number">38</span>Child <span class="token number">34</span> terminated abnormallyChild <span class="token number">35</span> terminated abnormallyChild <span class="token number">36</span> terminated abnormallyChild <span class="token number">37</span> terminated abnormallyChild <span class="token number">38</span> terminated abnormally <span class="token operator">*</span><span class="token operator">/</span></code></pre><p>kill（）函数就是给一个信号给进程。<a href="https://blog.csdn.net/qq_42152681/article/details/90261295" target="_blank" rel="noopener">参考kill()函数</a><br>此函数里面父进程被强制结束，子进程一直循环，结果子进程被系统自动回收，WIFEXITED()不能得到信号，最后显示出子进程被异常终止。</p>]]></content>
      
      
      
        <tags>
            
            <tag> csdn fork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的建立</title>
      <link href="/2020/07/07/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
      <url>/2020/07/07/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
      
        <content type="html"><![CDATA[<p>对这个博客，确实有很多的问题，自己都删了好几次文件，从新来搞，才搞成这样，可能还有一些的问题在里面，等后面发现了，就继续改进。现在就有一些问题就很烦，就是github.io过一段时间就不能进行访问了，相当于这个网页就没了，就是这个问题搞了好久，最后只能重新重头开始再搞一次。在网上也没找到什么解决办法，看后面怎么搞。下一个就是关于这个github和自己的域名的链接，上次一搞就崩了，希望这次不崩。</p><h4 id="首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。"><a href="#首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。" class="headerlink" title="首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。"></a>首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。</h4><p>1.<a href="https://yafine-blog.cn/posts/4ab2.html#1-%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B8%83%E5%88%B0Github-Pages" target="_blank" rel="noopener">过客～励む</a></p><p>2.<a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">遇见西门</a></p><p>3.<a href="https://space.bilibili.com/384068749/" target="_blank" rel="noopener">B站codesheep</a></p><h5 id="后面再说一下一些我碰见的问题和解决方法。"><a href="#后面再说一下一些我碰见的问题和解决方法。" class="headerlink" title="后面再说一下一些我碰见的问题和解决方法。"></a>后面再说一下一些我碰见的问题和解决方法。</h5><p>首先是域名的问题，这里参考遇见西门的博客的域名方法就行，记住不要直接在github建立CNAME文件，需要在本地建立CNAME文件，再上传，之后在github链接域名。</p><p>后面的一个问题是新建博客，使用的命令是<strong>hexo n “新建的博客名”</strong>,因为是md文件，所以需要你自己下一个md文件格式的编辑器，例如typora等，最后，你的文件写的时候，一般会添加tag，一定要tag:后面加一个空格，再加你的tag，不然会出现错误。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客建立 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
