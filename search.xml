<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue学习</title>
      <link href="/2020/07/08/vue%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/08/vue%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="关于自己对Vue学习的一些重点和理解"><a href="#关于自己对Vue学习的一些重点和理解" class="headerlink" title="关于自己对Vue学习的一些重点和理解"></a>关于自己对Vue学习的一些重点和理解</h4><p>学习的地方包括Vue自己的网站，菜鸟教程，B站等</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猎奇作品(以后有时间会更新)</title>
      <link href="/2020/07/08/%E7%8C%8E%E5%A5%87%E4%BD%9C%E5%93%81/"/>
      <url>/2020/07/08/%E7%8C%8E%E5%A5%87%E4%BD%9C%E5%93%81/</url>
      
        <content type="html"><![CDATA[<h4 id="就是记录一下一些看过的猎奇作品"><a href="#就是记录一下一些看过的猎奇作品" class="headerlink" title="就是记录一下一些看过的猎奇作品"></a>就是记录一下一些看过的猎奇作品</h4><p>1.鱼毛骨悚然的蠕动</p><p>​        动漫观感一般，后遗感2小时以内，留的坑有些多，不讨论其内涵，就画面来说对于猎奇这点还是有一些诠释，就是有些地方密恐慎入。</p><p>2.芽衣恶虐，恶梦轮回</p><p>​        这两部作品着实有些血腥，生理性有些不适。都是漫画，大概50页左右，后遗感1小时左右吧，血腥，色情，生理性不适，<strong>慎看</strong> 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 猎奇,记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android room简单学习</title>
      <link href="/2020/07/07/android-room%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/07/android-room%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="room"><a href="#room" class="headerlink" title="room"></a>room</h3><p>1.要使用room需要先声明依赖，<a href="https://developer.android.google.cn/jetpack/androidx/releases/room#declaring_dependencies" target="_blank" rel="noopener">声明方法</a><br><strong>注意要在app模式下的build.gradle(module:app)里面添加依赖，不要在project里面的gradle里面添加。</strong></p><p>2.room由3个主要的组件，分别为<br>Database：数据库，<br>Entity：数据库中的表，<br>DAO：访问数据库的方法。</p><p>3.room可以使用一个Java类文件当做数据库的表，只需使用@Entity注解。<br>里面有几个主要的注解使用<br><strong>也可以在@Entity注解后面使用tablename声明表的名称</strong><br> <strong>@PrimaryKey(autoGenerate = true) // 设置主键，并且自动生长</strong><br> <strong>@ColumnInfo(name = “true_name”) // 设置别名，如果不设置就默认为变量名</strong><br> 在其中可以定义需要的变量且对其中每一个变量都需要写出其set方法和get方法。</p><p> 4.之后我们使用DAO来对数据库进行访问<br> 同样我们需要使用一个Java接口类文件，同时使用@DAO 注解<br> 其中里面有4个主要的注解进行使用<br> <strong>@Insert 表示插入记录。<br>@Update 表示修改数据库中的记录。<br>@Delete 表示删除数据库中记录。<br>@Query(“ “) 中可以写入SQL语句，来执行操作。</strong></p><p>5.创建一个Database，同样要使用@Database注解，且在其中需要指明entities和version<br><strong>Database 文件必须要继承 **androidx.room.RoomDatabase</strong>，并且得是抽象类。**</p><p>之后就是建立一个布局，将数据库里面的数据显示出来，并与DAO的几个操作通过点击进行交互。</p><p><a href="https://github.com/chengsong-hunnu/local-github/tree/master/room" target="_blank" rel="noopener">主要代码在这里</a></p><p>主要借鉴了<a href="https://blog.csdn.net/weixin_43734095/article/details/100182369?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">萌宅鹿</a>和<a href="https://developer.android.google.cn/training/data-storage/room" target="_blank" rel="noopener">android studio官方</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> csdn room </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp fork的一些代码运行和理解</title>
      <link href="/2020/07/07/csapp-fork%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%92%8C%E7%90%86%E8%A7%A3/"/>
      <url>/2020/07/07/csapp-fork%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%92%8C%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p><strong>1.</strong> 先说一点简单的fork定义<br>1.创建一个新进程，新进程被称为子进程。两者最大的区别在于pid不同，一般通过返回值分辨是哪个进程。<br>2.fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。<br>3.子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。各自都有自己的独立地址。<br>4.两者的执行顺序是随机并发执行的，也就是不能判断执行顺序。</p><p><strong>2</strong> 为什么fork会返回两次？<br>由于在复制时复制了父进程的堆栈段，所以两个进程都停留在fork函数中，等待返回。因此fork函数会返回两次，一次是在父进程中返回，另一次是在子进程中返回，这两次的返回值是不一样的，<strong>父进程返回子进程的pid，子进程返回0</strong><br><strong>3</strong>现在来看下一些代码吧：<br>1.</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fork1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child has x = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">++</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Parent has x = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">--</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Bye from process %d with x = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>结果：<img src="https://img-blog.csdnimg.cn/2019110910200816.png" alt="在这里插入图片描述"><br>先fork一个子进程，这次子进程先执行，之后再试父进程，最后得到这个结果。</p><p>下面有一些关键字，<a href="https://blog.csdn.net/GEAUSE/article/details/102933742" target="_blank" rel="noopener">waitpid等</a>，可以去看一下。</p><p>2.下一个是关于僵尸进程的问题</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">fork7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Child */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Terminating Child, PID = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Running Parent, PID = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Infinite loop */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：<img src="https://img-blog.csdnimg.cn/20191109103227316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>僵死进程</strong>：是指子进程退出时，父进程并未对其发出的SIGCHLD信号进行适当处理，导致子进程停留在僵死状态等待其父进程为其回收，这个状态下的子进程就是僵死进程。</p><p>主进程运行然后fork一个子进程，父进程因为while（1），一直在后台运行，但是子进程正常执行完程序。最后在后台卡住，使用Ctrl+z挂起这个程序，之后ps命令去看可看见这个程序的父进程（pid=4300）还是在后台挂起，只能用kill命令强制结束。</p><p><strong>3.</strong> 这个是关于孤儿进程</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">fork8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Child */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Running Child, PID = %d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Infinite loop */</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Terminating Parent, PID = %d\n"</span><span class="token punctuation">,</span>                   <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：<br><img src="https://img-blog.csdnimg.cn/20191109104910232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>孤儿进程</strong>：父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(pid=1)所收养，并由init进程对它们完成状态收集工作。</p><p>由ps命令可看见子进程（pid=4304）还在后台运行，这就是一个孤儿进程。</p><p><strong>4.</strong>关于wait</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> N 5</span><span class="token keyword">void</span> <span class="token function">fork10</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> child_status<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Child */</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Parent */</span>        pid_t wpid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>child_status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated with exit status %d\n"</span><span class="token punctuation">,</span>                   wpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">else</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminate abnormally\n"</span><span class="token punctuation">,</span> wpid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">fork11</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> child_status<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Child */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> N<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pid_t wpid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>child_status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated with exit status %d\n"</span><span class="token punctuation">,</span>                   wpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">else</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminate abnormally\n"</span><span class="token punctuation">,</span> wpid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果：<img src="https://img-blog.csdnimg.cn/20191109113504188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于<strong>fork10</strong>，通过for循环先fork一个子进程，父进程进行到wait暂停，之后子进程运行exit正常退出，给出一个信号给父进程，然后根据wait的特点，父进程继续执行输出语句。</p><p>对于<strong>fork11</strong>，通过for循环先fork一个子进程，父进程进行到waitpid(pid[i],&amp;child_status, 0)暂停，之后waitpid等待着pid[i]的子进程结束，之后for（0-4）正常结束子进程，for（4-0）waitpid返回子进程结束值，之后执行输出语句。</p><p><strong>5</strong>关于信号</p><pre class=" language-c"><code class="language-c"> <span class="token operator">*</span><span class="token operator">/</span><span class="token keyword">void</span> <span class="token function">fork12</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> child_status<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* Child: Infinite Loop */</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Killing process %d\n"</span><span class="token punctuation">,</span> pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">kill</span><span class="token punctuation">(</span>pid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> SIGINT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//杀死此进程</span>        <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pid_t wpid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>child_status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated with exit status %d\n"</span><span class="token punctuation">,</span>wpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>child_status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">else</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d terminated abnormally\n"</span><span class="token punctuation">,</span> wpid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">*</span> fork12 <span class="token operator">-</span> Sending signals with the <span class="token function">kill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> function<span class="token punctuation">,</span>发送信号给前一个参数的进程 cheng@晟松<span class="token punctuation">:</span><span class="token operator">/</span>mnt<span class="token operator">/</span>d<span class="token operator">/</span>计算机基础代码测试<span class="token operator">/</span>chap8_code$ <span class="token punctuation">.</span><span class="token operator">/</span>forks <span class="token number">12</span>Killing process <span class="token number">34</span>Killing process <span class="token number">35</span>Killing process <span class="token number">36</span>Killing process <span class="token number">37</span>Killing process <span class="token number">38</span>Child <span class="token number">34</span> terminated abnormallyChild <span class="token number">35</span> terminated abnormallyChild <span class="token number">36</span> terminated abnormallyChild <span class="token number">37</span> terminated abnormallyChild <span class="token number">38</span> terminated abnormally <span class="token operator">*</span><span class="token operator">/</span></code></pre><p>kill（）函数就是给一个信号给进程。<a href="https://blog.csdn.net/qq_42152681/article/details/90261295" target="_blank" rel="noopener">参考kill()函数</a><br>此函数里面父进程被强制结束，子进程一直循环，结果子进程被系统自动回收，WIFEXITED()不能得到信号，最后显示出子进程被异常终止。</p>]]></content>
      
      
      
        <tags>
            
            <tag> csdn fork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统基础二</title>
      <link href="/2020/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
      <url>/2020/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机系统基础（二）"><a href="#计算机系统基础（二）" class="headerlink" title="计算机系统基础（二）"></a>计算机系统基础（二）</h2><h4 id="5-优化程序性能"><a href="#5-优化程序性能" class="headerlink" title="5    优化程序性能"></a>5    优化程序性能</h4><p>1.用度量标准（CPE）<strong>每元素的周期数</strong><br>2.一般优化方面为：消除循环的低效率（尽量顺序循环），减少过程调用，消除不必要的内存引用。</p><h4 id="6-存储器层次结构"><a href="#6-存储器层次结构" class="headerlink" title="6 存储器层次结构"></a>6 存储器层次结构</h4><p>1.随机访问存储器（RAM）:静态（SRAM）不需要刷新，稳定，一般用于高速缓存；动态（DRAM）不稳定，一般用于主存。都是易失的（断电就没了）<br>2.非易失性存储器（ROM），整体上都被称为只读存储器。一般用于外存<br>3.磁盘：由盘片组成，一般有多张盘片，磁道，扇区。</p><p>容量一般由记录密度，磁道密度，面密度决定。<br>容量 = 每个扇区的字节数 x 磁道上的平均扇区数 x 磁盘一面的磁道数 x 磁盘的面数 x 硬盘包含的磁盘数<br>访问时间一般由寻道时间，旋转时间，传送时间决定。<br>总的访问时间 = 寻址时间 + 旋转时间 + 传输时间 </p><p>寻址时间 因为物理规律的限制，一般是 3-9 ms<br>旋转延迟 取决于硬盘具体的转速，一般来说是 7200 RPM<br>传输时间 就是需要读取的扇区数目<br><img src="https://img-blog.csdnimg.cn/20191116121449266.png" alt="在这里插入图片描述"><br>4.固态硬盘<br>固态硬盘中分成很多的块，每个块又有很多页，大约 32-128 个，每个页可以存放一定数据，页是进行数据读写的最小单位。但是有一点需要注意，对一个页进行写入操作的时候，需要先把整个块清空（设计限制），而一个块大概在 100,000 次写入之后就会报废。<br>5.局部性<br>时间局部性： 如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。程序循环、堆栈等是产生时间局部性的原因。<br>空间局部性: 在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的<br>顺序局部性: 在典型程序中，除转移类指令外，大部分指令是顺序进行的。顺序执行和非顺序执行的比例大致是5:1。此外，对大型<strong>数组</strong>访问也是顺序的。指令的顺序执行、数组的连续存放等是产生顺序局部性的原因。<br>6.高速缓存<br><img src="https://img-blog.csdnimg.cn/20191116124629347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>每一层都可以看作是下一层的缓存，主存中的信息按“块” 送到Cache中。<br>缓存命中：在对应的层中找到需要的数据<br><strong>缓存不命中</strong>：对应的层没有找到数据，需要从下一层中取出需要的数据，有时候会需要覆盖。<br>强制性失效: CPU 第一次访问相应缓存块，缓存中肯定没有对应数据，这是不可避免的。<br>冲突失效：在直接相联或组相联的缓存中，不同的缓存块由于索引相同相互替换，引起的失效叫做冲突失效。<br>容量失效: 有限的缓存容量导致缓存放不下而被替换，被替换出去的缓存块再被访问，引起的失效叫做容量失效。<br>7.高速缓冲存储器<br> 高速缓冲存储器的三个关键组成部分（注意区分大小写）：</p><p>S 表示集合(set)数量<br>E 表示数据行(line)的数量<br>B 表示每个缓存块(block)保存的字节数目<br><img src="https://img-blog.csdnimg.cn/20191116132546630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">地址宽度m=s+t+b<br><img src="https://img-blog.csdnimg.cn/20191116135814907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先确定组索引对应的组，再看有效为是否为1，再去比对标记位，最后看块偏移，得到数据。<br>标记位和索引位连起来唯一的标识内存中的每个块。</p><h4 id="7-链接"><a href="#7-链接" class="headerlink" title="7.链接"></a>7.链接</h4><p><a href="https://blog.csdn.net/qq_43977818/article/details/102230859#" target="_blank" rel="noopener">之前的一些记录</a></p><h4 id="8-异常控制流"><a href="#8-异常控制流" class="headerlink" title="8.异常控制流"></a>8.异常控制流</h4><p><a href="https://blog.csdn.net/qq_43977818/article/details/102983925#" target="_blank" rel="noopener">fork的一些记录</a></p><h4 id="9-虚拟内存"><a href="#9-虚拟内存" class="headerlink" title="9.虚拟内存"></a>9.虚拟内存</h4><p>1.分页，通过页表实现逻辑地址向物理地址的转换。<br>2.每个虚拟页都可以被映射到任何的物理页上。</p><h5 id="3-地址翻译："><a href="#3-地址翻译：" class="headerlink" title="3.地址翻译："></a><strong>3.地址翻译：</strong></h5><p><strong>从虚拟地址找到物理地址，再物理地址在缓存中找到数据<br>vpn在TLB中找到PPN，物理地址中的CI在缓存中找到对应的组，在CT标记位对应，最后CO 块偏移找到相应字节</strong><br>先来了解<strong>以下参数</strong>：</p><p>N=2^n^,M=2^m^,P=2^p^<br>其中 N 表示虚拟地址空间中的地址数量，M 表示物理地址空间中的地址数量，P 是每一页包含的字节数(page size)。</p><p>虚拟地址(VA, Virtual Address)中的元素：</p><p>TLBI: TLB 的索引值<br>TLBT: TLB 的标签(tag)<br>VPO: 虚拟页偏移量<br>VPN: 虚拟页编号<br>物理地址(PA, physical address)中的元素：</p><p>PPO: 物理页偏移量（与 VPO 的值相同）<br>PPN: 物理页编号<br><img src="https://img-blog.csdnimg.cn/20191116232117177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>具体的访问过程为</strong>：</p><p>通过虚拟地址找到页表(page table)中对应的条目<br>检查有效位(valid bit)，是否需要触发页错误(page fault)<br>然后根据页表中的物理页编号(physical page number)找到内存中的对应地址<br>最后把虚拟页偏移(virtual page offset)和前面的实际地址拼起来，就是最终的物理地址了<br>这里又分两种情况：Page Hit 和 Page Fault。<br><img src="https://img-blog.csdnimg.cn/20191123110317476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20191123110746831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.C程序中的内存错误（P609）</p>]]></content>
      
      
      
        <tags>
            
            <tag> csdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的建立</title>
      <link href="/2020/07/07/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
      <url>/2020/07/07/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
      
        <content type="html"><![CDATA[<p>对这个博客，确实有很多的问题，自己都删了好几次文件，从新来搞，才搞成这样，可能还有一些的问题在里面，等后面发现了，就继续改进。现在就有一些问题就很烦，就是github.io过一段时间就不能进行访问了，相当于这个网页就没了，就是这个问题搞了好久，最后只能重新重头开始再搞一次。在网上也没找到什么解决办法，看后面怎么搞。下一个就是关于这个github和自己的域名的链接，上次一搞就崩了，希望这次不崩。</p><h4 id="首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。"><a href="#首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。" class="headerlink" title="首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。"></a>首先感谢这几位大佬的参考资料，不然有许多的问题都不知道怎么搞。</h4><p>1.<a href="https://yafine-blog.cn/posts/4ab2.html#1-%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B8%83%E5%88%B0Github-Pages" target="_blank" rel="noopener">过客～励む</a></p><p>2.<a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">遇见西门</a></p><p>3.<a href="https://space.bilibili.com/384068749/" target="_blank" rel="noopener">B站codesheep</a></p><h5 id="后面再说一下一些我碰见的问题和解决方法。"><a href="#后面再说一下一些我碰见的问题和解决方法。" class="headerlink" title="后面再说一下一些我碰见的问题和解决方法。"></a>后面再说一下一些我碰见的问题和解决方法。</h5><p>首先是域名的问题，这里参考遇见西门的博客的域名方法就行，记住不要直接在github建立CNAME文件，需要在本地建立CNAME文件，再上传，之后在github链接域名。</p><p>后面的一个问题是新建博客，使用的命令是<strong>hexo n “新建的博客名”</strong>,因为是md文件，所以需要你自己下一个md文件格式的编辑器，例如typora等，最后，你的文件写的时候，一般会添加tag，一定要tag:后面加一个空格，再加你的tag，不然会出现错误。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客建立 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csdn上的一些以前写的东西</title>
      <link href="/2020/07/07/csdn%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A5%E5%89%8D%E5%86%99%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
      <url>/2020/07/07/csdn%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%A5%E5%89%8D%E5%86%99%E7%9A%84%E4%B8%9C%E8%A5%BF/</url>
      
        <content type="html"><![CDATA[<p>csdn以前的一些东西</p><h2 id="计算机系统基础（一）"><a href="#计算机系统基础（一）" class="headerlink" title="计算机系统基础（一）"></a>计算机系统基础（一）</h2><p>1.关于计算机基础方面的一些理解</p><pre><code>对于这门课，我在刚接触的时候，跟我刚接触C语言一样，这到底讲的是个什么啊。但是经过这半个学期的学习，我其实还是懂了一些了，这门课其实是为了写出更加优美的代码，其实也就是去理解计算机的底层到底是怎样去运行的。这些底层的东西，对于我们来说其实是一个通往一个更高的水平的路，我们需要的就是去理解，去学习。</code></pre><p>好，现在从第一章开始。</p><p><strong>第一章 计算机系统漫游</strong></p><pre><code>    这一部分其实我还真的不理解，这一部分要求我们学习更多的知识才能理解，但我自己对这一部分的理解也就是一个总览，看看就好，不必深究。</code></pre><p><strong>第二章 信息的表示和处理</strong><br><strong>2.1    信息存储</strong><br>            一个字节由8位组成        十六进制由0x开头，由0-F十六个字符表示，可大小写混合。<br>        <strong>进制转换：</strong><br>        十六进制转换为二进制，直接把相应的字符转换为对应的4位二进制就行。<br>        十进制转换为十六进制，直接十进制数除以16，取其剩下的余数，再用那个16的倍数再次除以16继续取其余数，再反向排序余数<br>        十进制转换为二进制与上面也差不多，只是除数变为2。<br>        <strong>字数据大小</strong><br>        <img src="https://img-blog.csdnimg.cn/20190501200525609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">对于一个w位的机器，程序最多访问2^w个字节。也就是0 - 2^w<br>        64位机器可以运行32位的程序，这是一种向后兼容。<br>        我们将程序成为32位 64位 只是区别于程序是如何编译的，而不是其运行的机器类型。<br>        ps：所有的指针类型都是8个字节。<br>小端模式：低位数据放在低地址中。如0x01234567         67就是低位数据放在低地址中。大端模式与其相反。<br>        <strong>布尔代数：</strong>~        &amp;        |        ^四种运算。运算时按位相运算就是了。<br>        要保持原数不变，就是与1相与，十六进制的布尔运算先转换为二进制在按位相运算。<br>        <strong>移位运算</strong>：左移直接移就是了，右移有算术和逻辑两种，算数补符号位，逻辑补0。用’&lt;&lt;’表示左移<br>                                    ‘&gt;&gt;’表示右移。</p><p><strong>2.2 整数表示</strong><br>        整数有有符号和无符号两种，有符号数的最大值要比最小值的绝对值小1。|Tmin| = |Tmax|+1.<br>        有符号数的第一位用来表示正负，用来计算十进制数时，第一位用负数参与计算，之后的数以正数加至第一个负数，最后得到其值。<br>        有符号数和无符号数一起参与运算时的时候，要将有符号数转化为无符号数。<br>        无符号数和补码的转换就是一个大小的适配。也就是加或减2^w。<br>        <strong>扩展</strong>：无符号数添0，有符号数添符号位。<br>        <strong>截断</strong>：将一个w位的数字截断为k位，就是丢弃高w-k位。<br>        <strong>整数运算</strong>：<br>        无符号数加法：当两个数相加之后的结果没有超过相对应的范围时，就不去管；如果超过了，就减去最大范围，剩下的就是最后的结果。<br>        补码加法：有正溢出和负溢出两种，也是相应的对2^w相对应运算。<br>当要求一个负数表示的二进制代码时，可以先将它的绝对值用二进制表示出来，之后再将其取补就是了。<br>        <strong>取补</strong>：二进制数从后向前数的第一个1之前的数全部取反就是取补。ps：补码的非也就是取补。<br>        ps：一般两数相加超过最大的表示范围时，就直接截断超过的那些位，留下该表示的位数。<br>        <strong>无符号和有符号数的乘法</strong>：<br>        <img src="https://img-blog.csdnimg.cn/20190501213026781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        <strong>2.4   浮点数</strong><br>        符号数的小数点左移相当于除法，小数点右移相当于乘法<br>对于数来说，左移相当于乘法，右移相当于除法<img src="https://img-blog.csdnimg.cn/20190501213145130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        对于规格数，需要的是M=1+frac；E=Exp−Bias<br>而非规格数，就只是M=frac；而且E=1-bias。<img src="https://img-blog.csdnimg.cn/20190501213200636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        <img src="https://img-blog.csdnimg.cn/20190501213209871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>        当阶码全为1，小数域全为0时，表示无穷     称为‘NaN’。<br>        <strong>舍入</strong>：<br>        舍去：多余位小于最低位的一半<br>        +一半：多余位大于最低位的一半<br>        当多余位和最低位的一半时：<br>        舍：最低位为0<br> +一半：最低位不为0</p><p>浮点数的细节舍入和溢出问题：<br>从int变为float，数字不会溢出，但可能被舍入<br>从int或float变为double，因为double有更大的范围，所以能精确保留数值<br>从double变为float，因为float的范围小，可能会溢出为无穷，也可能舍入<br>从float或double变为int，值会向0舍入</p><p><strong>第三章：程序的机器级表示</strong></p><p>程序计数器（也称pc）：给出将要执行的下一条指令在内存中的地址。<br>寄存器：有的寄存器用来保存某些重要的程序状态，而其他的用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。</p><p>gcc -s test.c        产生汇编代码<br>gcc -c test.c         产生目标代码文件test.o（二进制）<br>objdump -d test.o 反汇编二进制文件成汇编代码<br>所有‘.’开头的行都是伪指令，直接无视就是了。</p><p>char     1字节         汇编后缀         b<br>short     2字节          后缀        w<br>int         4字节          后缀        l<br>long   char*        8字节        后缀      q<br>ps;指针都是8字节</p><p><img src="https://img-blog.csdnimg.cn/20190502084629606.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于 movq 指令来说，需要源操作数和目标操作数，源操作数可以是立即数、寄存器值或内存值的任意一种，但目标操作数只能是寄存器值或内存值。指令的具体格式可以这样写 movq [Imm|Reg|Mem], [Reg|Mem]，第一个是源操作数，第二个是目标操作数。<br>但我们没有办法用一条指令完成内存间的数据交换。</p><p>而mov指令的后缀与目的操作数有关<br>ps：当目的操作数为内存引用时，就要看源操作数。<br>有时还会进行扩展，movz表示0扩展    movs表示符号扩展</p><p>在汇编代码中用小括号表示取地址<br>前六个寄存器(%rax, %rbx, %rcx, %rdx, %rsi, %rdi)称为通用寄存器，有其『特定』的用途：<br>o        %rax(%eax) 用于做累加           %rax 也用于函数的返回<br>o        %rcx(%ecx) 用于计数<br>o        %rdx(%edx) 用于保存数据<br>o        %rbx(%ebx) 用于做内存查找的基础地址<br>o        %rsi(%esi) 用于保存源索引值<br>o        %rdi(%edi) 用于保存目标索引值<br>而 %rsp(%esp) 和 %rbp(%ebp) 则是作为栈指针和基指针来使用的。</p><p>首先要理解的是，寄存器中存储着当前正在执行的程序的相关信息：<br>o临时数据存放在 (%rax, …)<br>o运行时栈的地址存储在 (%rsp) 中<br>o目前的代码控制点存储在 (%rip, …) 中<br>o目前测试的状态放在 CF, ZF, SF, OF 中</p><p>CF 进位标志    ZF 零标志    SF 符号标志    OF 溢出标志<br>其实这四个条件代码，是用来标记上一条命令的结果的各种可能的，是自动会进行设置的。<br>注意，使用 leaq 指令的话不会进行设置。</p><p>。对于寻址来说，比较通用的格式是 D(Rb, Ri, S) -&gt; Mem[Reg[Rb]+S<em>Reg[Ri]+D]，其中：<br>oD - 常数偏移量<br>oRb - 基寄存器<br>oRi - 索引寄存器，不能是 %rsp<br>oS - 系数<br>除此之外，还有如下三种特殊情况<br>o(Rb, Ri) -&gt; Mem[Reg[Rb]+Reg[Ri]]<br>oD(Rb, Ri) -&gt; Mem[Reg[Rb]+Reg[Ri]+D]<br>o(Rb, Ri, S) -&gt; Mem[Reg[Rb]+S</em>Reg[Ri]]<br>运算指令：这里以 leaq 指令为例子。具体格式为 leaq Src, Dst，其中 Src 是地址的表达式，然后把计算的值存入 Dst 指定的寄存器，也就是说，无须内存引用就可以计算，类似于 p = &amp;x[i]</p><p><img src="https://img-blog.csdnimg.cn/2019050208501234.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>移位操作：左移为乘法，右移为除法。都为2的倍数</p><p><img src="https://img-blog.csdnimg.cn/20190502085651931.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>注意：cmp s1 s2；实际是用s2-s1来比较的。<br>           test %rax %rax 用来检测%rax为正或负或零。<br>           <img src="https://img-blog.csdnimg.cn/20190502090927154.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>           跳转指令：<br><img src="https://img-blog.csdnimg.cn/20190502090945278.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>jmp 直接跳转；<br>还有一个间接跳转 加上*</p><p><img src="https://img-blog.csdnimg.cn/20190502091604548.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>do while         /while         /    for 三个循环都是用条件判断和跳转指令在汇编层面实现。<br>switch是编写一个跳转表来实现。适用于条件过多，且范围跨度较小时使用。</p><p><strong>过程调用：</strong><br>1.传递控制：包括如何开始执行过程代码，以及如何返回到开始的地方<br>2.传递数据：包括过程需要的参数以及过程的返回值<br>3.内存管理：如何在过程执行的时候分配内存，以及在返回之后释放内存<br><img src="https://img-blog.csdnimg.cn/20190502091710547.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTc3ODE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>新入栈的数据放在低地址</p><p>调用新的函数时，总是push指令保存栈，然后mov指令<br>函数调用中会利用 %rax 来保存过程调用的返回值，以便程序继续运行的。<br>如果参数没有超过六个，那么会放在：%rdi, %rsi, %rdx, %rcx, %r8, %r9 中<br>且函数内的参数后面的先入栈，前面的后入栈</p><p>递归调用的所需空间和时间都很大，增加很多额外的东西，一般避免使用递归</p>]]></content>
      
      
      
        <tags>
            
            <tag> csdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/06/hello-world/"/>
      <url>/2020/07/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post-测试是否有效"><a href="#Create-a-new-post-测试是否有效" class="headerlink" title="Create a new post 测试是否有效"></a>Create a new post 测试是否有效</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
